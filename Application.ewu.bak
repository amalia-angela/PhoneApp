$version 11.00

$rect <30,130,210,170>
$output false
class ContactsPage : Core::Group
{
  $rect <310,40,510,80>
  inherited method Init()
  {
    attachobserver onNoOfContactsChanged, ^Application::MyContactsManager.Contacts.NoOfItems;
    postsignal onNoOfContactsChanged;

    attachobserver onContactsSortingChanged, ^Application::MyContactsManager.Contacts.Sorting;
    postsignal onContactsSortingChanged;






  }

  $rect <310,80,510,120>
  inherited property Bounds = <0,0,272,440>;

  $rect <450,210,650,250>
  slot onAddPress
  {
    addContact = new Application::ContactAddPage;

    addContact.OnSave  = onSaveAdd;
    addContact.OnClose = onCancelAdd; 
    addContact.Contact = new Application::Contact;

    SwitchToDialog( addContact, Res::SlideUpCentered, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <300,210,450,250>
  var Application::ContactAddPage addContact = null;

  $rect <470,250,650,290>
  slot onSaveAdd
  {
    Application::MyContactsManager.Contacts.Add( addContact.Contact );

    DismissDialog( addContact, Res::SlideDownCentered, null, null, null, null, false);

    addContact = null;
  }

  $rect <470,290,650,330>
  slot onCancelAdd
  {
    DismissDialog( addContact, Res::SlideDownCentered, null, null, null, null, false);
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,660,140>;
  }

  $rect <900,40,1100,80>
  property int32 SelectedContact;

  $rect <900,80,1100,120>
  onset SelectedContact
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedContact == value )
      return;

    // Remember the property's new value.
    pure SelectedContact = value;

    notifyobservers ^SelectedContact; 
  }

  $rect <470,420,650,460>
  slot onDeleteContact
  {
    //the "SelectedContact" has been changed, reload item and the rest after that
    VerticalList.InvalidateItems( SelectedContact, VerticalList.NoOfItems - 1 );
     
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);
  }

  $rect <690,180,890,220>
  slot onSearch
  {
    /*var Application::Contact it = contact;
    var string filter                = SearchExt.String;
    var int32  i;
    var int32  j = 0;


    while ( it != null )
    {
      if (( it.FirstName.find( filter, 0 ) >= 0 ) ||
          ( it.LastName.find( filter, 0 ) >= 0 ))
          ///////////////////////// 
        Filtered_Array[j++] = Original_Array[i];
      
      contact = contact.next;
      j++;
    }

    // Inform the list about its changed size
    VerticalList.NoOfItems = j;
    VerticalList.InvalidateItems( 0, j );
    */
  }

  $rect <300,340,450,380>
  var Application::ContactDetailsPage detailsPage;

  $rect <470,380,650,420>
  slot onCloseContact
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,150,660,570>;
  }

  $rect <690,230,890,270>
  slot onUpPress
  {
    Application::MyContactsManager.Contacts.Sorting = Application::Sorting.Ascending;

    trace "asc";

  }

  $rect <690,270,890,310>
  slot onDownPress
  {
    Application::MyContactsManager.Contacts.Sorting = Application::Sorting.Descending;

    trace "dsc";
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <690,140,890,180>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var int32 itemNo = VerticalList.Item;

    var Application::Contact contact = Application::MyContactsManager.Contacts.GetContact( itemNo );

    var Application::ContactItem itemView = (Application::ContactItem)VerticalList.View;
                                                  
    if ( itemView == null )
      return;

    if(contact != null )
    {
      itemView.Contact = contact;
      itemView.OnActivate = onContactActivated;
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <680,40,890,80>
  slot onNoOfContactsChanged
  {
    VerticalList.NoOfItems = Application::MyContactsManager.Contacts.NoOfItems;

  }

  // Vertical list
  note group Note1
  {
    attr Bounds = <670,0,1110,320>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <10,141,260,440>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 32;
    preset ItemClass = Application::ContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -1;
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,141,260,440>;
    preset SnapNext = <0,35>;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground UpButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <235,115,261,141>;
    preset OnActivate = onUpPress;
    preset Label = Res::Uptxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground DownButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <209,115,235,141>;
    preset Enabled = true;
    preset OnActivate = onDownPress;
    preset Label = Res::DownTxt;
  }

  $rect <20,20,160,60>
  object Application::SearchEtxt SearchExt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <2,83,268,115>;
    preset OnChange = onSearch;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <11,42,261,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Contacts";
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground PlusButton
  {
    preset Bounds = <242,12,272,42>;
    preset Enabled = true;
    preset OnActivate = onAddPress;
    preset Label = Res::PlusIconTxt;
  }

  $rect <680,80,890,120>
  slot onContactsSortingChanged
  {
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
  }

  $rect <450,340,650,380>
  slot onContactActivated
  {
    var Application::ContactItem itemView = (Application::ContactItem)sender;

    if ( itemView != null )
    {
      detailsPage = new Application::ContactDetailsPage;
      detailsPage.OnBack = onCloseContact;
      detailsPage.OnDelete = onDeleteContact;

      detailsPage.Contact = itemView.Contact;
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }

  }
}

// UI Pages
note group Note
{
  attr Bounds = <0,0,410,580>;
}

// Resorces
note group Note1
{
  attr Bounds = <420,0,840,370>;
}

$rect <51,170,210,210>
$output false
class ContactItem : Core::Group
{
  $rect <290,0,490,40>
  inherited property Bounds = <0,0,272,32>;

  $rect <10,100,210,140>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GreyLight;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }




    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  $rect <230,110,430,150>
  property Application::Contact Contact = null;

  $rect <230,150,430,190>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <230,190,430,230>
  slot onContactUpdated
  {
    if ( Contact != null )
    {
      FirstNameTxt.String = pure Contact.FirstName;
      LastNameTxt.String = pure Contact.LastName;
      PrfofilButton.Text = pure Contact.NameInitials;
    }

  }

  // Contact data
  note group Note4
  {
    attr Bounds = <220,60,440,270>;
  }

  // State management
  note group Note5
  {
    attr Bounds = <0,60,220,310>;
  }

  $rect <10,260,210,300>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <10,220,210,260>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <10,180,210,220>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <10,140,210,180>
  var bool enabled;

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <580,0,780,40>
  property string Icon;

  $rect <790,0,990,40>
  property string Text = "";

  $rect <790,40,990,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <990,0,1190,40>
  property color ButtonColor = Res::White;

  $rect <990,40,1190,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <1190,0,1390,40>
  property color IconColor = Res::White;

  $rect <1190,40,1390,80>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <460,320,680,450>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <230,320,450,450>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <0,320,220,490>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <470,360,670,400>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <240,360,440,400>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <470,400,670,440>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <240,400,440,440>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <580,40,780,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <10,440,210,480>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <10,400,210,440>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <370,0,570,40>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <10,360,210,400>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <1390,0,1590,40>
  property color TextColor = Res::Black;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,32>;
    preset Point3 = <268,32>;
    preset Point2 = <268,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,32>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text LastNameTxt
  {
    preset Bounds = <55,2,146,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "LastName";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text FirstNameTxt
  {
    preset StackingPriority = 0;
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz];
    preset Bounds = <146,2,268,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "FirstName";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <272,32>;
    preset Point1 = <0,32>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall PrfofilButton
  {
    preset Bounds = <6,4,31,29>;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <267,0>;
    preset Point1 = <0,0>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }
}

$rect <50,210,210,250>
$output false
class ContactDetailsPage : Core::Group
{
  $rect <-10,510,190,550>
  inherited property Bounds = <0,0,272,440>;

  $rect <450,50,630,90>
  slot onTapEdit
  {
    edit = new Application::ContactEditPage;

    edit.OnSave  = onSaveEdit;
    edit.OnClose = onCancelEdit;
    edit.Contact = Contact;
    edit.OnDelete = onDelete;

    SwitchToDialog( edit, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );
     



  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <770,0,1240,200>;
  }

  $rect <460,210,620,250>
  slot onDelete
  {
    signal OnDelete;
    DismissDialog( edit, Res::FadeInOutCentered, null, null, null, null, false);
  }

  $rect <300,210,460,250>
  property slot OnDelete;

  $rect <300,50,450,90>
  var Application::ContactEditPage edit;

  $rect <290,280,460,320>
  var Application::CallPage call;

  $rect <460,280,640,320>
  slot onTapCall
  {
    /*call = new Application::CallPage;

    call.OnEndCall = onCallEnd;
    call.Contact = Contact;

    SwitchToDialog( call, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );  */
     

     //simulatio 
    Application::Device.UpdateCallState( Application::CallState.RingOutgoing );
    Application::Device.UpdateCallingNumber( Contact.PhoneNumber );

  }

  $rect <480,320,640,360>
  slot onCallEnd
  {
    DismissDialog( call, Res::FadeInOutCentered, null, null, null, null, false);
  }

  $rect <460,90,620,130>
  slot onSaveEdit
  {
    //Contact = Application::MyContact;
    DismissDialog( edit, Res::FadeInOutCentered, null, null, null, null, false);
  }

  $rect <460,130,620,170>
  slot onCancelEdit
  {
    DismissDialog( edit, Res::FadeInOutCentered, null, null, null, null, false);
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,760,480>;
  }

  $rect <300,170,460,210>
  property slot OnBack;

  $rect <460,170,620,210>
  slot onBack
  {
    signal OnBack;
  }

  $rect <790,90,980,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <790,130,980,170>
  slot onContactUpdated
  {
    if ( pure Contact != null )
    {
      ContactName.String =       pure Contact.LastName + " "  + pure Contact.FirstName;
      NumberTxt.String = pure Contact.PhoneNumber; 
      
      UserInitialsBtn.Initials =  pure Contact.NameInitials;
      
    }

  }

  $rect <790,50,980,90>
  property Application::Contact Contact;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <265,310>;
    preset Point1 = <7,310>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text NumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <19,281,263,310>;
    preset ColorBR = #FFFFFF00;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = " +0749320298";
    preset Font = Res::ContactFont15;
    preset Color = Res::Blue;
  }

  $rect <20,20,160,60>
  object Views::Text MobileTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <7,255,265,288>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = " mobile";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <265,255>;
    preset Point1 = <7,255>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumBlue CallBtn
  {
    preset Bounds = <51,160,101,235>;
    preset OnActivate = onTapCall;
    preset Icon = Res::CallTxt;
    preset Descrip = "call";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumBlue VideoCallBtn
  {
    preset Bounds = <111,160,161,235>;
    preset Enabled = false;
    preset Icon = Res::VideoCallTxt;
    preset Descrip = "video";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumBlue PushButtonMediumBlue2
  {
    preset Bounds = <171,160,221,235>;
    preset Enabled = false;
    preset Icon = Res::MessageIconTxt;
    preset Descrip = "message";
  }

  $rect <20,20,160,60>
  object Views::Text ContactName
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,113,268,143>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont29;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitialsBtn
  {
    preset Bounds = <101,22,171,113>;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground EditBtn
  {
    preset Bounds = <240,4,265,29>;
    preset OnActivate = onTapEdit;
    preset Label = Res::EditIconTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground BackBtn
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onBack;
    preset Label = Res::BackIconTxt;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,90,630,130>
$output false
class PushButtonMediumBlue : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,50,75>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */


    // Update the parameters of the text view (label)
    if ( IconTxt != null )
    {
       var color clr = Res::White; 
      IconTxt.Font   = Res::IconsFont20;
      IconTxt.String = Icon;
      IconTxt.Color  = clr;
      }

    if ( DescripTxt != null )
    {
       var color clr = Res::Blue; 
      DescripTxt.Font      = Res::ContactFont12;
      DescripTxt.String = Descrip;
      DescripTxt.Color     = clr;
      }

    if ( !isEnabled )
    {
      Background.Color = Res::Grey;
      DescripTxt.Color = Res::Grey;
       IconTxt.Color   = Res::GreyLight;
    }                  

    else if ( isPressed )
    {
      Background.Color = Res::BlueLight;
    }

    else if ( isSelected )
    {
      Background.Color = Res::Blue;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = Res::Blue;
    }



    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,50,50>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,50>;
    preset Point3 = <50,50>;
    preset Point2 = <50,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <1,0,50,50>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <450,50,650,90>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Icon = "";

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Bounds = <0,50,50,75>;
    preset Font = Res::ContactFont12;
    preset Color = Res::Blue;
  }

  $rect <650,10,850,50>
  property string Descrip = "";

  $rect <650,50,850,90>
  onset Descrip
  {
    // The value doesn't change - nothing to do.
    if ( pure Descrip == value )
      return;

    // Remember the property's new value.
    pure Descrip = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,50,630,90>
$output false
class PushButtonBig : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,70,91>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    // Update the parameters of the text view (label)
    if ( Text != null )
    {
       var color clr = InitialsColor; 
      Text.Font      = Res::TitileFont25;
      Text.String = Initials;
      Text.Color     = clr;
      }

      // Update the parameters of the text view (label)
    if ( DescripTxt != null )
    {
       var color clr = DescriptColor; 
      DescripTxt.Font      = Res::ContactFont12;
      DescripTxt.String = Descript;
      DescripTxt.Color     = clr;
      }


    if ( !isEnabled )
    {
      Background.Color = Res::Grey;
      DescripTxt.Visible = false;
      //Border.Color     = #CCCCCCFF;
      //Border.Width     = 1;
    }

    else if ( isPressed )
    {
      Background.Color = Res::Grey;
      //Border.Color     = #000000FF;
     // Border.Width     = 3;
    }

    else if ( isSelected )
    {
      Background.Color =Res::Grey;
     // Border.Color     = #444444FF;
     // Border.Width     = 3;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = Res::Grey;
     // Border.Color     = #444444FF;
     // Border.Width     = 1;
    }



    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <450,50,650,90>
  onset Initials
  {
    // The value doesn't change - nothing to do.
    if ( pure Initials == value )
      return;

    // Remember the property's new value.
    pure Initials = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Initials = "";

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,70,70>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundBig;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,91>;
    preset Point3 = <70,91>;
    preset Point2 = <70,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,70,70>;
    preset String = "";
    preset Font = Res::IconsFont30;
    preset Color = #FFFFFFFF;
  }

  $rect <240,70,440,110>
  property color Property;

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Bounds = <0,70,70,91>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertBottom];
    preset String = "";
    preset Font = Res::ContactFontBold15;
  }

  $rect <870,10,1070,50>
  property string Descript = "";

  $rect <870,50,1070,90>
  onset Descript
  {
    // The value doesn't change - nothing to do.
    if ( pure Descript == value )
      return;

    // Remember the property's new value.
    pure Descript = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <1080,10,1280,50>
  property color DescriptColor = Res::Blue;

  $rect <1080,50,1280,90>
  onset DescriptColor
  {
    // The value doesn't change - nothing to do.
    if ( pure DescriptColor == value )
      return;

    // Remember the property's new value.
    pure DescriptColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <660,10,860,50>
  property color InitialsColor = Res::White;

  $rect <660,50,860,90>
  onset InitialsColor
  {
    // The value doesn't change - nothing to do.
    if ( pure InitialsColor == value )
      return;

    // Remember the property's new value.
    pure InitialsColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,170,630,210>
$output false
class PushButtonSmall : Templates::PushButton
{
  $rect <20,400,220,440>
  inherited property Bounds = <0,0,25,25>;

  $rect <710,260,910,300>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    // Update the parameters of the text view (label)
    if ( TextText != null )
    {
      var color clr = TextColor; 
      TextText.Font      = Res::ContactFont12;
      TextText.String = Text;
      TextText.Color     = clr;
      }
      // Update the parameters of the text view (label)
    if ( IconTxt != null )
    {
      var color clr = IconColor; 
      IconTxt.Font      = Res::IconsFont20;
      IconTxt.String = Icon;
      IconTxt.Color     = clr;
    }

    if ( !isEnabled )
    {
      Background.Color = Res::PressColor;
      //Border.Color     = #CCCCCCFF;
      //Border.Width     = 1;
    }

    else if ( isPressed )
    {
      Background.Color = ButtonColor;
      //Border.Color     = #000000FF;
     // Border.Width     = 3;
    }

    else if ( isSelected )
    {
      Background.Color = ButtonColor;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,220,920,470>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,220,690,350>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,220,460,350>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,220,230,390>;
  }

  // This variable stores the current state of the button.
  $rect <710,380,910,420>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,340,910,380>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,300,910,340>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,260,680,300>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,260,450,300>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,300,680,340>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,300,450,340>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,340,220,380>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,300,220,340>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,260,220,300>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <250,40,450,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <250,0,450,40>
  property string Text = "";

  $rect <710,420,910,460>
  var Views::Text textView;

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <50,0,250,40>
  property slot OnActivate = null;

  $rect <460,0,660,40>
  property color ButtonColor = Res::Grey;

  $rect <460,40,660,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    InvalidateViewState();
  }

  $rect <250,90,450,130>
  property color TextColor = Res::White;

  $rect <250,130,450,170>
  onset TextColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColor == value )
      return;

    // Remember the property's new value.
    pure TextColor = value;

    InvalidateViewState();
  }

  $rect <660,0,860,40>
  property string Icon;

  $rect <660,40,860,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    InvalidateViewState();
  }

  $rect <660,90,860,130>
  property color IconColor = Res::Grey;

  $rect <660,130,860,170>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,25,25>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,25>;
    preset Point3 = <25,25>;
    preset Point2 = <25,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <0,0,25,25>;
    preset String = "";
    preset Font = Res::IconsFont25;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text TextText
  {
    preset Bounds = <0,0,25,25>;
    preset String = "";
    preset Font = Res::IconsFont25;
    preset Color = #FFFFFFFF;
  }

  $reorder Bounds 1
  $reorder first 1
  $reorder last 1
  $reorder keyHandlers 1
  $reorder buffer 1
  $reorder dialogStack 1
  $reorder fadersQueue 1
  $reorder pendingFader 1
  $reorder processKeyHandlers 1
  $reorder updateBufferSlot 1
  $reorder drawContent 1
  $reorder recalculateLayout 1
  $reorder updateComponent 1
  $reorder OnSetFocus 1
  $reorder OnGetBuffered 1
  $reorder OnSetBuffered 1
  $reorder OnGetEnabled 1
  $reorder OnSetEnabled 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder DrawForeground 1
  $reorder DrawBackground 1
  $reorder GetMinimalSize 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateLayout 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder RemoveAll 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Note4 1
  $reorder Note3 1
  $reorder Note2 1
  $reorder Note1 1
  $reorder pressed 1
  $reorder selected 1
  $reorder enabled 1
  $reorder FlashTimer 1
  $reorder KeyHandler 1
  $reorder onFlashTimer 1
  $reorder onPressKey 1
  $reorder onEnterLeaveTouch 1
  $reorder onReleaseTouch 1
  $reorder onPressTouch 1
  $reorder OnSetText 1
  $reorder Text 1
  $reorder textView 1
  $reorder OnActivate 1
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,220,630,260>
$output false
class PushButtonNoBackground : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,25,25>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */


    // Update the parameters of the text view (label)
    if ( Text != null )
    {
      var color clr = Res::Blue; 
      Text.Font      = Res::IconsFont25;
      Text.String = Label;
      Text.Color     = clr;
      }


    if ( !isEnabled )
    {
      Background.Color = Res::WhiteTransparent;
      Text.Color       = Res::Grey;
    }

    else if ( isPressed )
    {
      Background.Color = Res::WhiteTransparent;
      Text.Color       = Res::BlueLight;
    }

    else if ( isSelected )
    {
      Background.Color = Res::WhiteTransparent ;
      }

    // Enabled but not pressed nor selected.
    else
    {
     Background.Color = Res::WhiteTransparent ;
    }


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,25,25>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,25>;
    preset Point3 = <25,25>;
    preset Point2 = <25,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,25,25>;
    preset String = "";
    preset Font = Res::IconsFont25;
    preset Color = #FFFFFFFF;
  }

  $rect <450,50,650,90>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Label = "";

  $rect <710,350,910,390>
  var Views::Text textView;
}

// This component implements an editor.
$rect <639,50,830,90>
$output false
class SearchEtxt : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,266,32>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
      blinkEffect.Enabled = true;

    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }
  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point  rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32  newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
     {
      ObtainFocus();
     }
    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // The begin of the row reached? Skip to the end of the preceding row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // The end of the current row reached? Skip to the begin of the next
      // following row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  $rect <480,170,680,210>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <280,170,480,210>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <690,80,890,120>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32 inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <690,40,890,80>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <490,40,690,80>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;
  }

  $rect <290,40,490,80>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <690,120,890,160>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <490,120,690,160>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <290,120,490,160>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <690,0,890,40>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <490,0,690,40>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <290,0,490,40>
  property Resources::Font Font = Resources::FontMedium;

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  $rect <20,20,160,60>
  object Views::Frame Frame
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0, 268, 32>;
    preset Color = #F0F0F0FD;
    preset Bitmap = Res::SearchButton;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,32>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,32>;
    preset Point3 = <272,32>;
    preset Point2 = <272,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <48,2,272,32>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Search\n";
    preset Font = Resources::FontSmall;
    preset Color = #B9B9B9FD;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <50,70>;
    preset Point1 = <50,50>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text Search
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,2,41,27>;
    preset WrapText = true;
    preset String = Res::SerachIconTxt;
    preset Font = Res::IconsFont25;
    preset Color = #B9B9B9FD;
  }
}

$rect <50,290,210,330>
$output false
class ContactAddPage : Core::Group
{
  $rect <280,0,480,40>
  inherited property Bounds = <0,0,272,440>;

  $rect <760,100,960,140>
  inherited method UpdateViewState()
  {
    // Always give the ancestor class a chance to process this event.
    super( aState );

    if(Contact)
    {

    if (FirstNameTxt.String != "" ||
        LastNameTxt.String != "" ||
        PhoneNumberTxt.String !=  "")
    {
      SaveBtn.Enabled = true;
    }

    else
     SaveBtn.Enabled = false;
     }
     
  }

  $rect <311,100,511,140>
  slot onSave
  {
    notifyobservers pure Contact;
    signal OnSave;
  }

  $rect <521,100,721,140>
  property slot OnSave;

  $rect <310,240,510,280>
  property Application::Contact Contact;

  $rect <310,280,510,320>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }
  }

  $rect <310,320,510,360>
  slot onContactUpdated
  {
    Contact.FirstName    = FirstNameTxt.String;
    Contact.LastName     = LastNameTxt.String;
    Contact.PhoneNumber  = PhoneNumberTxt.String;
    Contact.NameInitials = Application::MyContactsManager.Contacts.GetInitials( LastNameTxt.String, FirstNameTxt.String);


         



  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,190,740,390>;
  }

  $rect <311,141,511,181>
  slot onClose
  {
    signal OnClose;
  }

  $rect <521,141,721,181>
  property slot OnClose;

  // Touch screen events
  note group Note
  {
    attr Bounds = <291,50,740,190>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <265,289>;
    preset Point1 = <7,289>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt PhoneNumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,257,269,289>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Blue;
    preset Placeholder = "Mobile number";
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <264,256>;
    preset Point1 = <6,256>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt FirstNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,224,269,256>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "First Name";
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <264,223>;
    preset Point1 = <6,223>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt LastNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,191,269,223>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "Last Name";
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <264,190>;
    preset Point1 = <6,190>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitials
  {
    preset Bounds = <100,78,170,169>;
    preset Descript = "Add Photo";
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <86,7,186,37>;
    preset String = "New Contact";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground SaveBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Enabled = false;
    preset OnActivate = onSave;
    preset Label = Res::CkeckIconTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground CloseButton
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onClose;
    preset Label = Res::CloseIconTxt;
  }

  $rect <530,320,730,360>
  slot onFieldChanged
  {
    UserInitials.Initials = Application::MyContactsManager.Contacts.GetInitials( LastNameTxt.String, FirstNameTxt.String );
    InvalidateViewState();
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,50,970,190>;
  }
}

$rect <50,250,210,290>
$output false
class ContactEditPage : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,440>;

  $rect <760,60,960,100>
  inherited method UpdateViewState()
  {
    // Always give the ancestor class a chance to process this event.
    super( aState );

    if(Contact)
    {

    if (Contact.FirstName != FirstNameTxt.String ||
        Contact.LastName != LastNameTxt.String ||
        Contact.PhoneNumber !=  NumberTxt.String)
    {
      SaveBtn.Enabled = true;
    }

    else
     SaveBtn.Enabled = false;
     }
     
  }

  $rect <310,50,510,90>
  slot onSave
  {
    Contact.FirstName    = FirstNameTxt.String; 
    Contact.LastName     = LastNameTxt.String;
    Contact.PhoneNumber  = NumberTxt.String;
    Contact.NameInitials = Application::MyContactsManager.Contacts.GetInitials( Contact.LastName, Contact.FirstName);

    signal OnSave;
  }

  $rect <520,50,720,90>
  property slot OnSave;

  $rect <310,91,510,131>
  slot onClose
  {
    signal OnClose;
  }

  $rect <520,91,720,131>
  property slot OnClose;

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,740,190>;
  }

  $rect <310,140,510,180>
  slot onDeleteContact
  {
    Application::MyContactsManager.Contacts.Remove( Contact );
    signal OnDelete;
  }

  $rect <310,290,510,330>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <310,330,510,370>
  slot onContactUpdated
  {
    if ( Contact != null )
    {
      FirstNameTxt.String = Contact.FirstName;
      LastNameTxt.String  = Contact.LastName;
      NumberTxt.String    = Contact.PhoneNumber;  
      UserInitials.Initials  = Contact.NameInitials;
    }

  }

  $rect <310,250,510,290>
  property Application::Contact Contact;

  $rect <520,140,720,180>
  property slot OnDelete;

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,200,740,390>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Application::PushButtonDelete DeleteBtn
  {
    preset Bounds = <5,398,263,431>;
    preset Enabled = true;
    preset OnActivate = onDeleteContact;
    preset Label = "Delete contact";
  }

  $rect <20,20,160,60>
  object Application::InputEtxt NumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <7,244,265,273>;
    preset OnChange = onFieldModified;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0749320267";
    preset Color = Res::Blue;
    preset Font = Res::ContactFont15;
    preset Placeholder = "0749320267";
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <264,239>;
    preset Point1 = <6,239>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text MobileTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <6,207,264,240>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = " mobile";
    preset Font = Res::ContactFont15;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <263,206>;
    preset Point1 = <5,206>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt FirstNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <2,174,268,206>;
    preset OnChange = onFieldModified;
    preset String = "First name";
    preset Color = Res::Black;
    preset Placeholder = "First name";
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <263,173>;
    preset Point1 = <5,173>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt LastNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <2,141,268,173>;
    preset OnChange = onFieldModified;
    preset String = "Last name";
    preset Color = Res::Black;
    preset Placeholder = "Last name";
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <263,140>;
    preset Point1 = <5,140>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitials
  {
    preset Bounds = <99,29,169,120>;
    preset Initials = "";
    preset Descript = "Add Photo";
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground CloseBtn
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onClose;
    preset Label = Res::CloseIconTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground SaveBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Enabled = false;
    preset OnActivate = onSave;
    preset Label = Res::CkeckIconTxt;
  }

  $rect <530,330,730,370>
  slot onFieldModified
  {
    UserInitials.Initials = Application::MyContactsManager.Contacts.GetInitials( LastNameTxt.String, FirstNameTxt.String );
    InvalidateViewState();
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,0,970,140>;
  }
}

$rect <470,500,630,540>
$output false
class Contact
{
  $rect <0,60,200,100>
  property string FirstName;

  $rect <0,10,200,50>
  var Application::Contact next;

  $rect <0,100,200,140>
  property string LastName;

  $rect <20,290,220,330>
  method void TraceContact()
  {
    trace FirstName + " " + LastName;
  }

  $rect <0,140,200,180>
  property string PhoneNumber;

  $rect <200,60,400,100>
  onset FirstName
  {
    // The value doesn't change - nothing to do.
    if ( pure FirstName == value )
      return;

    // Remember the property's new value.
    pure FirstName = value;

    notifyobservers this;
  }

  $rect <200,100,400,140>
  onset LastName
  {
    // The value doesn't change - nothing to do.
    if ( pure LastName == value )
      return;

    // Remember the property's new value.
    pure LastName = value;

    notifyobservers this;
  }

  $rect <200,140,400,180>
  onset PhoneNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure PhoneNumber == value )
      return;

    // Remember the property's new value.
    pure PhoneNumber = value;

    notifyobservers this;
  }

  $rect <0,180,200,220>
  property string NameInitials;

  $rect <200,180,400,220>
  onset NameInitials
  {
    // The value doesn't change - nothing to do.
    if ( pure NameInitials == value )
      return;

    // Remember the property's new value.
    pure NameInitials = value;

    notifyobservers this;
  }
}

$rect <450,460,630,500>
$output false
class Contacts
{
  $rect <0,0,200,40>
  var Application::Contact head = null;

  $rect <0,50,200,90>
  method void Add( arg Application::Contact aContact )
  {
    if ( head ==  null )
    {
      head = aContact;
      //head.NameInitials = GetInitials( aContact.LastName, aContact.FirstName );
    }  

    else
    {
     var Application::Contact lastNode   = head;
     while ( lastNode.next != null )
     {
      lastNode = lastNode.next;
      }
      lastNode.next = aContact;
      //lastNode.NameInitials = GetInitials( aContact.LastName, aContact.FirstName );
    }

    NoOfItems +=1;

  }

  $rect <0,90,200,130>
  method void Remove( arg Application::Contact aContact )
  {
    var Application::Contact contact = head;
    var Application::Contact prev = null;

    if (( contact != null) && ( contact == aContact ))
    {
      head = contact.next;
      NoOfItems -= 1;
    }
     
    else
    {
      while ((contact != null) && (contact != aContact))
      {
        prev = contact;
        contact = contact.next;
       }
       prev.next = contact.next;
       NoOfItems -= 1;
    }
  }

  $rect <0,210,200,250>
  method void TraceContacts()
  {
    var Application::Contact contact = head;

    while ( contact != null )
    {
      contact.TraceContact();
      contact = contact.next;
    }

  }

  $rect <210,0,410,40>
  property int32 NoOfItems = 0;

  $rect <210,40,410,80>
  onset NoOfItems
  {
    // The value doesn't change - nothing to do.
    if ( pure NoOfItems == value )
      return;

    // Remember the property's new value.
    pure NoOfItems = value;

    notifyobservers ^NoOfItems;

  }

  $rect <70,400,270,440>
  property string Filter;

  $rect <70,440,270,480>
  onset Filter
  {
    // The value doesn't change - nothing to do.
    if ( pure Filter == value )
      return;

    // Remember the property's new value.
    pure Filter = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <70,480,270,520>
  onget Filter
  {
    return pure Filter;
  }

  $rect <70,520,270,560>
  method int32 loadFilteredContacts( arg int32 aArg1 )
  {
    /* The template just returns the given argument... */
    return aArg1;
  }

  $rect <70,560,270,600>
  var Application::Contacts filteredContacts = null;

  $rect <0,130,200,170>
  method Application::Contact GetContact( arg int32 aNo )
  {
    var Application::Contact contact = head;
    var int32 it = 0;
    while ( it != aNo)
    {
      contact = contact.next;
      it +=1;
        
    }

    return contact;

  }

  // TO DO LATER
  note group Note
  {
    attr Bounds = <10,360,310,660>;
  }

  $rect <0,170,200,210>
  method string GetInitials( arg string aLastName, arg string aFirstName )
  {
     return aLastName[0] + "" + aFirstName[0];
  }

  $rect <430,80,630,120>
  method void insertionSort()
  {
    var Application::Contact current = head;

    while ( current != null )
    {
      //store the currents next for next iteration 
      var Application::Contact next = current.next;
      //insert cuurent in sorted liked list
      sortedInsert ( current );

      //update current 
      current = next;
    }

    head = sorted;
    sorted = null;
  }

  $rect <430,40,630,80>
  method void sortedInsert( arg Application::Contact aContact )
  {
    if ((sorted == null) || 
        ((Sorting == Application::Sorting.Ascending)  && (sorted.LastName >= aContact.LastName )) ||
        ((Sorting == Application::Sorting.Descending) && (sorted.LastName <= aContact.LastName)))
    {
      aContact.next = sorted;
      sorted = aContact;
    }

    else
    {
      var Application::Contact current = sorted;

      
     while (( current.next != null) &&
              (((Sorting == Application::Sorting.Ascending) && (current.next.LastName < aContact.LastName)) ||
              ((Sorting == Application::Sorting.Descending) && (current.next.LastName > aContact.LastName))))
      {
        current = current.next;
      }
      aContact.next = current.next;
      current.next  = aContact;
    }


  }

  $rect <430,0,630,40>
  var Application::Contact sorted = null;

  $rect <640,0,840,40>
  property Application::Sorting Sorting = Application::Sorting.None;

  $rect <640,40,840,80>
  onset Sorting
  {
    // The value doesn't change - nothing to do.
    if ( pure Sorting == value )
      return;

    // Remember the property's new value.
    pure Sorting = value;

    insertionSort();
    notifyobservers ^Sorting;
  }

  $rect <0,250,200,290>
  method Application::Contact FindByNumber( arg string aNumber )
  {
    var Application::Contact contact = head;

    while ( contact!=null )
    {
      if( contact.PhoneNumber == aNumber )
        return contact;
      contact = contact.next;
    }

    return null; 
     

  }
}

// Data
note group Note2
{
  attr Bounds = <420,380,840,580>;
}

$rect <630,420,830,460>
$output false
autoobject Application::ContactsManager MyContactsManager;

// This component implements an editor.
$rect <640,90,830,130>
$output false
class InputEtxt : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,266,32>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
    {
      blinkEffect.Enabled = true;
    }
    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }

  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point  rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32  newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
     {
      ObtainFocus();
     }
    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // The begin of the row reached? Skip to the end of the preceding row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // The end of the current row reached? Skip to the begin of the next
      // following row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal onChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal onChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal onChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal onChange;
  }

  $rect <480,170,680,210>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <280,170,480,210>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <690,80,890,120>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32 inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <690,40,890,80>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;

    postsignal updatePlaceholder;
  }

  $rect <490,40,690,80>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;

  }

  $rect <290,40,490,80>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <690,120,890,160>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <490,120,690,160>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <290,120,490,160>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <690,0,890,40>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <490,0,690,40>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <290,0,490,40>
  property Resources::Font Font = Resources::FontMedium;

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  $rect <890,40,1090,80>
  onset Placeholder
  {
    // The value doesn't change - nothing to do.
    if ( pure Placeholder == value )
      return;

    // Remember the new string ...
    pure Placeholder = value;

    TextPlaceholder.String = pure Placeholder;

    postsignal updatePlaceholder;
  }

  // The property 'String' stores the text of the editor.
  $rect <890,0,1090,40>
  property string Placeholder = "Insert Text here";

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  $rect <690,160,890,200>
  slot onChange
  {
    signal OnChange;

    postsignal updatePlaceholder;
  }

  $rect <890,160,1090,200>
  slot updatePlaceholder
  {
    //TextPlaceholder.Visible = ( String == "Text\n" );
    if( String == "Text\n" || String == "" )
      TextPlaceholder.Visible = true;
    else
      TextPlaceholder.Visible = false;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,32>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,32>;
    preset Point3 = <272,32>;
    preset Point2 = <272,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <13,2,272,32>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text\n";
    preset Font = Resources::FontSmall;
    preset Color = #1E1E1EFD;
  }

  $rect <20,20,160,60>
  object Views::Text TextPlaceholder
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <14,2,272,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontSmall;
    preset Color = #B9B9B9FD;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <0,29>;
    preset Point1 = <0,5>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,260,630,300>
$output false
class PushButtonDelete : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <6,436,264,469>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    // Update the parameters of the text view (label)
    if ( Text != null )
    {
      var color clr = Res::Red; 
      Text.Font      = Res::ContactFont15;
      Text.String = Label;
      Text.Color     = clr;
      }


    if ( !isEnabled )
    {
      Background.Color = Res::WhiteTransparent;
      Text.Color       = Res::Grey;  
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
      Text.Color       = Res::RedLight;
    }

    else if ( isSelected )
    {
      Background.Color = Res::WhiteTransparent;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = Res::WhiteTransparent;
    }



    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,258,33>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,33>;
    preset Point3 = <258,33>;
    preset Point2 = <258,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <260,10,450,50>
  property slot OnActivate = null;

  $rect <450,50,650,90>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Label = "";

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <12,0,258,33>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Delete contact";
    preset Font = Resources::FontSmall;
    preset Color = #FF295BFF;
  }
}

$rect <210,130,400,170>
$output false
class CallPage : Core::Group
{
  $rect <770,40,970,80>
  inherited method Init()
  {
    attachobserver onCallState, ^Application::Device.CallState;
    postsignal onCallState;

    ///postsignal onContactUpdated;

    getContact();


  }

  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,480>;
    preset ColorBL = Res::Grey;
    preset ColorBR = Res::GreyLight;
    preset ColorTR = Res::Grey;
    preset ColorTL = Res::Grey;
    preset Color = Res::Black;
  }

  $rect <310,90,500,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <310,130,500,170>
  slot onContactUpdated
  {
    if ( pure Contact != null )
    {
      ContactNameTxt.String  = pure Contact.LastName + " "  + pure Contact.FirstName;
      UserInitials.Initials =  pure Contact.NameInitials; 
    }
    else
    {
       ContactNameTxt.String = Application::Device.CallingNumber;
       UserInitials.Visible = false;
    }

    postsignal onContactRistoryUpdate;

  }

  $rect <310,50,500,90>
  property Application::Contact Contact = null;

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,0,750,200>;
  }

  $rect <310,250,510,290>
  property slot OnEndCall;

  $rect <520,250,720,290>
  slot onEndCallPress
  {
    Application::Device.UpdateCallState( Application::CallState.None );

    postsignal onCallState;
  }

  $rect <540,570,740,610>
  slot onSpeakerPress
  {
    //if button is pressed it changes sate from start/stop and icon PlayIcon/StopIcon

    Application::Device.Speaker =!   Application::Device.Speaker;

    SpeakerBtn.ButtonColor = Application::Device.Speaker ? Res::White : Res::WhiteTransparent;
    SpeakerBtn.IconColor   = Application::Device.Speaker ? Res::Black : Res::White ;
  }

  $rect <540,530,740,570>
  slot onMicPress
  {
    //if button is pressed it changes sate from start/stop and icon PlayIcon/StopIcon

    Application::Device.Microphone = !   Application::Device.Microphone;

    MuteBtn.ButtonColor = Application::Device.Microphone ? Res::White : Res::WhiteTransparent;

    MuteBtn.IconColor = Application::Device.Microphone ? Res::Black : Res::White;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,750,640>;
  }

  $rect <520,390,720,430>
  slot onKeypadPress
  {
    Keypad1.Bounds.origin =< 0, 30>;




    //keypadPage = new Application::Keypad;

    Keypad1.OnHide = onHide;

    //SwitchToDialog( keypadPage, Res::FadeInOutCentered, null, null, null, null, null, null, null, null, null );


  }

  $rect <310,530,510,570>
  slot onAddCallPress
  {
    sender; /* the method is called from the sender object */
  }

  $rect <310,570,510,610>
  slot onVideoCallPress
  {
    sender; /* the method is called from the sender object */
  }

  $rect <520,300,710,340>
  slot onContactsPress
  {
    contactsPage = new Application::ContactsInsideCall;

    contactsPage.OnCancel = onCancel; 

    SwitchToDialog( contactsPage,  Application::SlideUpCentered, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumRed EndCallBtn
  {
    preset Bounds = <104,378,169,446>;
    preset OnActivate = onEndCallPress;
    preset Label = Res::EndCallTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans ContactsBtn
  {
    preset Bounds = <182,240,247,332>;
    preset OnActivate = onContactsPress;
    preset Icon = Res::UserIconTxt;
    preset Descript = "contacts";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans VideoCallBtn
  {
    preset Bounds = <104,241,169,333>;
    preset OnActivate = onVideoCallPress;
    preset Icon = Res::VideoCallTxt;
    preset Descript = "VideoCall";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans AddCallBtn
  {
    preset Bounds = <26,242,91,334>;
    preset OnActivate = onAddCallPress;
    preset Icon = Res::PlusIconTxt;
    preset Descript = "add call";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans SpeakerBtn
  {
    preset Bounds = <182,147,247,239>;
    preset OnActivate = onSpeakerPress;
    preset Icon = Res::SpeakerTxt;
    preset Descript = "speaker";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans KeyPadBtn
  {
    preset Bounds = <104,148,169,240>;
    preset OnActivate = onKeypadPress;
    preset Icon = Res::KeypadTxt;
    preset Descript = "keypad";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans MuteBtn
  {
    preset Bounds = <26,149,91,241>;
    preset OnActivate = onMicPress;
    preset Icon = Res::MicOffTxt;
    preset Descript = "mute";
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <16,73,89,103>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "calling...";
    preset Font = Res::ContactFont12;
    preset Color = #FAFAFAFF;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitials
  {
    preset Bounds = <179,28,249,119>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  object Views::Text ContactNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <16,42,179,72>;
    preset Ellipsis = true;
    preset WrapText = false;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont25;
    preset Color = #FAFAFAFF;
  }

  $rect <310,300,510,340>
  var Application::ContactsInsideCall contactsPage = null;

  $rect <530,340,700,380>
  slot onCancel
  {
    DismissDialog( contactsPage, Res::SlideDownCentered, null, null, null, null, false);
  }

  $rect <320,390,520,430>
  var Application::KeypadPage keypadPage;

  $rect <550,470,720,510>
  slot onHide
  {
    //DismissDialog( keypadPage, Res::FadeInOutCentered, null, null, null, null, null );
     // Move the keyboard below the bottom screen edge
    Keypad1.Bounds.origin.y = Bounds.y2;

    Keypad1.InputEtxt.String = "";
    ContactNameTxt.Visible = true;
    TimeTxt.Visible = true;
    UserInitials.Visible = true;

  }

  $rect <20,20,160,60>
  object Application::KeypadInsideCall Keypad1
  {
    preset Bounds = <0,518,272,958>;
    preset HideFunction = false;
    preset HideCall = true;
    preset OnEditTextChanged = onKeypadEdit;
  }

  $rect <520,430,720,470>
  slot onKeypadEdit
  {
    ContactNameTxt.Visible = Keypad1.InputEtxt.String == "";
    TimeTxt.Visible = Keypad1.InputEtxt.String == "";
    UserInitials.Visible = Keypad1.InputEtxt.String == "";
  }

  $rect <770,80,970,120>
  slot onCallState
  {

    if ( Application::Device.CallState == Application::CallState.RingOutgoing)
    {
      AddCallBtn.Enabled =  false;
      VideoCallBtn.Enabled = false;
      Application::MyContactsManager.History.Add( ContactHistory);//
    }
    else if ( Application::Device.CallState == Application::CallState.Talk)
    {
      AddCallBtn.Enabled =  true;
      VideoCallBtn.Enabled = true;
      TimeTxt.Visible = false;
      Application::MyContactsManager.History.Add( ContactHistory );//
    } 
    else if ( Owner != null )
    {
      Owner.DismissDialog( this, null, null, null, null, null, false);
    }


  }

  $rect <770,120,970,160>
  method void getContact()
  {
    Contact = Application::MyContactsManager.Contacts.FindByNumber( Application::Device.CallingNumber );

    postsignal onContactUpdated;

  }

  // Initialization
  note group Note2
  {
    attr Bounds = <760,0,1230,200>;
  }

  $rect <550,90,740,130>
  onset ContactHistory
  {
    // The value doesn't change - nothing to do.
    if ( pure ContactHistory == value )
      return;

    if ( pure ContactHistory != null )
    {
       detachobserver onContactRistoryUpdate, pure ContactHistory;
    }

    // Remember the property's new value.
    pure ContactHistory = value;

    if ( pure ContactHistory != null )
    {
      attachobserver onContactRistoryUpdate, pure ContactHistory;
      postsignal onContactRistoryUpdate;
    }

  }

  $rect <550,50,740,90>
  property Application::ContactHistory ContactHistory = null;

  $rect <550,130,740,170>
  slot onContactRistoryUpdate
  {
    if ( pure ContactHistory != null )
    {
      LastNameTxt.String  =  pure ContactHistory.LastName;
      FirstNameTxt.String = pure ContactHistory.FirstName;
      CallType.String     = pure ContactHistory.CallType;
      
      
      
    }

  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,130,630,170>
$output false
class PushButtonMediumTrans : Templates::PushButton
{
  $rect <490,380,690,420>
  inherited property Bounds = <0,0,65,92>;

  $rect <720,260,920,300>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    // Update the parameters of the text view (label)
    if ( IconTxt != null )
    {
       var color clr = IconColor; 
      IconTxt.Font   = Res::IconsFont25;
      IconTxt.String = Icon;
      IconTxt.Color  = clr;
      }

    // Update the parameters of the text view (label)
    if ( DescripTxt != null )
    {
       var color clr    = DescriptColor; 
      DescripTxt.Font   = Res::ContactFont12;
      DescripTxt.String = Descript;
      DescripTxt.Color  = clr;
      }

    if ( !isEnabled )
    {
      Background.Color = Res::Transparent;
      DescripTxt.Color = Res::WhiteTransparent;
      IconTxt.Color    = Res::WhiteTransparent;
     
    }

    else if ( isPressed )
    {
      Background.Color = ButtonColorPressed;
    }

    else if ( isSelected )
    {
      Background.Color = ButtonColor;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <710,220,930,470>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <480,220,700,350>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <250,220,470,350>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <20,220,240,390>;
  }

  // This variable stores the current state of the button.
  $rect <720,380,920,420>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <720,340,920,380>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <720,300,920,340>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <490,260,690,300>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <260,260,460,300>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <490,300,690,340>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <260,300,460,340>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <30,340,230,380>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <30,300,230,340>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <30,260,230,300>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,65>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,65>;
    preset Point3 = <65,65>;
    preset Point2 = <65,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <90,0,290,40>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <0,0,65,65>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <290,40,490,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <290,0,490,40>
  property string Icon = "";

  $rect <720,420,920,460>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,65,65,92>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Res::ContactFont12;
  }

  $rect <710,0,910,40>
  property string Descript = "";

  $rect <710,40,910,80>
  onset Descript
  {
    // The value doesn't change - nothing to do.
    if ( pure Descript == value )
      return;

    // Remember the property's new value.
    pure Descript = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <500,0,700,40>
  property color ButtonColor = Res::WhiteTransparent;

  $rect <500,40,700,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <280,90,480,130>
  property color IconColor = Res::White;

  $rect <280,130,480,170>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <490,90,700,130>
  property color ButtonColorPressed = Res::WhiteSemiTransparent;

  $rect <490,130,700,170>
  onset ButtonColorPressed
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColorPressed == value )
      return;

    // Remember the property's new value.
    pure ButtonColorPressed = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <710,90,910,130>
  property color DescriptColor = Res::White;

  $rect <710,130,910,170>
  onset DescriptColor
  {
    // The value doesn't change - nothing to do.
    if ( pure DescriptColor == value )
      return;

    // Remember the property's new value.
    pure DescriptColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <640,130,840,170>
$output false
class PushButtonMediumRed : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,65,65>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color = Res::Red;
    }

    else if ( isPressed )
    {
      Background.Color = Res::RedLight;
    }

    else if ( isSelected )
    {
      Background.Color = Res::Red;
      }

    // Enabled but not pressed nor selected.
    else
    {
       Background.Color = Res::Red;
    }


    // Update the parameters of the text view (label)
    if ( Text != null )
    {
       var color clr = #FFFFFFFF; 
      Text.Font      = Res::IconsFont25;
      Text.String = Label;
      Text.Color     = clr;
      }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,65>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,65>;
    preset Point3 = <65,65>;
    preset Point2 = <65,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,65,65>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <450,50,650,90>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Label = "";

  $rect <710,350,910,390>
  var Views::Text textView;
}

$rect <820,540,1030,580>
$output false
enum Sorting
{
  $rect <10,10,210,50>
  item None;

  $rect <220,10,420,50>
  item Ascending;

  $rect <430,10,630,50>
  item Descending;
}

$rect <870,40,1100,80>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <0,40,200,80>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Application::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <0,0,200,40>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Application::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  $rect <200,90,400,130>
  property bool Microphone;

  $rect <600,90,800,130>
  onget Microphone
  {
    // Per default return the value stored already in the property.
    return pure Microphone;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,90,600,130>
  onset Microphone
  {
    // The property doesn't change -> nothing to do.
    if ( pure Microphone == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Microphone = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Microphone;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,90,200,130>
  $output true
  method void UpdateMicrophone( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Microphone )
    {
      // Remember the new value in the internal memory of the property.
      pure Microphone = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Microphone;
    }
  }

  $rect <200,130,400,170>
  property bool Speaker;

  $rect <600,130,800,170>
  onget Speaker
  {
    // Per default return the value stored already in the property.
    return pure Speaker;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,130,600,170>
  onset Speaker
  {
    // The property doesn't change -> nothing to do.
    if ( pure Speaker == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Speaker = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Speaker;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,130,200,170>
  $output true
  method void UpdateSpeaker( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Speaker )
    {
      // Remember the new value in the internal memory of the property.
      pure Speaker = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Speaker;
    }
  }

  $rect <200,180,400,220>
  property Application::CallState CallState = Application::CallState.None;

  $rect <600,180,800,220>
  onget CallState
  {
    // Per default return the value stored already in the property.
    return pure CallState;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,180,600,220>
  onset CallState
  {
    // The property doesn't change -> nothing to do.
    if ( pure CallState == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure CallState = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^CallState;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,180,200,220>
  $output true
  method void UpdateCallState( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure CallState )
    {
      // Remember the new value in the internal memory of the property.
      pure CallState = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^CallState;
    }
  }

  $rect <200,220,400,260>
  property string CallingNumber;

  $rect <600,220,800,260>
  onget CallingNumber
  {
    // Per default return the value stored already in the property.
    return pure CallingNumber;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,220,600,260>
  onset CallingNumber
  {
    // The property doesn't change -> nothing to do.
    if ( pure CallingNumber == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure CallingNumber = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^CallingNumber;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,220,200,260>
  $output true
  method void UpdateCallingNumber( arg string aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure CallingNumber )
    {
      // Remember the new value in the internal memory of the property.
      pure CallingNumber = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^CallingNumber;
    }
  }
}

$rect <870,90,1100,130>
autoobject Application::DeviceClass Device;

// Device
note group Note3
{
  attr Bounds = <850,0,1140,200>;
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <640,170,840,210>
$output false
class KeyPadButtons : Templates::PushButton
{
  $rect <90,40,290,80>
  inherited property Bounds = <0,0,65,65>;

  $rect <690,310,890,350>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    // Update the parameters of the text view (label)
    if ( IconTxt != null )
    {
       var color clr = IconColor; 
      IconTxt.Font      = Res::IconsFont25;
      IconTxt.String = Icon;
      IconTxt.Color     = clr;
      }

    // Update the parameters of the text view (label)
    if ( DescripTxt != null )
    {
       var color clr = TextColor; 
      DescripTxt.Font      = Res::TitileFont25;
      DescripTxt.String = Text;
      DescripTxt.Color     = clr;
      }



    if ( !isEnabled )
    {
      Background.Color = Res::PressColor;
      IconTxt.Color    = Res::Grey;
      DescripTxt.Color  = Res::Grey;
    }

    else if ( isPressed )
    {
      Background.Color = ButtonColorPressed;
      IconTxt.Color    = IconColorPressed;
      DescripTxt.Color  = TextColorPressed;
    }

    else if ( isSelected )
    {
      Background.Color = ButtonColor;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <680,270,900,520>;
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <300,0,500,40>
  property string Icon;

  $rect <690,470,890,510>
  var Views::Text textView;

  $rect <510,0,710,40>
  property string Text = "";

  $rect <510,40,710,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <720,0,920,40>
  property color ButtonColor = Res::WhiteTransparent;

  $rect <720,40,920,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <300,90,500,130>
  property color IconColor = Res::White;

  $rect <300,130,500,170>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <450,270,670,400>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <220,270,440,400>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <-10,270,210,440>;
  }

  // This variable stores the current state of the button.
  $rect <690,430,890,470>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <690,390,890,430>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <690,350,890,390>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <460,310,660,350>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <230,310,430,350>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <460,350,660,390>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <230,350,430,390>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <300,40,500,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <0,390,200,430>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <0,350,200,390>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <90,0,290,40>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <0,310,200,350>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,65>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,65>;
    preset Point3 = <65,65>;
    preset Point2 = <65,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <0,0,65,65>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Bounds = <0,0,65,65>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <510,90,710,130>
  property color TextColor = Res::White;

  $rect <510,130,710,170>
  onset TextColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColor == value )
      return;

    // Remember the property's new value.
    pure TextColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <720,90,920,130>
  property color ButtonColorPressed = Res::WhiteSemiTransparent;

  $rect <720,130,920,170>
  onset ButtonColorPressed
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColorPressed == value )
      return;

    // Remember the property's new value.
    pure ButtonColorPressed = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <300,180,500,220>
  property color IconColorPressed = Res::WhiteSemiTransparent;

  $rect <300,220,500,260>
  onset IconColorPressed
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColorPressed == value )
      return;

    // Remember the property's new value.
    pure IconColorPressed = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <510,180,710,220>
  property color TextColorPressed = Res::WhiteSemiTransparent;

  $rect <510,220,710,260>
  onset TextColorPressed
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColorPressed == value )
      return;

    // Remember the property's new value.
    pure TextColorPressed = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }
}

$rect <230,210,400,250>
$output false
class DetailsInsideCall : Application::ContactDetailsPage
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,440>;

  $rect <490,20,690,60>
  inherited slot onTapEdit
  {
    edit = new Application::ContactEditPage;

    edit.OnSave  = onSaveEdit;
    edit.OnClose = onCancelEdit;
    edit.Contact = Contact;
    edit.OnDelete = onDelete;

    SwitchToDialog( edit, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );
     



  }

  $rect <290,20,490,60>
  inherited var edit;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  inherited object Line2
  {
    preset Point2 = <264,311>;
    preset Point1 = <6,311>;
  }

  $rect <20,20,160,60>
  inherited object NumberTxt
  {
    preset Bounds = <18,282,262,311>;
  }

  $rect <20,20,160,60>
  inherited object MobileTxt
  {
    preset Bounds = <6,256,264,289>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <264,256>;
    preset Point1 = <6,256>;
  }

  $rect <20,20,160,60>
  inherited object CallBtn
  {
    preset Bounds = <50,161,100,236>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  inherited object VideoCallBtn
  {
    preset Bounds = <110,161,160,236>;
  }

  $rect <20,20,160,60>
  inherited object PushButtonMediumBlue2
  {
    preset Bounds = <170,161,220,236>;
  }

  $rect <20,20,160,60>
  inherited object ContactName
  {
    preset Bounds = <10,114,267,144>;
  }

  $rect <20,20,160,60>
  inherited object UserInitialsBtn
  {
    preset Bounds = <100,30,170,121>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  inherited object EditBtn
  {
    preset Bounds = <239,5,264,30>;
  }

  $rect <20,20,160,60>
  inherited object BackBtn
  {
    preset Bounds = <6,5,31,30>;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <640,210,840,250>
$output false
class TextButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,66,25>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    // Update the parameters of the text view (label)
    if ( TextTxt != null )
    {
      var color clr = TextColor; 
      TextTxt.Font      = Res::ContactFont15;
      TextTxt.String = Text;
      TextTxt.Color     = clr;
      }

    if ( !isEnabled )
    {
      Background.Color = BackgoundColor;
      TextTxt.Color       = Res::Grey;
    }

    else if ( isPressed )
    {
      Background.Color = BackgoundColor;
      TextTxt.Color       = TextColorPress;
    }

    else if ( isSelected )
    {
      Background.Color = BackgoundColor;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = BackgoundColor;
    }


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;

  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <280,40,480,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <280,0,480,40>
  property string Text = "";

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,25>;
    preset Point3 = <66,25>;
    preset Point2 = <66,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,-4,66,28>;
    preset Color = #FFFFFF00;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <80,0,280,40>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text TextTxt
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,66,25>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Res::IconsFont25;
    preset Color = #FFFFFFFF;
  }

  $rect <480,40,680,80>
  onset TextColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColor == value )
      return;

    // Remember the property's new value.
    pure TextColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <480,0,680,40>
  property color TextColor = Res::Blue;

  $rect <680,40,880,80>
  onset TextColorPress
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColorPress == value )
      return;

    // Remember the property's new value.
    pure TextColorPress = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <680,0,880,40>
  property color TextColorPress = Res::BlueLight;

  $rect <880,40,1080,80>
  onset BackgoundColor
  {
    // The value doesn't change - nothing to do.
    if ( pure BackgoundColor == value )
      return;

    // Remember the property's new value.
    pure BackgoundColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <880,0,1080,40>
  property color BackgoundColor = Res::Transparent;

  $reorder Bounds 1
  $reorder first 1
  $reorder last 1
  $reorder keyHandlers 1
  $reorder buffer 1
  $reorder dialogStack 1
  $reorder fadersQueue 1
  $reorder pendingFader 1
  $reorder processKeyHandlers 1
  $reorder updateBufferSlot 1
  $reorder drawContent 1
  $reorder recalculateLayout 1
  $reorder updateComponent 1
  $reorder OnSetFocus 1
  $reorder OnGetBuffered 1
  $reorder OnSetBuffered 1
  $reorder OnGetEnabled 1
  $reorder OnSetEnabled 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder DrawForeground 1
  $reorder DrawBackground 1
  $reorder GetMinimalSize 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateLayout 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder RemoveAll 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Note4 1
  $reorder Note3 1
  $reorder Note2 1
  $reorder Note1 1
  $reorder pressed 1
  $reorder selected 1
  $reorder enabled 1
  $reorder FlashTimer 1
  $reorder KeyHandler 1
  $reorder onFlashTimer 1
  $reorder onPressKey 1
  $reorder onEnterLeaveTouch 1
  $reorder onReleaseTouch 1
  $reorder onPressTouch 1
  $reorder OnSetText 1
  $reorder Text 1
  $reorder textView 1
  $reorder TouchHandler 1
  $reorder Background 1
  $reorder OnActivate 1
  $reorder TextTxt 1
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <640,250,840,290>
$output false
class NavBarButtons : Templates::PushButton
{
  $rect <470,440,670,480>
  inherited property Bounds = <0,0,68,40>;

  $rect <700,320,900,360>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = isSelected();
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    if ( IconTxt != null )
    {
       var color clr = IconColor; 
      IconTxt.Font      = Res::IconsFont20;
      IconTxt.String = Icon;
      IconTxt.Color     = clr;
      }

    // Update the parameters of the text view (label)
    if ( DescripTxt != null )
    {
        var color clr = DescrpitColor; 
      DescripTxt.Font      = Res::ContactFont12;
      DescripTxt.String = Descript;
      DescripTxt.Color     = clr;
      }

    if ( !isEnabled )
    {
      IconTxt.Color     = Res::GreyLight;
      DescripTxt.Color  = Res::GreyLight;
    }

    else if ( isPressed )
    {

      IconTxt.Color     = Res::BlueLight;
      DescripTxt.Color  = Res::BlueLight;

    }

    else if ( isSelected )
    {
      IconTxt.Color     = Res::Blue;
      DescripTxt.Color  = Res::Blue;
    }

    // Enabled but not pressed nor selected.
    else
    { 
      IconTxt.Color     = Res::Grey;
      DescripTxt.Color  = Res::Grey;
    }


    // Finally set the color of the knob depending on the button's state.
    if      ( isPressed &&  isSelected ) IconTxt.Color = Res::Blue;
    else if ( isPressed && !isSelected ) IconTxt.Color = Res::BlueLight;
    else if ( isEnabled &&  isSelected ) IconTxt.Color = Res::Blue;
    else if ( isEnabled && !isSelected ) IconTxt.Color = Res::Grey;
    else if ( isSelected )               IconTxt.Color = Res::Blue;
    else                                IconTxt.Color = Res::RedLight;


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <690,280,910,530>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <460,280,680,410>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <230,280,450,410>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,280,230,450>;
  }

  // This variable stores the current state of the button.
  $rect <700,440,900,480>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <700,400,900,440>
  var bool selected = true;

  // This variable stores the current state of the button.
  $rect <700,360,900,400>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <470,320,670,360>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <240,320,440,360>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <470,360,670,400>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <240,360,440,400>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      FlashTimer.Enabled = false;

      // Select the button and notify the owner of the button.
      if ( !isSelected() )
      {
        postsignal OnSelect;

        // If a property is associated to the button, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,400,220,440>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,360,220,400>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
    {
      // Select the button and notify the owner of the button.
      if ( !isSelected() )
      {
        
        postsignal OnSelect;

        // If a property is associated to the button, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
    }

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,320,220,360>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      FlashTimer.Enabled = false;

      // Select the button and notify the owner of the button.
      if ( !isSelected() )
      {
        postsignal OnSelect;

        // If a property is associated to the button, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
    }
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,40>;
    preset Point3 = <65,40>;
    preset Point2 = <65,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <90,0,290,40>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <0,0,68,25>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <100,150,250,190>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <100,110,250,150>
  property string Icon;

  $rect <700,480,900,520>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,25,68,40>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Res::ContactFont12;
  }

  $rect <260,110,430,150>
  property string Descript = "Text";

  $rect <260,150,430,190>
  onset Descript
  {
    // The value doesn't change - nothing to do.
    if ( pure Descript == value )
      return;

    // Remember the property's new value.
    pure Descript = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <100,200,250,240>
  property color IconColor = Res::Grey;

  $rect <100,240,250,280>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <260,200,430,240>
  property color DescrpitColor = Res::Grey;

  $rect <260,240,430,280>
  onset DescrpitColor
  {
    // The value doesn't change - nothing to do.
    if ( pure DescrpitColor == value )
      return;

    // Remember the property's new value.
    pure DescrpitColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <450,40,620,80>
  onset OutletSelector
  {
    // Check if the given value differs from the current value
    if ( pure OutletSelector == value )
      return;

    pure OutletSelector = value;

    InvalidateViewState();
  }

  $rect <300,40,450,80>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  // The property 'OnSelect' can refer to a slot method, which will receive a signal \
  // as soon as the user has selected the radio button. Thereupon the method's logic \
  // will be executed.
  $rect <630,0,790,40>
  property slot OnSelect = null;

  // The property 'OutletSelector' contains a value identifying the radio button \
  // within a group of radio buttons. At the runtime, the button compares this value \
  // with the value of the property referred by @Outlet and if both are equal, the \
  // radio button assumes the 'selected' state (its property @Selected is 'true'). \
  // If the values are different, the radio button appears not selected. This selector \
  // is useful to build a group of radio buttons that refers to the same outlet. \
  // Different selectors for each radio button manages automatically the group of \
  // radio buttons.
  $rect <450,0,620,40>
  property int32 OutletSelector = 0;

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the user selects the radio button, the affected \
  // property is automatically updated to the value found in the property @OutletSelector. \
  // On the other hand, when the referred property is modified by another one, the \
  // radio button is automatically notified to remain in sync with the property. \
  // The button appears selected, when the referred property has the value equal \
  // to @OutletSelector.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the radio button represents the 'View' and 'Controller' and the property \
  // referred via 'Outlet' can be seen as a part of the 'Model'.
  $rect <300,0,450,40>
  property ^int32 Outlet = null;

  // Controller events
  note group Note5
  {
    attr Bounds = <230,410,450,500>;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <240,450,440,490>
  slot onOutlet
  {
    // ... and finally, request an update
    InvalidateViewState();
  }

  $rect <790,0,990,40>
  method bool isSelected()
  {
    return Outlet != null && Outlet^ == OutletSelector;
  }
}

$rect <30,340,210,380>
$output false
class KeypadPage : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272, 440>;

  $rect <730,140,930,180>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);

    if ( HideFunction == false)
    {
      HideBtn.Visible= true;
    }

    if ( HideFunction == true)
    {
      HideBtn.Visible= false;
    }

    if ( HideCall == false)
    {
      callbtn.Visible= true;
    }

    if ( HideCall == true)
    {
      callbtn.Visible= false;
    }


    if ( !isEnabled )
    {
      Background.Color = Res::Grey;
    }

    // Enabled but not pressed nor selected.
    else
    {
       Background.Color = BackgoundColor;
    }


  }

  $rect <290,10,490,50>
  property slot OnHide;

  $rect <490,10,690,50>
  slot onHide
  {
    postsignal OnHide;
  }

  $rect <290,70,490,110>
  property color BackgoundColor = Res::White;

  $rect <490,70,690,110>
  onset BackgoundColor
  {
    // The value doesn't change - nothing to do.
    if ( pure BackgoundColor == value )
      return;

    // Remember the property's new value.
    pure BackgoundColor = value;

    InvalidateViewState();
  }

  $rect <290,120,490,160>
  property bool HideFunction = true;

  $rect <490,120,690,160>
  onset HideFunction
  {
    // The value doesn't change - nothing to do.
    if ( pure HideFunction == value )
      return;

    // Remember the property's new value.
    pure HideFunction = value;
    InvalidateViewState();
  }

  $rect <290,220,490,260>
  slot onButtonsPress
  {
    var Application::KeyPadButtons b = (Application::KeyPadButtons)sender;

    if ( sender == BtnErase)
      InputEtxt.String = InputEtxt.String.remove( InputEtxt.String.length-1, 1);
    else if ( b != null )
    {
      InputEtxt.String += b.Text;
    }

    signal OnEditTextChanged;        

  }

  $rect <290,160,490,200>
  property bool HideCall = false;

  $rect <490,160,690,200>
  onset HideCall
  {
    // The value doesn't change - nothing to do.
    if ( pure HideCall == value )
      return;

    // Remember the property's new value.
    pure HideCall = value;
    InvalidateViewState();
  }

  $rect <290,260,490,300>
  slot onCallPress
  {
    if( InputEtxt.String != "")
    {
      Application::Device.UpdateCallingNumber( InputEtxt.String );
      Application::Device.CallState = Application::CallState.RingOutgoing;

    }
  }

  $rect <874,317,1074,357>
  property slot OnEditTextChanged = null;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons callbtn
  {
    preset Bounds = <104,340,169,405>;
    preset Icon = Res::CallTxt;
    preset ButtonColor = Res::GreenDark;
    preset OnActivate = onCallPress;
    preset ButtonColorPressed = Res::Green;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons BtnErase
  {
    preset Bounds = <169,340,234,405>;
    preset Icon = Res::BackspaceTxt;
    preset Text = "";
    preset ButtonColor = Res::Transparent;
    preset IconColor = Res::Black;
    preset OnActivate = onButtonsPress;
    preset ButtonColorPressed = Res::Transparent;
    preset IconColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn1
  {
    preset Bounds = <39,80,104,145>;
    preset Text = "1";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn3
  {
    preset Bounds = <169,80,234,145>;
    preset Text = "3";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn2
  {
    preset Bounds = <104,80,169,145>;
    preset Text = "2";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn4
  {
    preset Bounds = <39,145,104,210>;
    preset Text = "4";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn6
  {
    preset Bounds = <169,145,234,210>;
    preset Text = "6";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn5
  {
    preset Bounds = <104,145,169,210>;
    preset Text = "5";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn7
  {
    preset Bounds = <39,210,104,275>;
    preset Text = "7";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn9
  {
    preset Bounds = <169,210,234,275>;
    preset Text = "9";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn8
  {
    preset Bounds = <104,210,169,275>;
    preset Text = "8";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btnstar
  {
    preset Bounds = <39,275,104,340>;
    preset Text = "*";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btnDiez
  {
    preset Bounds = <169,275,234,340>;
    preset Text = "#";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn0
  {
    preset Bounds = <104,275,169,340>;
    preset Text = "0";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt InputEtxt
  {
    preset Bounds = <39,48,234,80>;
    preset String = "";
    preset Color = Res::Black;
    preset Font = Res::TitileFont25;
  }

  $rect <20,20,160,60>
  object Application::TextButton HideBtn
  {
    preset Bounds = <39,360,101,385>;
    preset Text = "Hide";
    preset OnActivate = onHide;
    preset TextColor = Res::Black;
    preset TextColorPress = Res::Grey;
  }
}

// This is the root component of the entire GUI application.
$rect <10,80,210,120>
$output false
class ContactsApp : Core::Group
{
  $rect <320,90,500,130>
  inherited method Init()
  {
    attachobserver onCallState, ^Application::Device.CallState;
    postsignal onCallState;

    SelectedPage = 2;
  }

  $rect <280,0,480,40>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  object Core::Group Outline
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,440,272,480>;
  }

  $rect <20,20,160,60>
  object Application::NavBarButtons NavBarButtons
  {
    preset Bounds = <0,440,68,480>;
    preset Icon = Res::HeartTxt;
    preset Descript = "Favorites";
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Application::NavBarButtons NavBarButtons1
  {
    preset Bounds = <68,440,136,480>;
    preset Icon = Res::CallTxt;
    preset Descript = "Recent";
    preset OutletSelector = 1;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Application::NavBarButtons NavBarButtons2
  {
    preset Bounds = <136,440,204,480>;
    preset Icon = Res::UserIconTxt;
    preset Descript = "Contacts";
    preset OutletSelector = 2;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Application::NavBarButtons NavBarButtons3
  {
    preset Bounds = <204,440,272,480>;
    preset Icon = Res::KeypadTxt;
    preset Descript = "Keypad";
    preset OutletSelector = 3;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <270,440>;
    preset Point1 = <0,440>;
    preset Color = Res::Grey;
  }

  $rect <290,270,490,310>
  property int32 SelectedPage = -1;

  $rect <290,310,490,350>
  onset SelectedPage
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedPage == value )
      return;

    // Remember the property's new value.
    pure SelectedPage = value;

    notifyobservers ^SelectedPage;

    switch ( pure SelectedPage )
    {
      case 0: 
      {
        var Core::Group favorites = new Application::FavoritesPage;
        Outline.SwitchToDialog( favorites, null, null, null, null, null, null, null, null, null,false );
      }
      case 1: 
      {
        var Core::Group recent = new Application::RecentPage;
        Outline.SwitchToDialog( recent, null, null, null, null, null, null, null, null, null,false );
      }
      case 2: 
      {
        var Core::Group contacts = new Application::ContactsPage;
        Outline.SwitchToDialog( contacts, null, null, null, null, null, null, null, null, null,false );
      }
      case 3: 
      {
        var Core::Group keypad = new Application::KeypadPage;
        Outline.SwitchToDialog( keypad, null, null, null, null, null, null,
                                null, null, null,false );
      }

      default:
        trace "ERROR: invalid selected page ", pure SelectedPage;
    }

  }

  $rect <290,350,490,390>
  onget SelectedPage
  {
    return pure SelectedPage;
  }

  $rect <500,90,700,130>
  slot onCallState
  {
     if ( Application::Device.CallState != Application::CallState.None)
    {
      DismissDialog( this, null, null, null, null, null, false);
    } 

  }
}

$rect <10,30,210,70>
$output false
class Application : Core::Root
{
  $rect <290,50,490,90>
  inherited method Init()
  {
    attachobserver onCallState, ^Application::Device.CallState;
    postsignal onCallState;


  }

  $rect <290,0,490,40>
  inherited property Bounds = <0,0,272,480>;

  // To do:
  // 
  // - Adjust the visible size of your application (the thick blue border). It should \
  // correspond to the size of your target display.
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <10,510,790,740>;
  }

  $rect <290,90,490,130>
  slot onCallState
  {

    //Talk dialog
    if ( Application::Device.CallState == Application::CallState.Talk)
    {
      PresentDialog( new Application::CallPage, Res::FadeInOutCentered, null, null, null, null, null, null, null, false );
    }
    //Outgoing call dialog
    else if ( Application::Device.CallState == Application::CallState.RingOutgoing)
    {
      PresentDialog( new Application::CallPage, Res::FadeInOutCentered, null, null, null, null, null, null, null, false );
    }
    //Incoming call dialog
    else if ( Application::Device.CallState == Application::CallState.RingIncoming)
    {
      PresentDialog( new Application::InComingCall, Res::FadeInOutCentered, null, null, null, null, null, null, null, false );
    }





  }

  $rect <700,0,900,40>
  var Application::DeviceClass deviceInstance = Application::Device;

  $rect <490,0,690,40>
  var Application::ContactsManager myContactInstance = Application::MyContactsManager;

  $rect <290,130,490,170>
  var int32 Variable;

  $rect <20,20,160,60>
  object Application::ContactsApp ContactsApp
  {
    preset Bounds = <0,0,272,480>;
  }
}

$rect <230,250,400,290>
$output false
class KeypadInsideCall : Application::KeypadPage
{
  $rect <20,20,160,60>
  inherited object Background
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle BackgroundSmall
  {
    preset Bounds = <0,80,272,340>;
    preset ColorBL = Res::Grey;
    preset ColorBR = Res::Grey;
    preset ColorTR = Res::GreyLight;
    preset ColorTL = Res::Grey;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  inherited object callbtn
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  inherited object BtnErase
  {
    preset Text = "";
    preset IconColor = Res::White;
    preset ButtonColorPressed = Res::Transparent;
  }

  $rect <20,20,160,60>
  inherited object btn1
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn3
  {
    preset Enabled = true;
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn2
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn4
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn6
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn5
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn7
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn9
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn8
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btnstar
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btnDiez
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn0
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object InputEtxt
  {
    preset Bounds = <39,32,234,64>;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  inherited object HideBtn
  {
    preset TextColor = Res::White;
  }

  $reorder BackgroundSmall 16
}

$rect <230,170,400,210>
$output false
class ContactsInsideCall : Application::ContactsPage
{
  $rect <290,110,490,150>
  inherited var detailsPage;

  $rect <20,20,160,60>
  inherited object Background;

  $rect <20,20,160,60>
  inherited object VerticalList;

  $rect <20,20,160,60>
  inherited object SlideTouchHandler;

  $rect <20,20,160,60>
  inherited object UpButton;

  $rect <20,20,160,60>
  inherited object DownButton;

  $rect <20,20,160,60>
  inherited object SearchExt;

  $rect <20,20,160,60>
  inherited object TitleTxt
  {
    preset Bounds = <11,12,261,61>;
    preset Font = Res::ContactFontBold15;
  }

  $rect <20,20,160,60>
  inherited object PlusButton
  {
    preset Bounds = <166,12,196,42>;
  }

  $rect <490,110,690,150>
  inherited slot onContactActivated
  {
    var Application::ContactItem itemView = (Application::ContactItem)sender;

    if ( itemView != null )
    {
      detailsPage = new Application::DetailsInsideCall;
      detailsPage.OnBack = onCloseContact;
      detailsPage.OnDelete = onDeleteContact;

      detailsPage.Contact = itemView.Contact;
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }

  }

  $rect <20,20,160,60>
  object Application::TextButton TextButton
  {
    preset Bounds = <196,15,262,40>;
    preset Text = "Cancel";
    preset OnActivate = onCancel;
  }

  $rect <290,0,490,40>
  property slot OnCancel;

  $rect <490,0,690,40>
  slot onCancel
  {
    postsignal OnCancel;
  }
}

$rect <880,150,1080,190>
$output false
enum CallState
{
  $rect <10,10,210,50>
  item None;

  $rect <220,10,420,50>
  item RingIncoming;

  $rect <430,10,630,50>
  item RingOutgoing;

  $rect <640,10,840,50>
  item Talk;
}

$rect <870,257,1070,297>
$variant Simulation
vclass ApplicationSimulation : Application::Application
{
  $rect <810,0,1010,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <421,155,571,205>;
    preset OnActivate = onIncomingCall;
    preset Label = "Incoming call";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <844,104,1044,144>
  slot onIncomingCall
  {
    Application::Device.UpdateCallState( Application::CallState.RingIncoming );
    //Application::Device.UpdateCallingNumber( "+40723494923" );
    Application::Device.UpdateCallingNumber( "zf" );
  }
}

$rect <870,300,1120,340>
$output false
autoobject Effects::FadeInOutTransition FadeInOutTransition
{
  preset MarginTop = 30;
  preset Alignment = Effects::DialogAlignment[AlignHorzLeft];
}

// Simulation
note group Note4
{
  attr Bounds = <850,210,1140,410>;
}

$rect <210,80,400,120>
$output false
class InComingCall : Core::Group
{
  $rect <770,40,970,80>
  inherited method Init()
  {
    attachobserver onCallState, ^Application::Device.CallState;
    postsignal onCallState;

    postsignal updateCurrentTime;

    getContact();


  }

  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <310,90,500,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <310,130,500,170>
  slot onContactUpdated
  {
    //if the calling number is in the contact list display info
    if ( pure Contact != null )
    {
      ContactNameTxt.String  = pure Contact.LastName + " "  + pure Contact.FirstName;
      UserInitials.Initials = pure Contact.NameInitials; 
    }
    //if not display number and hide UserInitials
    else
    {
       ContactNameTxt.String = Application::Device.CallingNumber;
       UserInitials.Visible = false;
    }

  }

  $rect <310,50,500,90>
  property Application::Contact Contact = null;

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,0,760,200>;
  }

  $rect <310,250,510,290>
  property bool OnDesclineCall = false;

  $rect <520,250,720,290>
  slot onDesclineCall
  {
    Application::Device.UpdateCallState( Application::CallState.None );

    postsignal onCallState;

  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,760,640>;
  }

  $rect <770,80,970,120>
  slot onCallState
  {
    //close dialog on call state changed
    Application::MyContactsManager.History.Add( Contact );

    if ( Application::Device.CallState != Application::CallState.RingIncoming && Owner!= null )
    {
      Owner.DismissDialog( this, null, null, null, null, null, false);
    } 

  }

  $rect <310,290,510,330>
  property bool OnAcceptCall = false;

  $rect <520,290,720,330>
  slot onAcceptCall
  {
    Application::Device.UpdateCallState( Application::CallState.Talk);

    postsignal onCallState;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,480>;
    preset ColorBL = #838383FA;
    preset ColorBR = #4F4F4FFF;
    preset ColorTR = #898989FF;
    preset ColorTL = #898989FF;
    preset Color = #3C3C3CFF;
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans PushButtonMediumTrans
  {
    preset Bounds = <171,340,236,432>;
    preset OnActivate = onAcceptCall;
    preset Icon = Res::CallTxt;
    preset Descript = "Accept";
    preset ButtonColor = Res::GreenDark;
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans PushButtonMediumTrans1
  {
    preset Bounds = <36,340,101,432>;
    preset OnActivate = onDesclineCall;
    preset Icon = Res::EndCallTxt;
    preset Descript = "Descline";
    preset ButtonColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <18,73,91,103>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "calling...";
    preset Font = Res::ContactFont12;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  object Views::Text ContactNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <18,42,171,72>;
    preset EnableBidiText = false;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont25;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitials
  {
    preset Bounds = <184,28,254,119>;
    preset Enabled = false;
    preset Descript = "";
  }

  $rect <990,40,1190,80>
  method void getContact()
  {
    Contact = Application::MyContactsManager.Contacts.FindByNumber( Application::Device.CallingNumber);

    postsignal onContactUpdated;
  }

  $rect <530,50,730,90>
  property Application::ContactHistory ContactHistory = null;

  $rect <530,90,730,130>
  onset ContactHistory
  {
    // The value doesn't change - nothing to do.
    if ( pure ContactHistory == value )
      return;

    // Remember the property's new value.
    pure ContactHistory = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <525,479,715,519>
  object Core::Time Time;

  $rect <770,120,970,160>
  slot updateCurrentTime
  {
    // Get the current time
    var Core::Time currentTime = Time.CurrentTime;
    var Application::ContactHistory ContactHistory = new Application::ContactHistory;

    if ( pure Contact != null )
    {
      ContactHistory.FirstName = pure Contact.FirstName;
      ContactHistory.LastName  = pure Contact.LastName;
      ContactHistory.PhoneNumber = pure Contact.PhoneNumber;
    }
    else
    {
      ContactHistory.FirstName = Application::Device.CallingNumber;
    }

    ContactHistory.CallType = "incoming";

    Application::MyContactsManager.History.Add( ContactHistory );
    //Date.String = currentTime.getDayOfWeekName( currentTime.DayOfWeek, true ) + ", "
    //              + currentTime.getMonthName( currentTime.Month, false ) + " " + string(currentTime.Day, 2);
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <760,0,1230,200>;
  }
}

// The global autoobject Effects::SlideUpCentered represents the fade-in/out operation \
// affecting the position and the opacity of the given GUI component. When using \
// the transition for the fade-in operation, the GUI component slides from the bottom \
// edge of its owner component and continues moving vertically until it reaches the \
// owner's center position. When using the transition for the fade-out operation, \
// the component slides up until it leaves the visible area of its owner component. \
// Additionally, while the transitions are performed, the opacity of the GUI component \
// fades-in or fades-out accordingly. This transition is thus ideal wherever one \
// GUI component should smoothly slide-in/out in context of another component. The \
// duration of the transition is configured per default to take 500 ms and the timing \
// is configured to start fast and then slow down the animation (FastIn_EaseOut).
// This object exists for your convenience permitting you to simply refer the transition \
// wherever it is required in your implementation without having to take care of \
// the creation and configuration of the object. If you require the transition to \
// run with other configuration (e.g. other timing parameters), create a copy of \
// this object and adapt its properties accordingly.
$rect <880,350,1130,390>
$output false
autoobject Effects::SlideTransition SlideUpCentered
{
  preset MarginTop = 40;
  preset Direction = Core::Direction.Top;
}

$rect <30,390,210,430>
$output false
class FavoritesPage : Core::Group
{
  $rect <300,20,480,60>
  inherited method Init()
  {
    attachobserver onNoOfContactsChanged, ^Application::MyContactsManager.Favorites.NoOfItems;
    postsignal onNoOfContactsChanged;
  }

  $rect <300,100,490,140>
  inherited property Bounds = <0,0,272,440>;

  $rect <0,570,200,610>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,530,200,570>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <470,260,660,300>
  slot onAddPress
  {
    addFav = new Application::ContactsList;

    addFav.OnCancel = onClose;
    addFav.OnAddFav = onClose;

    SwitchToDialog( addFav, Res::SlideUpCentered, null, null, null, null, null,
                               null, null, null, false );

  }

  $rect <290,260,470,300>
  var Application::ContactsList addFav = null;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <690,50,890,90>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var int32 itemNo = VerticalList.Item;

    var Application::Contact contact = Application::MyContactsManager.Favorites.GetContact( itemNo );

    var Application::FavContactItem itemView = (Application::FavContactItem)VerticalList.View;
    SelectedContact = itemView.Contact;
                                                  
    if ( itemView == null )
      return;

    if ( contact != null )
    {
      itemView.Contact = contact;
      itemView.OnActivate = onPressedContact;
      itemView.OnDelete = onDeleteContact;
      itemView.OnInfo  = onInfoContact;  
      itemView.EditMode = EditMode;
      
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );


  }

  $rect <720,90,890,130>
  slot onPressedContact
  {
    //on contact pressed ->contact will be called
    //var Application::FavContactItem itemView = (Application::FavContactItem)sender;

    SelectedContact =  ((Application::FavContactItem)sender).Contact;

    Application::Device.UpdateCallState ( Application::CallState.RingOutgoing);
    Application::Device.UpdateCallingNumber ( SelectedContact.PhoneNumber );

    SelectedContact = null;

  }

  $rect <490,300,660,340>
  slot onClose
  {
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
    DismissDialog( addFav, Res::SlideDownCentered, null, null, null, null, false);

                               
    addFav = null;
  }

  $rect <300,60,480,100>
  slot onNoOfContactsChanged
  {
    VerticalList.NoOfItems = Application::MyContactsManager.Favorites.NoOfItems;

  }

  $rect <490,20,660,60>
  property Application::Contact SelectedContact = null;

  $rect <490,60,660,100>
  onset SelectedContact
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedContact == value )
      return;

    // Remember the property's new value.
    pure SelectedContact = value;

    notifyobservers ^SelectedContact; 
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <280,170,670,390>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <11,95,261,408>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 32;
    preset ItemClass = Application::FavContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -2;
    preset Bounds = <11,95,261,408>;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt1
  {
    preset Bounds = <11,42,261,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Favorites";
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground PlusButton
  {
    preset Bounds = <11,12,41,42>;
    preset Enabled = true;
    preset OnActivate = onAddPress;
    preset Label = Res::PlusIconTxt;
  }

  $rect <20,20,160,60>
  object Application::TextButton TextButton
  {
    preset Bounds = <213,12,263,37>;
    preset Text = "Edit";
    preset OnActivate = onEdit;
  }

  $rect <900,170,1060,210>
  var Application::ContactDetailsPage detailsPage;

  $rect <720,170,890,210>
  slot onInfoContact
  {
    detailsPage = new Application::ContactDetailsPage;
    //var Application::FavContactItem itemView = (Application::FavContactItem)sender;
    //SelectedContact = itemView.Contact;

    detailsPage.Contact = ((Application::FavContactItem)sender).Contact;
    detailsPage.OnBack = onCloseDetailsPage;

    SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null, null, null, null, false );


  }

  $rect <720,130,890,170>
  slot onDeleteContact
  {
    // delete contact from favorites list

    SelectedContact =  ((Application::FavContactItem)sender).Contact;

    Application::MyContactsManager.Favorites.Remove( SelectedContact );
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );

    SelectedContact = null;
  }

  $rect <740,210,890,250>
  slot onCloseDetailsPage
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);

    SelectedContact = null;
  }

  // Vertical list
  note group Note2
  {
    attr Bounds = <680,0,1100,390>;
  }

  // Initialization
  note group Note3
  {
    attr Bounds = <290,-10,670,160>;
  }

  $rect <290,210,470,250>
  property bool EditMode = false;

  $rect <470,210,660,250>
  slot onEdit
  {
    EditMode = !EditMode;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
  }
}

$rect <220,390,400,430>
$output false
class RecentPage : Core::Group
{
  $rect <290,40,480,80>
  inherited method Init()
  {
    attachobserver onNoOfContactsChanged, ^Application::MyContactsManager.History.NoOfItems;
    postsignal onNoOfContactsChanged;
  }

  $rect <290,120,480,160>
  inherited property Bounds = <0,0,272,440>;

  $rect <0,570,200,610>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,530,200,570>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt1
  {
    preset Bounds = <11,42,261,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Recent";
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Application::TextButton TextButton
  {
    preset Bounds = <213,12,263,37>;
    preset Text = "Edit";
    preset OnActivate = onEdit;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <11,95,261,408>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 50;
    preset ItemClass = Application::RecentContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -2;
    preset Bounds = <11,95,261,408>;
    preset SlideHorz = false;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <690,40,890,80>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var int32 itemNo = VerticalList.Item;

    var Application::ContactHistory contactHistory = (Application::ContactHistory )Application::MyContactsManager.History.GetContact( itemNo );

    var Application::RecentContactItem itemView = (Application::RecentContactItem)VerticalList.View;
                                                  
    if ( itemView == null )
      return;

    if ( contactHistory != null )
    {
      itemView.ContactHistory = contactHistory;  
      itemView.EditMode = EditMode;
      itemView.OnActivate = onPressedContact;
      itemView.OnDelete = onDeleteContact;
      itemView.OnInfo = onInfoContact;
      
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );


  }

  $rect <290,80,480,120>
  slot onNoOfContactsChanged
  {
    VerticalList.NoOfItems = Application::MyContactsManager.History.NoOfItems;

  }

  $rect <490,40,660,80>
  property Application::Contact SelectedContact = null;

  $rect <490,80,660,120>
  onset SelectedContact
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedContact == value )
      return;

    // Remember the property's new value.
    pure SelectedContact = value;

    notifyobservers ^SelectedContact; 
  }

  $rect <290,230,470,270>
  property bool EditMode = false;

  $rect <470,230,650,270>
  slot onEdit
  {
    EditMode = !EditMode;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <280,180,670,400>;
  }

  // Vertical list
  note group Note2
  {
    attr Bounds = <680,0,1100,390>;
  }

  // Initialization
  note group Note3
  {
    attr Bounds = <280,0,670,170>;
  }

  $rect <720,80,890,120>
  slot onPressedContact
  {
    //on contact pressed ->contact will be called
    //var Application::FavContactItem itemView = (Application::FavContactItem)sender;

    SelectedContact =  ((Application::RecentContactItem1)sender).Contact;

    Application::Device.UpdateCallState ( Application::CallState.RingOutgoing);
    Application::Device.UpdateCallingNumber ( SelectedContact.PhoneNumber );

    SelectedContact = null;

  }

  $rect <900,160,1060,200>
  var Application::ContactDetailsPage detailsPage;

  $rect <720,160,890,200>
  slot onInfoContact
  {
    detailsPage = new Application::ContactDetailsPage;
    //var Application::FavContactItem itemView = (Application::FavContactItem)sender;
    //SelectedContact = itemView.Contact;

    detailsPage.Contact = ((Application::RecentContactItem1)sender).Contact;
    detailsPage.OnBack = onCloseDetailsPage;

    SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null, null, null, null, false );


  }

  $rect <720,120,890,160>
  slot onDeleteContact
  {
    // delete contact from favorites list

    SelectedContact =  ((Application::RecentContactItem1)sender).Contact;

    Application::MyContactsManager.History.Remove( SelectedContact );
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );

    SelectedContact = null;
  }

  $rect <740,200,890,240>
  slot onCloseDetailsPage
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);

    SelectedContact = null;
  }
}

$rect <50,470,210,510>
$output false
class ContactsList : Application::ContactsInsideCall
{
  $rect <20,20,160,60>
  inherited object PlusButton
  {
    preset Visible = false;
  }

  $rect <480,10,680,50>
  inherited slot onContactActivated
  {
    //add contact to favorites

    var Application::ContactItem itemView = (Application::ContactItem)sender;
    Application::MyContactsManager.Favorites.Add( itemView.Contact );

    postsignal OnAddFav; 


  }

  $rect <20,20,160,60>
  inherited object TextButton
  {
    preset Bounds = <202,24,268,49>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <12,0,261,30>;
    preset String = "Choose a contact to add to Favourites";
    preset Font = Res::ContactFont12;
    preset Color = Res::Black;
  }

  $rect <280,10,480,50>
  property slot OnAddFav;
}

$rect <430,420,630,460>
$output false
class ContactsManager
{
  $rect <10,10,210,50>
  object Application::Contacts Contacts;

  $rect <10,90,210,130>
  object Application::Contacts History;

  $rect <10,50,210,90>
  object Application::Contacts Favorites;

  $rect <10,130,210,170>
  object Application::Contacts Search;
}

$rect <50,430,209,470>
$output false
class FavContactItem : Application::ContactItem
{
  $rect <60,260,260,300>
  inherited property Bounds = <0,0,250,32>;

  $rect <-20,60,180,100>
  object Effects::Int32Effect EditEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 25;
    preset Value1 = 0;
  }

  $rect <180,80,380,120>
  slot onAnimate
  {
    RemoveButton.Bounds.x    = EditEffect.Value - 25  - DeleteEffect.Value;
    PrfofilButton.Bounds.x   = EditEffect.Value + 6   - DeleteEffect.Value;
    LastNameTxt.Bounds.x     = EditEffect.Value + 55  - DeleteEffect.Value;
    FirstNameTxt.Bounds.x    = EditEffect.Value + 146 - DeleteEffect.Value;
    InfoButton.Bounds.x      = EditEffect.Value + 217  - DeleteEffect.Value;
    TouchHandler.Point1.x    = RemoveButton.Bounds.x2;
    TouchHandler.Point4.x    = RemoveButton.Bounds.x2;
    DeleteButton.Bounds.x    = EditEffect.Value + 273 - DeleteEffect.Value;
  }

  $rect <390,60,590,100>
  property bool EditMode = false;

  $rect <390,100,590,140>
  onset EditMode
  {
    // The value doesn't change - nothing to do.
    if ( pure EditMode == value )
      return;

    // Remember the property's new value.
    pure EditMode = value;

    EditEffect.Reversed = !EditMode;

    if ( EditMode )
    {
      InfoButton.Icon = Res::MenuTxt;
      InfoButton.IconColor = Res::Grey; 
    }
    else
    {
      InfoButton.Icon = Res::InfoTxt;
      InfoButton.IconColor = Res::Blue;
      
      if ( DeleteEffect.Enabled || DeleteEffect.Value == DeleteEffect.Value2 )
      {
        DeleteEffect.Reversed = true;
        signal DeleteEffect.StartEffect;
      }
    }

    signal EditEffect.StartEffect;



  }

  $rect <-20,100,180,140>
  object Effects::Int32Effect DeleteEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 110;
    preset Value1 = 0;
  }

  $rect <190,180,390,220>
  slot onDelete
  {
    postsignal OnDelete;
    //Application::MyContactsManager.Favorites.Remove( Contact );
  }

  $rect <180,140,380,180>
  slot onShowDelete
  {
    DeleteEffect.Reversed = false;
    signal DeleteEffect.StartEffect;

  }

  $rect <-10,180,190,220>
  property slot OnDelete;

  $rect <190,220,390,260>
  slot onInfo
  {
    InfoButton.OnActivate = Slot;
  }

  $rect <-10,220,190,260>
  property slot OnInfo;

  $rect <290,440,450,480>
  var Application::ContactDetailsPage detailsPage;

  $rect <480,480,640,520>
  slot onCloseWindow
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);
  }

  $rect <390,220,590,260>
  slot Slot
  {
    postsignal OnInfo;
  }

  $rect <20,20,160,60>
  inherited object TouchHandler
  {
    preset StackingPriority = -1;
    preset Point3 = <217,32>;
    preset Point2 = <217,0>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,250,32>;
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall RemoveButton
  {
    preset Bounds = <-25,5,0,30>;
    preset OnActivate = onShowDelete;
    preset ButtonColor = Res::Red;
    preset Icon = Res::RemoveTxt;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  object Application::TextButton DeleteButton
  {
    preset Bounds = <250,0,316,32>;
    preset Text = "Delete";
    preset OnActivate = onDelete;
    preset TextColor = Res::White;
    preset TextColorPress = Res::WhiteSemiTransparent;
    preset BackgoundColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall InfoButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <217,5,242,30>;
    preset OnActivate = onInfo;
    preset ButtonColor = Res::Transparent;
    preset Icon = Res::InfoTxt;
    preset IconColor = Res::Blue;
  }

  $rect <20,20,160,60>
  inherited object FirstNameTxt
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <131,8,201,26>;
    preset AutoSize = true;
    preset String = "FirstName";
  }

  $rect <20,20,160,60>
  inherited object LastNameTxt
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <44,8,113,26>;
    preset AutoSize = true;
  }

  $rect <20,20,160,60>
  inherited object Line
  {
    preset Point2 = <250,32>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  inherited object PrfofilButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <6,4,31,29>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <250,0>;
  }

  $reorder EditEffect 11
  $reorder onAnimate 11
  $reorder EditMode 11
  $reorder OnSetEditMode 11
  $reorder DeleteEffect 11
  $reorder onDelete 11
  $reorder onShowDelete 11
  $reorder OnDelete 11
  $reorder onInfo 11
  $reorder OnInfo 11
  $reorder detailsPage 11
  $reorder onCloseWindow 11
  $reorder Slot 11
  $reorder RemoveButton 5
  $reorder DeleteButton 5
  $reorder InfoButton 5
  $reorder FirstnameTxt 1
}

$rect <610,570,810,610>
$variant $SimulateData
vclass SimulateDatabase : Application::ContactsManager
{
  $rect <20,0,220,40>
  inherited method Init()
  {
    CreateContactData();
  }

  $rect <10,90,210,130>
  method void CreateContact( arg string aLastName, arg string aFirstName, arg string aPhoneNumber )
  {
    var Application::Contact MyContact = new Application::Contact;


    MyContact.FirstName = aFirstName;
    MyContact.LastName = aLastName;
    MyContact.PhoneNumber = aPhoneNumber;
    Contacts.Add( MyContact );



  }

  $rect <10,50,210,90>
  method void CreateContactData()
  {
    CreateContact( "Buna", "Zsolt", "sfdg");
    CreateContact( "Benedek", "Norbert", "sfg");
    CreateContact( "Amota", "Adel", "zf");
    CreateContact( "Bacsr", "Amalia", "sfd");
    CreateContact1( "Amota", "Adel", "zf");
    CreateContact2( "Amota", "Adel", "zf");
    CreateContact2( "Benedek", "Norbert", "sfg");


    Contacts.insertionSort();

    //var int32 i =0;

    //for ( i=0; i<100; i++ )
    //{
    //  CreateContact( "Name" + (string)i, "LastName" + (string)i, "0722" + (string)i );
    //}


  }

  $rect <10,130,210,170>
  method void CreateContact1( arg string aLastName, arg string aFirstName, arg string aPhoneNumber )
  {
    var Application::Contact MyContact = new Application::Contact;


    MyContact.FirstName = aFirstName;
    MyContact.LastName = aLastName;
    MyContact.PhoneNumber = aPhoneNumber;
    Favorites.Add( MyContact );



  }

  $rect <10,170,210,210>
  method void CreateContact2( arg string aLastName, arg string aFirstName, arg string aPhoneNumber )
  {
    var Application::ContactHistory MyContact = new Application::ContactHistory;


    MyContact.FirstName = aFirstName;
    MyContact.LastName = aLastName;
    MyContact.PhoneNumber = aPhoneNumber;
    MyContact.CallType = "incoming";
    History.Add( MyContact );



  }
}

$rect <640,500,800,540>
$output false
class ContactHistory : Application::Contact
{
  $rect <10,40,210,80>
  property string CallType;

  $rect <210,40,410,80>
  onset CallType
  {
    // The value doesn't change - nothing to do.
    if ( pure CallType == value )
      return;

    // Remember the property's new value.
    pure CallType = value;

    notifyobservers this;
  }

  $rect <10,80,210,120>
  property string TimeOfCall;

  $rect <210,80,410,120>
  onset TimeOfCall
  {
    // The value doesn't change - nothing to do.
    if ( pure TimeOfCall == value )
      return;

    // Remember the property's new value.
    pure TimeOfCall = value;

    notifyobservers this;
  }

  $rect <10,120,210,160>
  property Core::Time Duration;

  $rect <210,120,410,160>
  onset Duration
  {
    // The value doesn't change - nothing to do.
    if ( pure Duration == value )
      return;

    // Remember the property's new value.
    pure Duration = value;

    notifyobservers this;
  }
}

// The class Core::Time is used for date and time operations. Objects of this class \
// can store the time, convert it and format strings with the time, etc.
$rect <440,320,630,360>
$output false
class Time
{
  $rect <10,690,200,730>
  method string getMonthName( arg int32 aMonth, arg bool aAbbreviated )
  {
    if ( aAbbreviated )
      switch ( aMonth )
      {
        case 1  : return Resources::JanuaryAbbr;
        case 2  : return Resources::FebruaryAbbr;
        case 3  : return Resources::MarchAbbr;
        case 4  : return Resources::AprilAbbr;
        case 5  : return Resources::MayAbbr;
        case 6  : return Resources::JuneAbbr;
        case 7  : return Resources::JulyAbbr;
        case 8  : return Resources::AugustAbbr;
        case 9  : return Resources::SeptemberAbbr;
        case 10 : return Resources::OctoberAbbr;
        case 11 : return Resources::NovemberAbbr;
        case 12 : return Resources::DecemberAbbr;

        default  : return "";
      }
    else
      switch ( aMonth )
      {
        case 1  : return Resources::January;
        case 2  : return Resources::February;
        case 3  : return Resources::March;
        case 4  : return Resources::April;
        case 5  : return Resources::May;
        case 6  : return Resources::June;
        case 7  : return Resources::July;
        case 8  : return Resources::August;
        case 9  : return Resources::September;
        case 10 : return Resources::October;
        case 11 : return Resources::November;
        case 12 : return Resources::December;

        default  : return "";
      }
  }

  $rect <10,650,200,690>
  method string getDayOfWeekName( arg int32 aDayOfWeek, arg bool aAbbreviated )
  {
    if ( aAbbreviated )
      switch ( aDayOfWeek )
      {
        case 1  : return Resources::MondayAbbr;
        case 2  : return Resources::TuesdayAbbr;
        case 3  : return Resources::WednesdayAbbr;
        case 4  : return Resources::ThursdayAbbr;
        case 5  : return Resources::FridayAbbr;
        case 6  : return Resources::SaturdayAbbr;
        case 0  : return Resources::SundayAbbr;
        default : return "";
      }
    else
      switch ( aDayOfWeek )
      {
        case 1  : return Resources::Monday;
        case 2  : return Resources::Tuesday;
        case 3  : return Resources::Wednesday;
        case 4  : return Resources::Thursday;
        case 5  : return Resources::Friday;
        case 6  : return Resources::Saturday;
        case 0  : return Resources::Sunday;
        default : return "";
      }
  }

  $rect <200,650,370,690>
  method int64 getCurrentTime()
  {
    var int64 result;

    $if $prototyper
      result = EwGetTime();
    $endif

    $if !$prototyper && ( $platform != *.WebGL.* )
      native ( result )
      {
        result = EwGetTime();
      }
    $endif

    $if !$prototyper && ( $platform == *.WebGL.* )
      native ( result )
      {
        var d = new Date;
        result = Math.trunc( d.getTime() / 1000 - ( d.getTimezoneOffset() * 60 ));
      }
    $endif

    return result;
  }

  $rect <370,410,550,450>
  onget String
  {
    var string date = string( Year, 4 ) + "-" + string( Month, 2 ) + "-" + string( Day, 2 );
    var string time = string( Hour, 2 ) + ":" + string( Minute, 2 ) + ":" + string( Second, 2 );

    return date + " " + time;
  }

  $rect <190,450,370,490>
  onget Time
  {
    var int32 d    = Day;
    var int32 m    = Month;
    var int32 y    = Year - (( m <= 2 )? 1 : 0 );
    var int32 era  = ( y >= 0 ? y : y - 399 ) / 400;
    var int32 yoe  = y - era * 400;
    var int32 doy  = ( 153 * ( m + (( m > 2 )? -3 : 9 )) + 2 ) / 5 + d - 1;
    var int32 doe  = yoe * 365 + yoe / 4 - yoe / 100 + doy;
    var int32 days = era * 146097 + doe - 719468;

    // Now get the total number of seconds since 1.1.1970
    return ( int64( days ) * ( 60 * 60 * 24 )) +
           ( int64( Hour ) * ( 60 * 60 )) + 
           ( int64( Minute ) * 60 ) +
             int64( Second );
  }

  $rect <190,410,370,450>
  onset Time
  {
    // The reference date is 1 March 0000. Get the seconds between 1 March 0000
    // and 01 Jan. 1970
    value += 62162035200;

    if ( value < 0 )
      value = 0;

    var int32 z   = (int32)( value / ( 60 * 60 * 24 ));
    var int32 era = (( z >= 0 ) ? z : z - 146096 ) / 146097;
    var int32 doe = z - era * 146097;
    var int32 yoe = ( doe - ( doe / 1460 ) + ( doe / 36524 ) - ( doe / 146096 )) / 365;
    var int32 y   = yoe + era * 400;
    var int32 doy = doe - (( 365 * yoe ) + ( yoe / 4 ) - ( yoe / 100 ));
    var int32 mp  = (( 5 * doy ) + 2 ) / 153;
    var int32 d   = doy - (( 153 * mp ) + 2 ) / 5 + 1;
    var int32 m   = mp + (( mp < 10 ) ? 3 : -9 );

    var int32 h = int32(( value / ( 60 * 60 )) % 24 );
    var int32 i = int32(( value / 60 ) % 60 );
    var int32 s = int32( value % 60 );

    Year   = y + (( m <= 2 )? 1 : 0 );
    Month  = m;
    Day    = d;
    Hour   = h + (( h < 0 )? 24 : 0 );
    Minute = i + (( i < 0 )? 60 : 0 );
    Second = s + (( s < 0 )? 60 : 0 );
  }

  $rect <10,410,190,450>
  onget CurrentTime
  {
    return ( new Core::Time ).Initialize( getCurrentTime());
  }

  $rect <10,320,190,360>
  onget DaysInMonth
  {
    // The number of days in February depends on the leap year.
    if ( Month == 2 )
      if ((( Year % 4 ) == 0 ) && ((( Year % 100 ) != 0 ) || (( Year % 400 ) == 0 )))
        return 29;
      else
        return 28;

    // A month with 30 days?
    else if (( Month == 4 ) || ( Month == 6 ) || ( Month == 9 ) || ( Month == 11 ))
      return 30;

    // Every other month has 31 days.
    else
      return 31;
  }

  $rect <370,230,550,270>
  onget WeekOfYear
  {
    // Day of week for the 1 January
    var int32 doy     = DayOfYear - 1;
    var int32 dow     = ( 6 + DayOfWeek ) % 7;
    var int32 dow1Jan = ( 371 + dow -  doy ) % 7;

    // According to ISO 8601 the last day of the year are considered as week 0 of the
    // next year
    if ( Month == 12 )
    {
      var int32 d = Day;

      if (( d == 31 ) && ( dow < 3 )) return 0; 
      if (( d == 30 ) && ( dow < 2 )) return 0; 
      if (( d == 29 ) && ( dow < 1 )) return 0; 
    }

    if ( dow1Jan <= 3 ) doy += dow1Jan;
    else                doy -= 7 - dow1Jan;

    // According to ISO 8601 still in the last week of the previous year?
    if ( doy < 0 )
    {
      var int32 d = Day;
      var int32 m = Month;

      // Change temporarily to 31 Dec. of prev. year
      Year--; Day = 31; Month = 12;

      // Calculate the last week of the preceding year
      doy     = DayOfYear - 1;
      dow     = ( 6 + DayOfWeek ) % 7;
      dow1Jan = ( 371 + dow -  doy ) % 7;

      if ( dow1Jan <= 3 ) doy += dow1Jan;
      else                doy -= dow1Jan;

      // Restore the date
      Year++; Day = d; Month = m;
    }

    return doy / 7;

  }

  $rect <190,230,370,270>
  onget DayOfYear
  {
    var int32 d  = Day;
    var int32 m  = Month;
    var int32 y  = Year;
    var int32 ly = ( !( y % 4 ) && (( y % 100 ) || !( y % 400 )))? 1 : 0;

    switch ( m )
    {
      case  2 : d +=  31;
      case  3 : d +=  59 + ly;
      case  4 : d +=  90 + ly;
      case  5 : d += 120 + ly;
      case  6 : d += 151 + ly;
      case  7 : d += 181 + ly;
      case  8 : d += 212 + ly;
      case  9 : d += 243 + ly;
      case 10 : d += 273 + ly;
      case 11 : d += 304 + ly;
      case 12 : d += 334 + ly;
      default :;
    }

    return d;
  }

  $rect <10,230,190,270>
  onget DayOfWeek
  {
    var int32 d = Day;
    var int32 m = Month + (( Month > 2 )? -2 : 10 );
    var int32 y = Year - (( Month <= 2 )? 1 : 0 );
    var int32 c = y / 100;

    y %= 100;
    d += (( 26 * m - 2 ) / 10 ) + y + y / 4 + c / 4 - 2 * c;

    if ( d >= 0 )
      return d % 7;
    else
      return ( 7 - ( -d % 7 )) % 7;
  }

  $rect <370,140,550,180>
  onset Second
  {
    if ( value < 0 )
      value = 0;

    if ( value > 59 )
      value = 59;

    pure Second = value;
  }

  $rect <190,140,370,180>
  onset Minute
  {
    if ( value < 0 )
      value = 0;

    if ( value > 59 )
      value = 59;

    pure Minute = value;
  }

  $rect <10,140,190,180>
  onset Hour
  {
    if ( value < 0 )
      value = 0;

    if ( value > 23 )
      value = 23;

    pure Hour = value;
  }

  $rect <370,50,550,90>
  onset Day
  {
    if ( value < 1 )
      value = 1;

    if ( value > 31 )
      value = 31;

    pure Day = value;
  }

  $rect <190,50,370,90>
  onset Month
  {
    if ( value < 1 )
      value = 1;

    if ( value > 12 )
      value = 12;

    pure Month = value;
  }

  $rect <10,50,190,90>
  onset Year
  {
    pure Year = value;
  }

  // The method Format() converts the stored date and time accordingly to the supplied \
  // aFormat parameter in a string. The aFormat parameter consists of format codes, \
  // preceded by the percent sign '%'. At the runtime the codes are replaced with \
  // their corresponding content. All other signs that do not begin with % are simply \
  // taken over from aFormat to the output string. Following codes are available:
  // -%d Day of month as decimal number (01-31)
  // -%H Hour in 24-hour format (00-23)
  // -%I Hour in 12-hour format (01-12)
  // -%m Month as decimal number (01-12)
  // -%M Minute as decimal number (00-59)
  // -%p AM / PM indicator
  // -%S Second as decimal number (00-59)
  // -%w Weekday as decimal number (0-6; Sunday is 0)
  // -%y Year without century, as decimal number (00-99)
  // -%Y Year with century as decimal number
  // -%j Day of year as decimal number (001-366)
  // -%W Week of year as decimal number with Monday as first day of week (00-53)
  // -%a Abbreviated weekday name
  // -%A Weekday name
  // -%b Abbreviated month name
  // -%B Month name
  // To remove the leading zeros, the '#' sign may prefix the following format code. \
  // For example '%#m' will format the month as a decimal number in the range 1-12. \
  // In contrast to it, '%m' formats the number with the leading zero sign 01-12.
  // The month and weekday names are stored in constants within the unit @Resources. \
  // To adapt them to a new language, you can create variants of these constants.
  $rect <370,510,550,550>
  method string Format( arg string aFormat )
  {
    var string result = "";
    var int32  inx    = 0;

    // Repeat until the whole format string is processed.
    while ((int32)aFormat[ inx ] != 0 )
    {
      // Is this a special escape sequence?
      if ( aFormat[ inx ] == '%' )
      {
        var int32 leadingZeros = 1;

        // Skip over the leading percent sign.
        inx = inx + 1;

        // The '#' sign removes leading zeros in the following escape sequence.
        if ( aFormat[ inx ] == '#' )
        {
          // Skip over the '#' sign.
          inx = inx + 1;
          leadingZeros = 0;
        }

        // Get the code of the escape sequence.
        switch ( aFormat[ inx ])
        {
          case 'd' : result = result + string( Day,  2 * leadingZeros );
          case 'H' : result = result + string( Hour, 2 * leadingZeros );
          case 'I' :
            if (( Hour % 12 ) == 0 )
              result = result + "12";
            else
              result = result + string( Hour % 12, 2 * leadingZeros );
          case 'm' : result = result + string( Month,  2 * leadingZeros );
          case 'M' : result = result + string( Minute, 2 * leadingZeros );
          case 'p' :
            if ( Hour < 12 )
              result = result + Resources::AM;
            else
              result = result + Resources::PM;
          case 'S' : result = result + string( Second, 2 * leadingZeros );
          case 'w' : result = result + string( DayOfWeek, leadingZeros );
          case 'y' : result = result + string( Year % 100, 2 * leadingZeros );
          case 'Y' : result = result + string( Year, 4 * leadingZeros );
          case '%' : result = result + "%";

          case 'j' : result = result + string( DayOfYear,  3 * leadingZeros );
          case 'W' : result = result + string( WeekOfYear, 2 * leadingZeros );

          case 'a' : result = result + getDayOfWeekName( DayOfWeek, true );
          case 'A' : result = result + getDayOfWeekName( DayOfWeek, false );
          case 'b' : result = result + getMonthName( Month, true );
          case 'B' : result = result + getMonthName( Month, false );

          default  :;
        }
        inx = inx + 1;
      }

      // This is a normal sign - take it over.
      else
      {
        result = result + aFormat[ inx ];
        inx = inx + 1;
      }
    }

    return result;
  }

  // The method Initialize2() initializes this Core::Time object with the given time \
  // and date and returns this object.
  $rect <190,550,370,590>
  method Core::Time Initialize2( arg int32 aYear, arg int32 aMonth, arg int32 aDay, arg int32 aHour, arg int32 aMinute, arg int32 aSecond )
  {
    Year   = aYear;
    Month  = aMonth;
    Day    = aDay;
    Hour   = aHour;
    Minute = aMinute;
    Second = aSecond;

    return this;
  }

  // The method Initialize() initializes this Core::Time object with the given time \
  // as number of seconds since 1.1.1970 and returns this object.
  $rect <190,510,370,550>
  method Core::Time Initialize( arg int64 aTime )
  {
    Time = aTime;
    return this;
  }

  // The method Difference() calculates a delta value between this time object and \
  // the object passed in the parameter aTime. The method creates and initializes \
  // a new Core::TimeSpan object with the calculated difference.
  $rect <10,590,190,630>
  method Core::TimeSpan Difference( arg Core::Time aTime )
  {
    if ( aTime == null )
      return (new Core::TimeSpan).Initialize( Time );

    return (new Core::TimeSpan).Initialize( Time - aTime.Time );
  }

  // The method Subtract() calculates a new time value by a subtraction of the aTimeSpan \
  // from this time object. The method creates a new Core::Time object and initializes \
  // it with the new time and date value.
  $rect <10,550,190,590>
  method Core::Time Subtract( arg Core::TimeSpan aTimeSpan )
  {
    if ( aTimeSpan == null )
      return this;

    return (new Core::Time).Initialize( Time - aTimeSpan.Time );
  }

  // The method Add() calculates a new time value by an addition of the aTimeSpan \
  // to this time object. The method creates a new Core::Time object and initializes \
  // it with the new time and date value.
  $rect <10,510,190,550>
  method Core::Time Add( arg Core::TimeSpan aTimeSpan )
  {
    if ( aTimeSpan == null )
      return this;

    return (new Core::Time).Initialize( Time + aTimeSpan.Time );
  }

  // The property 'String' stores the time as a string: "YYYY-MM-DD hh:mm:ss". This \
  // property is read only - it is not possible to assign a value to it.
  $rect <370,370,550,410>
  property string String;

  // The property 'Time' stores a point in time as the number of seconds since 1.1.1970. \
  // Negative values address points in time before 1.1.1970. The most distant point \
  // supported by the Core::Time class is 1 March 0000.
  // When assigning a value to the property Time, the Core::Time object converts \
  // the given number of seconds in @Year, @Month, @Day, @Hour and @Seconds.
  $rect <190,370,370,410>
  property int64 Time;

  // The property 'CurrentTime' stores the current time. This property is read only \
  // - it is not possible to assign a value to it.
  $rect <10,370,190,410>
  property Core::Time CurrentTime;

  // The property 'WeekOfYear' contains the week of the year as a number in the range \
  // 0 .. 53. Each week starts with Monday. This property is read only - it is not \
  // possible to assign a value to it.
  $rect <370,190,550,230>
  property int32 WeekOfYear;

  // The property 'DaysInMonth' contains the number of days in the month. This property \
  // is read only - it is not possible to assign a value to it.
  $rect <10,280,190,320>
  property int32 DaysInMonth;

  // The property 'DayOfYear' contains the day of the year as a number in the range \
  // 1 .. 366. This property is read only - it is not possible to assign a value \
  // to it.
  $rect <190,190,370,230>
  property int32 DayOfYear;

  // The property 'DayOfWeek' contains the day of the week as a number in the range \
  // 0 .. 6. The value 0 corresponds to Sunday, 1 to Monday, etc. This property is \
  // read only - it is not possible to assign a value to it.
  $rect <10,190,190,230>
  property int32 DayOfWeek;

  // The property 'Second' stores the number of seconds.
  $rect <370,100,550,140>
  property int32 Second;

  // The property 'Minute' stores the number of minutes.
  $rect <190,100,370,140>
  property int32 Minute;

  // The property 'Hour' stores the number of hours since midnight.
  $rect <10,100,190,140>
  property int32 Hour;

  // The property 'Day' stores the day in range 1 .. 31.
  $rect <370,10,550,50>
  property int32 Day;

  // The property 'Month' stores the month in range 1 .. 12.
  $rect <190,10,370,50>
  property int32 Month;

  // The property 'Year' stores the year including the century.
  $rect <10,10,190,50>
  property int32 Year;
}

$rect <241,430,400,470>
$output false
class RecentContactItem1 : Application::ContactItem
{
  $rect <740,290,940,330>
  inherited method Init()
  {
    // TO DO: Write your code here ... 
  }

  $rect <20,580,220,620>
  inherited property Bounds = <0,0,250,50>;

  $rect <20,20,160,60>
  inherited object TouchHandler
  {
    preset Point4 = <0,50>;
    preset Point3 = <220,50>;
    preset Point2 = <220,0>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,0,250,50>;
  }

  $rect <20,20,160,60>
  inherited object LastNameTxt
  {
    preset Layout = Core::Layout[AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <32,2,123,32>;
  }

  $rect <20,20,160,60>
  inherited object Line
  {
    preset Point2 = <250,50>;
    preset Point1 = <0,50>;
  }

  $rect <20,20,160,60>
  inherited object PrfofilButton
  {
    preset Enabled = false;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <250,0>;
  }

  $rect <20,20,160,60>
  inherited object FirstNameTxt
  {
    preset Bounds = <123,1,223,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
  }

  $rect <20,20,160,60>
  object Views::Text CallType
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <32,33,101,47>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Call type";
    preset Font = Resources::DefaultFont;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Text Time
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <173,23,220,35>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Time ";
    preset Font = Resources::DefaultFont;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall PushButtonSmall
  {
    preset Bounds = <0,17,25,42>;
    preset AlphaBlended = true;
    preset ButtonColor = Res::Transparent;
    preset TextColor = Res::Grey;
    preset Icon = Res::OutgoingCallTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall RemoveButton
  {
    preset Bounds = <-25,11,0,36>;
    preset OnActivate = onShowDelete;
    preset ButtonColor = Res::Red;
    preset Icon = Res::RemoveTxt;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  object Application::TextButton DeleteButton
  {
    preset Bounds = <250,1,316,51>;
    preset Text = "Delete";
    preset OnActivate = onDelete;
    preset TextColor = Res::White;
    preset TextColorPress = Res::WhiteSemiTransparent;
    preset BackgoundColor = Res::Red;
  }

  $rect <10,260,170,300>
  object Effects::Int32Effect EditEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 25;
    preset Value1 = 0;
  }

  $rect <180,280,340,320>
  slot onAnimate
  {
    RemoveButton.Bounds.x    = EditEffect.Value - 25  - DeleteEffect.Value;
    PushButtonSmall.Bounds.x = EditEffect.Value + 6   - DeleteEffect.Value;
    LastNameTxt.Bounds.x     = EditEffect.Value + 55  - DeleteEffect.Value;
    FirstNameTxt.Bounds.x    = EditEffect.Value + 146 - DeleteEffect.Value;
    CallType.Bounds.x        = EditEffect.Value + 55 - DeleteEffect.Value;
    InfoButton.Bounds.x      = EditEffect.Value + 217  - DeleteEffect.Value;
    Time.Bounds.x            = EditEffect.Value + 192  - DeleteEffect.Value;
    TouchHandler.Point1.x    = RemoveButton.Bounds.x2;
    TouchHandler.Point4.x    = RemoveButton.Bounds.x2;
    DeleteButton.Bounds.x    = EditEffect.Value + 273 - DeleteEffect.Value;
  }

  $rect <10,120,210,160>
  property bool EditMode = false;

  $rect <10,160,210,200>
  onset EditMode
  {
    // The value doesn't change - nothing to do.
    if ( pure EditMode == value )
      return;

    // Remember the property's new value.
    pure EditMode = value;

    EditEffect.Reversed = !EditMode;

    if ( EditMode )
    {
      InfoButton.Visible = false;
    }
    else
    {
      InfoButton.Visible = true;
      
      if ( DeleteEffect.Enabled || DeleteEffect.Value == DeleteEffect.Value2 )
      {
        DeleteEffect.Reversed = true;
        signal DeleteEffect.StartEffect;
      }
    }

    signal EditEffect.StartEffect;



  }

  $rect <10,300,170,340>
  object Effects::Int32Effect DeleteEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 110;
    preset Value1 = 0;
  }

  $rect <370,90,540,130>
  slot onDelete
  {
    postsignal OnDelete;
  }

  $rect <370,50,540,90>
  slot onShowDelete
  {
    DeleteEffect.Reversed = false;
    signal DeleteEffect.StartEffect;

  }

  $rect <540,90,710,130>
  property slot OnDelete;

  $rect <370,130,540,170>
  slot onInfo
  {
    postsignal OnInfo;
  }

  $rect <540,130,710,170>
  property slot OnInfo;

  $rect <20,20,160,60>
  object Application::PushButtonSmall InfoButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <225,14,250,39>;
    preset OnActivate = onInfo;
    preset ButtonColor = Res::Transparent;
    preset Icon = Res::InfoTxt;
    preset IconColor = Res::Blue;
  }

  // Moving effect
  // 

  note group Note
  {
    attr Bounds = <0,210,350,350>;
  }

  // Touch screen events
  // 

  note group Note1
  {
    attr Bounds = <360,0,720,350>;
  }

  // Initialization

  note group Note2
  {
    attr Bounds = <0,80,350,210>;
  }

  $rect <750,100,940,140>
  onset ContactHistory
  {
    // The value doesn't change - nothing to do.
    if ( pure ContactHistory == value )
      return;

    if ( pure ContactHistory != null )
    {
       detachobserver onContactRistoryUpdate, pure ContactHistory;
    }

    // Remember the property's new value.
    pure ContactHistory = value;

    if ( pure ContactHistory != null )
    {
      attachobserver onContactRistoryUpdate, pure ContactHistory;
      postsignal onContactRistoryUpdate;
    }

  }

  $rect <750,140,940,180>
  slot onContactRistoryUpdate
  {
    if ( pure ContactHistory != null )
    {
      LastNameTxt.String  =  pure ContactHistory.LastName;
      FirstNameTxt.String = pure ContactHistory.FirstName;
      CallType.String     = pure ContactHistory.CallType;
      
    }
    else
    {

    }

    postsignal onContactHistoryUpdate;

  }

  $rect <750,60,940,100>
  property Application::ContactHistory ContactHistory = null;

  // Contact data
  note group Note4
  {
    attr Bounds = <730,0,950,210>;
  }

  $reorder Line 1
  $reorder PrfofilButton 1
  $reorder Line1 1
}

$rect <270,480,429,520>
$output false
class RecentContactItem : Core::Group
{
  $rect <30,450,230,490>
  inherited property Bounds = <0,0,250,50>;

  $rect <580,110,780,150>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    if (LastNameTxt != null )
    {
      var color clr = NameColor;
      var Resources::Font font = Res::ContactFontBold15; 
      LastNameTxt.Font  = font;
      LastNameTxt.Color     = clr;
     }
    if (FirstNameTxt!= null)
    {
      var color clr = NameColor;
      var Resources::Font font = Res::ContactFont15; 
      FirstNameTxt.Font = font;
      FirstNameTxt.Color = clr;
     }

    if (CallType != null)
    {
      var color clr = NameColor1; 
      CallType.Font = Res::ContactFont12;
      CallType.Color = clr;
     }

    if (Time != null)
    {
      var color clr = NameColor1; 
      Time.Font = Res::ContactFont12;
      Time.Color = clr;
     }



    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
      PushButtonSmall.IconColor = Res::Grey;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
      
      PushButtonSmall.IconColor = Res::Grey;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GreyLight;
      
      PushButtonSmall.IconColor = Res::Grey;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
      
      PushButtonSmall.IconColor = Res::Grey;
    }




    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // Contact data
  note group Note4
  {
    attr Bounds = <570,330,790,520>;
  }

  // State management
  note group Note5
  {
    attr Bounds = <570,70,790,320>;
  }

  $rect <580,270,780,310>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <580,230,780,270>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <580,190,780,230>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <580,150,780,190>
  var bool enabled;

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <10,108,159,148>
  property string Icon = Res::OutgoingCallTxt;

  $rect <170,110,320,150>
  property string Text = "";

  $rect <170,150,320,190>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <10,278,159,318>
  property color ButtonColor = Res::White;

  $rect <10,318,159,358>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <10,188,159,228>
  property color IconColor = Res::White;

  $rect <10,228,159,268>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <340,390,560,520>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <340,250,560,380>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <340,70,560,240>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <350,430,550,470>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <350,290,550,330>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <350,470,550,510>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <350,330,550,370>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <10,148,159,188>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <350,190,550,230>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <350,150,550,190>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <10,378,159,418>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <350,110,550,150>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,250,52>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <25,52>;
    preset Point3 = <220,52>;
    preset Point2 = <220,0>;
    preset Point1 = <25,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <250,50>;
    preset Point1 = <0,50>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Views::Text LastNameTxt
  {
    preset Bounds = <32,4,114,22>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "LastName";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text FirstNameTxt
  {
    preset StackingPriority = 0;
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz];
    preset Bounds = <114,4,220,22>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "FirstName";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text CallType
  {
    preset Bounds = <32,33,101,47>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Call type";
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text Time
  {
    preset Bounds = <162,22,220,36>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Time ";
    preset Font = Resources::DefaultFont;
  }

  $rect <170,190,320,230>
  property color NameColor = Res::Black;

  $rect <170,230,320,270>
  onset NameColor
  {
    // The value doesn't change - nothing to do.
    if ( pure NameColor == value )
      return;

    // Remember the property's new value.
    pure NameColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <170,270,320,310>
  property color NameColor1 = Res::Grey;

  $rect <170,310,320,350>
  onset NameColor1
  {
    // The value doesn't change - nothing to do.
    if ( pure NameColor1 == value )
      return;

    // Remember the property's new value.
    pure NameColor1 = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall InfoButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <225,14,250,39>;
    preset ButtonColor = Res::Transparent;
    preset Icon = Res::InfoTxt;
    preset IconColor = Res::Blue;
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall PushButtonSmall
  {
    preset Bounds = <0,17,25,42>;
    preset AlphaBlended = true;
    preset ButtonColor = Res::Transparent;
    preset TextColor = Res::Grey;
    preset Icon = Res::OutgoingCallTxt;
  }

  // Design
  note group Note6
  {
    attr Bounds = <0,70,330,520>;
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall RemoveButton
  {
    preset Bounds = <-25,11,0,36>;
    preset OnActivate = onShowDelete;
    preset ButtonColor = Res::Red;
    preset Icon = Res::RemoveTxt;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  object Application::TextButton DeleteButton
  {
    preset Bounds = <250,1,316,51>;
    preset Text = "Delete";
    preset OnActivate = onDelete;
    preset TextColor = Res::White;
    preset TextColorPress = Res::WhiteSemiTransparent;
    preset BackgoundColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <250,0>;
    preset Point1 = <0,0>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <10,710,170,750>
  object Effects::Int32Effect EditEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 25;
    preset Value1 = 0;
  }

  $rect <180,730,340,770>
  slot onAnimate
  {
    RemoveButton.Bounds.x    = EditEffect.Value - 25  - DeleteEffect.Value;
    PushButtonSmall.Bounds.x = EditEffect.Value + 6   - DeleteEffect.Value;
    LastNameTxt.Bounds.x     = EditEffect.Value + 55  - DeleteEffect.Value;
    FirstNameTxt.Bounds.x    = EditEffect.Value + 146 - DeleteEffect.Value;
    CallType.Bounds.x        = EditEffect.Value + 55 - DeleteEffect.Value;
    InfoButton.Bounds.x      = EditEffect.Value + 217  - DeleteEffect.Value;
    Time.Bounds.x            = EditEffect.Value + 192  - DeleteEffect.Value;
    TouchHandler.Point1.x    = RemoveButton.Bounds.x2;
    TouchHandler.Point4.x    = RemoveButton.Bounds.x2;
    DeleteButton.Bounds.x    = EditEffect.Value + 273 - DeleteEffect.Value;
  }

  $rect <10,570,210,610>
  property bool EditMode = false;

  $rect <10,610,210,650>
  onset EditMode
  {
    // The value doesn't change - nothing to do.
    if ( pure EditMode == value )
      return;

    // Remember the property's new value.
    pure EditMode = value;

    EditEffect.Reversed = !EditMode;

    if ( EditMode )
    {
      InfoButton.Visible = false;
    }
    else
    {
      InfoButton.Visible = true;
      
      if ( DeleteEffect.Enabled || DeleteEffect.Value == DeleteEffect.Value2 )
      {
        DeleteEffect.Reversed = true;
        signal DeleteEffect.StartEffect;
      }
    }

    signal EditEffect.StartEffect;



  }

  $rect <10,750,170,790>
  object Effects::Int32Effect DeleteEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 110;
    preset Value1 = 0;
  }

  // Moving effect

  note group Note
  {
    attr Bounds = <0,660,330,800>;
  }

  // Initialization
  note group Note7
  {
    attr Bounds = <0,530,330,660>;
  }

  $rect <350,620,520,660>
  slot onDelete
  {
    postsignal OnDelete;
  }

  $rect <350,580,520,620>
  slot onShowDelete
  {
    DeleteEffect.Reversed = false;
    signal DeleteEffect.StartEffect;

  }

  $rect <520,620,690,660>
  property slot OnDelete;

  $rect <350,660,520,700>
  slot onInfo
  {
    postsignal OnInfo;
  }

  $rect <520,660,690,700>
  property slot OnInfo;

  // Touch screen events

  note group Note8
  {
    attr Bounds = <340,530,700,790>;
  }

  $rect <590,410,780,450>
  onset ContactHistory
  {
    // The value doesn't change - nothing to do.
    if ( pure ContactHistory == value )
      return;

    if ( pure ContactHistory != null )
    {
       detachobserver onContactRistoryUpdate, pure ContactHistory;
    }

    // Remember the property's new value.
    pure ContactHistory = value;

    if ( pure ContactHistory != null )
    {
      attachobserver onContactRistoryUpdate, pure ContactHistory;
      postsignal onContactRistoryUpdate;
    }

  }

  $rect <590,450,780,490>
  slot onContactRistoryUpdate
  {
    if ( pure ContactHistory != null )
    {
      LastNameTxt.String  =  pure ContactHistory.LastName;
      FirstNameTxt.String = pure ContactHistory.FirstName;
      CallType.String     = pure ContactHistory.CallType;
      
    }

  }

  $rect <590,370,780,410>
  property Application::ContactHistory ContactHistory = null;
}
