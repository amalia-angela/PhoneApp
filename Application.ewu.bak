$version 11.00

$rect <30,110,210,150>
$output false
class ContactsPage : Core::Group
{
  $rect <310,40,510,80>
  inherited method Init()
  {
    attachobserver onNoOfContactsChanged, ^Application::MyContacts.NoOfItems;
    postsignal onNoOfContactsChanged;

    attachobserver onContactsSortingChanged, ^Application::MyContacts.Sorting;
    postsignal onContactsSortingChanged;






  }

  $rect <310,80,510,120>
  inherited property Bounds = <0,0,272,440>;

  $rect <450,210,650,250>
  slot onAddPress
  {
    addContact = new Application::ContactAddPage;

    addContact.OnSave  = onSaveAdd;
    addContact.OnClose = onCancelAdd; 
    addContact.Contact = new Application::Contact;

    SwitchToDialog( addContact, Res::SlideUpCentered, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <300,210,450,250>
  var Application::ContactAddPage addContact = null;

  $rect <470,250,650,290>
  slot onSaveAdd
  {
    Application::MyContacts.Add( addContact.Contact );

    DismissDialog( addContact, Res::SlideDownCentered, null, null, null, null, false);

    addContact = null;
  }

  $rect <470,290,650,330>
  slot onCancelAdd
  {
    DismissDialog( addContact, Res::SlideDownCentered, null, null, null, null, false);
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,760,140>;
  }

  $rect <1050,40,1250,80>
  property int32 SelectedContact;

  $rect <1050,80,1250,120>
  onset SelectedContact
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedContact == value )
      return;

    // Remember the property's new value.
    pure SelectedContact = value;

    notifyobservers ^SelectedContact; 
  }

  $rect <470,420,650,460>
  slot onDeleteContact
  {
    //the "SelectedContact" has been changed, reload item and the rest after that
    VerticalList.InvalidateItems( SelectedContact, VerticalList.NoOfItems - 1 );
     
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);
  }

  $rect <800,180,1040,220>
  slot onSearch
  {
    /*var Application::Contact it = contact;
    var string filter                = SearchExt.String;
    var int32  i;
    var int32  j = 0;


    while ( it != null )
    {
      if (( it.FirstName.find( filter, 0 ) >= 0 ) ||
          ( it.LastName.find( filter, 0 ) >= 0 ))
          ///////////////////////// 
        Filtered_Array[j++] = Original_Array[i];
      
      contact = contact.next;
      j++;
    }

    // Inform the list about its changed size
    VerticalList.NoOfItems = j;
    VerticalList.InvalidateItems( 0, j );
    */
  }

  $rect <300,340,450,380>
  var Application::ContactDetailsPage detailsPage;

  $rect <470,380,650,420>
  slot onCloseContact
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,150,760,550>;
  }

  $rect <300,460,500,500>
  slot onUpPress
  {
    Application::MyContacts.Sorting = Application::Sorting.Ascending;

    trace "asc";

  }

  $rect <300,500,500,540>
  slot onDownPress
  {
    Application::MyContacts.Sorting = Application::Sorting.Descending;

    trace "dsc";
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <800,140,1040,180>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var int32 itemNo = VerticalList.Item;

    var Application::Contact contact = Application::MyContacts.GetContact( itemNo );

    var Application::ContactItem itemView = (Application::ContactItem)VerticalList.View;
                                                  
    if ( itemView == null )
      return;

    if(contact != null )
    {
      itemView.Contact = contact;
      itemView.OnActivate = onContactActivated;
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <790,40,1030,80>
  slot onNoOfContactsChanged
  {
    VerticalList.NoOfItems = Application::MyContacts.NoOfItems;

  }

  // Vertical list
  note group Note1
  {
    attr Bounds = <780,0,1290,320>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <10,126,260,440>;
    preset OnUpdate = null;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 35;
    preset ItemClass = Application::ContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -1;
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,126,260,440>;
    preset SnapNext = <0,35>;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground UpButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <235,100,261,126>;
    preset OnActivate = onUpPress;
    preset Label = Res::Uptxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground DownButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <209,100,235,126>;
    preset Enabled = true;
    preset OnActivate = onDownPress;
    preset Label = Res::DownTxt;
  }

  $rect <20,20,160,60>
  object Application::SearchEtxt SearchExt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <2,68,268,100>;
    preset OnChange = onSearch;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <11,27,261,61>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Contacts";
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground PlusButton
  {
    preset Bounds = <242,12,272,42>;
    preset Enabled = true;
    preset OnActivate = onAddPress;
    preset Label = Res::PlusIconTxt;
  }

  $rect <790,80,1030,120>
  slot onContactsSortingChanged
  {
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
  }

  $rect <450,340,650,380>
  slot onContactActivated
  {
    var Application::ContactItem itemView = (Application::ContactItem)sender;

    if ( itemView != null )
    {
      detailsPage = new Application::ContactDetailsPage;
      detailsPage.OnBack = onCloseContact;
      detailsPage.OnDelete = onDeleteContact;

      detailsPage.Contact = itemView.Contact;
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }

  }
}

// UI Pages
note group Note
{
  attr Bounds = <0,0,410,370>;
}

// Resorces
note group Note1
{
  attr Bounds = <420,0,840,370>;
}

$rect <51,150,210,190>
$output false
class ContactItem : Core::Group
{
  $rect <290,0,490,40>
  inherited property Bounds = <0,0,272,32>;

  $rect <10,100,210,140>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GeryLight;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }




    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,32>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text LastNameTxt
  {
    preset Bounds = <55,2,146,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "LastName";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text FirstnameTxt
  {
    preset StackingPriority = 0;
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz];
    preset Bounds = <146,2,268,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "FirstName";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <268,32>;
    preset Point1 = <0,32>;
    preset Width = 1;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::PushButtonSmall PushButtonSmall
  {
    preset Bounds = <6,4,31,29>;
  }

  $rect <230,110,430,150>
  property Application::Contact Contact = null;

  $rect <230,150,430,190>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <230,190,430,230>
  slot onContactUpdated
  {
    if ( Contact != null )
    {
      FirstnameTxt.String = pure Contact.FirstName;
      LastNameTxt.String = pure Contact.LastName;
      PushButtonSmall.Label = Application::MyContacts.GetInitials( Contact.LastName, Contact.FirstName );
    }

  }

  // Contact data
  note group Note4
  {
    attr Bounds = <220,60,440,270>;
  }

  // State management
  note group Note5
  {
    attr Bounds = <0,60,220,310>;
  }

  $rect <10,260,210,300>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <10,220,210,260>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <10,180,210,220>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <10,140,210,180>
  var bool enabled;

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <580,0,780,40>
  property string Icon;

  $rect <790,0,990,40>
  property string Text = "";

  $rect <790,40,990,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <990,0,1190,40>
  property color ButtonColor = Res::White;

  $rect <990,40,1190,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <1190,0,1390,40>
  property color IconColor = Res::White;

  $rect <1190,40,1390,80>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <460,320,680,450>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <230,320,450,450>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <0,320,220,490>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <470,360,670,400>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <240,360,440,400>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <470,400,670,440>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <240,400,440,440>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <580,40,780,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <10,440,210,480>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <10,400,210,440>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <370,0,570,40>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <10,360,210,400>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <1390,0,1590,40>
  property color TextColor = Res::Black;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,32>;
    preset Point3 = <268,32>;
    preset Point2 = <268,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }
}

$rect <30,190,210,230>
$output false
class ContactDetailsPage : Core::Group
{
  $rect <-10,510,190,550>
  inherited property Bounds = <0,0,272,440>;

  $rect <450,50,630,90>
  slot onTapEdit
  {
    edit = new Application::ContactEditPage;

    edit.OnSave  = onSaveEdit;
    edit.OnClose = onCancelEdit;
    edit.Contact = Contact;
    edit.OnDelete = onDelete;

    SwitchToDialog( edit, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );
     



  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <770,0,1240,200>;
  }

  $rect <460,210,620,250>
  slot onDelete
  {
    signal OnDelete;
    DismissDialog( edit, Res::FadeInOutCentered, null, null, null, null, false);
  }

  $rect <300,210,460,250>
  property slot OnDelete;

  $rect <300,50,450,90>
  var Application::ContactEditPage edit;

  $rect <290,280,460,320>
  var Application::CallPage call;

  $rect <460,280,640,320>
  slot onTapCall
  {
    /*call = new Application::CallPage;

    call.OnEndCall = onCallEnd;
    call.Contact = Contact;

    SwitchToDialog( call, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );  */
     

     //simulatio 
    Application::Device.UpdateCallState( Application::CallState.RingOutgoing );
    Application::Device.UpdateCallingNumber( Contact.PhoneNumber );

  }

  $rect <480,320,640,360>
  slot onCallEnd
  {
    DismissDialog( call, Res::FadeInOutCentered, null, null, null, null, false);
  }

  $rect <460,90,620,130>
  slot onSaveEdit
  {
    //Contact = Application::MyContact;
    DismissDialog( edit, Res::FadeInOutCentered, null, null, null, null, false);
  }

  $rect <460,130,620,170>
  slot onCancelEdit
  {
    DismissDialog( edit, Res::FadeInOutCentered, null, null, null, null, false);
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,760,480>;
  }

  $rect <300,170,460,210>
  property slot OnBack;

  $rect <460,170,620,210>
  slot onBack
  {
    signal OnBack;
  }

  $rect <790,90,980,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <790,130,980,170>
  slot onContactUpdated
  {
    if ( pure Contact != null )
    {
      ContactName.String =       pure Contact.LastName + " "  + pure Contact.FirstName;
      NumberTxt.String = pure Contact.PhoneNumber; 
      
      UserInitialsBtn.Initials =  Application::MyContacts.GetInitials( pure Contact.LastName, pure Contact.FirstName );
      
    }

  }

  $rect <790,50,980,90>
  property Application::Contact Contact;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <265,310>;
    preset Point1 = <7,310>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text NumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <19,281,263,310>;
    preset ColorBR = #FFFFFF00;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = " +0749320298";
    preset Font = Res::ContactFont15;
    preset Color = Res::Blue;
  }

  $rect <20,20,160,60>
  object Views::Text MobileTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <7,255,265,288>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = " mobile";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <265,255>;
    preset Point1 = <7,255>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumBlue CallBtn
  {
    preset Bounds = <51,160,101,235>;
    preset OnActivate = onTapCall;
    preset Icon = Res::CallTxt;
    preset Descrip = "call";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumBlue VideoCallBtn
  {
    preset Bounds = <111,160,161,235>;
    preset Enabled = false;
    preset Icon = Res::VideoCallTxt;
    preset Descrip = "video";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumBlue PushButtonMediumBlue2
  {
    preset Bounds = <171,160,221,235>;
    preset Enabled = false;
    preset Icon = Res::MessageIconTxt;
    preset Descrip = "message";
  }

  $rect <20,20,160,60>
  object Views::Text ContactName
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,113,268,143>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont29;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitialsBtn
  {
    preset Bounds = <101,22,171,113>;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground EditBtn
  {
    preset Bounds = <240,4,265,29>;
    preset OnActivate = onTapEdit;
    preset Label = Res::EditIconTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground BackBtn
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onBack;
    preset Label = Res::BackIconTxt;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,90,630,130>
$output false
class PushButtonMediumBlue : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,50,75>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */


    // Update the parameters of the text view (label)
    if ( IconTxt != null )
    {
       var color clr = Res::White; 
      IconTxt.Font   = Res::IconsFont20;
      IconTxt.String = Icon;
      IconTxt.Color  = clr;
      }

    if ( DescripTxt != null )
    {
       var color clr = Res::Blue; 
      DescripTxt.Font      = Res::ContactFont12;
      DescripTxt.String = Descrip;
      DescripTxt.Color     = clr;
      }

    if ( !isEnabled )
    {
      Background.Color = Res::Grey;
      DescripTxt.Color = Res::Grey;
       IconTxt.Color   = Res::GeryLight;
    }                  

    else if ( isPressed )
    {
      Background.Color = Res::BlueLight;
    }

    else if ( isSelected )
    {
      Background.Color = Res::Blue;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = Res::Blue;
    }



    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,50,50>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,50>;
    preset Point3 = <50,50>;
    preset Point2 = <50,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <1,0,50,50>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <450,50,650,90>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Icon = "";

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Bounds = <0,50,50,75>;
    preset Font = Res::ContactFont12;
    preset Color = Res::Blue;
  }

  $rect <650,10,850,50>
  property string Descrip = "";

  $rect <650,50,850,90>
  onset Descrip
  {
    // The value doesn't change - nothing to do.
    if ( pure Descrip == value )
      return;

    // Remember the property's new value.
    pure Descrip = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,50,630,90>
$output false
class PushButtonBig : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,70,91>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    // Update the parameters of the text view (label)
    if ( Text != null )
    {
       var color clr = InitialsColor; 
      Text.Font      = Res::TitileFont25;
      Text.String = Initials;
      Text.Color     = clr;
      }

      // Update the parameters of the text view (label)
    if ( DescripTxt != null )
    {
       var color clr = DescriptColor; 
      DescripTxt.Font      = Res::ContactFont12;
      DescripTxt.String = Descript;
      DescripTxt.Color     = clr;
      }


    if ( !isEnabled )
    {
      Background.Color = Res::Grey;
      DescripTxt.Visible = false;
      //Border.Color     = #CCCCCCFF;
      //Border.Width     = 1;
    }

    else if ( isPressed )
    {
      Background.Color = Res::Grey;
      //Border.Color     = #000000FF;
     // Border.Width     = 3;
    }

    else if ( isSelected )
    {
      Background.Color =Res::Grey;
     // Border.Color     = #444444FF;
     // Border.Width     = 3;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = Res::Grey;
     // Border.Color     = #444444FF;
     // Border.Width     = 1;
    }



    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <450,50,650,90>
  onset Initials
  {
    // The value doesn't change - nothing to do.
    if ( pure Initials == value )
      return;

    // Remember the property's new value.
    pure Initials = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Initials = "";

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,70,70>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundBig;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,91>;
    preset Point3 = <70,91>;
    preset Point2 = <70,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,70,70>;
    preset String = "";
    preset Font = Res::IconsFont30;
    preset Color = #FFFFFFFF;
  }

  $rect <240,70,440,110>
  property color Property;

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Bounds = <0,70,70,91>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertBottom];
    preset String = "";
    preset Font = Res::ContactFontBold15;
  }

  $rect <870,10,1070,50>
  property string Descript = "";

  $rect <870,50,1070,90>
  onset Descript
  {
    // The value doesn't change - nothing to do.
    if ( pure Descript == value )
      return;

    // Remember the property's new value.
    pure Descript = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <1080,10,1280,50>
  property color DescriptColor = Res::Blue;

  $rect <1080,50,1280,90>
  onset DescriptColor
  {
    // The value doesn't change - nothing to do.
    if ( pure DescriptColor == value )
      return;

    // Remember the property's new value.
    pure DescriptColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <660,10,860,50>
  property color InitialsColor = Res::White;

  $rect <660,50,860,90>
  onset InitialsColor
  {
    // The value doesn't change - nothing to do.
    if ( pure InitialsColor == value )
      return;

    // Remember the property's new value.
    pure InitialsColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,170,630,210>
$output false
class PushButtonSmall : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,25,25>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    // Update the parameters of the text view (label)
    if ( Text != null )
    {
      var color clr = #FFFFFFFF; 
      Text.Font      = Res::ContactFont12;
      Text.String = Label;
      Text.Color     = clr;
      }
    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color = Res::Grey;
      //Border.Color     = #CCCCCCFF;
      //Border.Width     = 1;
    }

    else if ( isPressed )
    {
      Background.Color = Res::Grey;
      //Border.Color     = #000000FF;
     // Border.Width     = 3;
    }

    else if ( isSelected )
    {
      Background.Color = Res::Grey;
    }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = Res::Grey;
    }


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.
    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <450,50,650,90>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Label = "";

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,25,25>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,25>;
    preset Point3 = <25,25>;
    preset Point2 = <25,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,25,25>;
    preset String = "";
    preset Font = Res::IconsFont25;
    preset Color = #FFFFFFFF;
  }

  $reorder Bounds 1
  $reorder first 1
  $reorder last 1
  $reorder keyHandlers 1
  $reorder buffer 1
  $reorder dialogStack 1
  $reorder fadersQueue 1
  $reorder pendingFader 1
  $reorder processKeyHandlers 1
  $reorder updateBufferSlot 1
  $reorder drawContent 1
  $reorder recalculateLayout 1
  $reorder updateComponent 1
  $reorder OnSetFocus 1
  $reorder OnGetBuffered 1
  $reorder OnSetBuffered 1
  $reorder OnGetEnabled 1
  $reorder OnSetEnabled 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder DrawForeground 1
  $reorder DrawBackground 1
  $reorder GetMinimalSize 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateLayout 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder RemoveAll 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Note4 1
  $reorder Note3 1
  $reorder Note2 1
  $reorder Note1 1
  $reorder pressed 1
  $reorder selected 1
  $reorder enabled 1
  $reorder FlashTimer 1
  $reorder KeyHandler 1
  $reorder onFlashTimer 1
  $reorder onPressKey 1
  $reorder onEnterLeaveTouch 1
  $reorder onReleaseTouch 1
  $reorder onPressTouch 1
  $reorder OnSetLabel 1
  $reorder Label 1
  $reorder textView 1
  $reorder Background 1
  $reorder TouchHandler 1
  $reorder OnActivate 1
  $reorder Text 1
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,220,630,260>
$output false
class PushButtonNoBackground : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,25,25>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */


    // Update the parameters of the text view (label)
    if ( Text != null )
    {
      var color clr = Res::Blue; 
      Text.Font      = Res::IconsFont25;
      Text.String = Label;
      Text.Color     = clr;
      }


    if ( !isEnabled )
    {
      Background.Color = Res::WhiteTransparent;
      Text.Color       = Res::Grey;
    }

    else if ( isPressed )
    {
      Background.Color = Res::WhiteTransparent;
      Text.Color       = Res::BlueLight;
    }

    else if ( isSelected )
    {
      Background.Color = Res::WhiteTransparent ;
      }

    // Enabled but not pressed nor selected.
    else
    {
     Background.Color = Res::WhiteTransparent ;
    }


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,25,25>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,25>;
    preset Point3 = <25,25>;
    preset Point2 = <25,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,25,25>;
    preset String = "";
    preset Font = Res::IconsFont25;
    preset Color = #FFFFFFFF;
  }

  $rect <450,50,650,90>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Label = "";

  $rect <710,350,910,390>
  var Views::Text textView;
}

// This component implements an editor.
$rect <639,50,830,90>
$output false
class SearchEtxt : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,266,32>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
      blinkEffect.Enabled = true;

    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }
  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point  rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32  newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
     {
      ObtainFocus();
     }
    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // The begin of the row reached? Skip to the end of the preceding row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // The end of the current row reached? Skip to the begin of the next
      // following row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal OnChange;
  }

  $rect <480,170,680,210>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <280,170,480,210>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <690,80,890,120>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32 inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <690,40,890,80>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <490,40,690,80>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;
  }

  $rect <290,40,490,80>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <690,120,890,160>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <490,120,690,160>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <290,120,490,160>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <690,0,890,40>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <490,0,690,40>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <290,0,490,40>
  property Resources::Font Font = Resources::FontMedium;

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  $rect <20,20,160,60>
  object Views::Frame Frame
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0, 268, 32>;
    preset Color = #F0F0F0FD;
    preset Bitmap = Res::SearchButton;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,32>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,32>;
    preset Point3 = <272,32>;
    preset Point2 = <272,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <48,2,272,32>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Search\n";
    preset Font = Resources::FontSmall;
    preset Color = #B9B9B9FD;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <50,70>;
    preset Point1 = <50,50>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Text Search
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,2,41,27>;
    preset WrapText = true;
    preset String = Res::SerachIconTxt;
    preset Font = Res::IconsFont25;
    preset Color = #B9B9B9FD;
  }
}

$rect <30,270,210,310>
$output false
class ContactAddPage : Core::Group
{
  $rect <280,0,480,40>
  inherited property Bounds = <0,0,272,440>;

  $rect <760,100,960,140>
  inherited method UpdateViewState()
  {
    // Always give the ancestor class a chance to process this event.
    super( aState );

    if(Contact)
    {

    if (FirstNameTxt.String != "" ||
        LastNameTxt.String != "" ||
        PhoneNumberTxt.String !=  "")
    {
      SaveBtn.Enabled = true;
    }

    else
     SaveBtn.Enabled = false;
     }
     
  }

  $rect <311,100,511,140>
  slot onSave
  {
    notifyobservers pure Contact;
    signal OnSave;
  }

  $rect <521,100,721,140>
  property slot OnSave;

  $rect <310,240,510,280>
  property Application::Contact Contact;

  $rect <310,280,510,320>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }
  }

  $rect <310,320,510,360>
  slot onContactUpdated
  {
    Contact.FirstName = FirstNameTxt.String;
    Contact.LastName = LastNameTxt.String;
    Contact.PhoneNumber = PhoneNumberTxt.String;
    Contact.NameInitials = Application::MyContacts.GetInitials( LastNameTxt.String, FirstNameTxt.String);


         



  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,190,740,390>;
  }

  $rect <311,141,511,181>
  slot onClose
  {
    signal OnClose;
  }

  $rect <521,141,721,181>
  property slot OnClose;

  // Touch screen events
  note group Note
  {
    attr Bounds = <291,50,740,190>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <-1,0,271,440>;
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <265,289>;
    preset Point1 = <7,289>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt PhoneNumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,257,269,289>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Blue;
    preset Placeholder = "Mobile number";
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <264,256>;
    preset Point1 = <6,256>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt FirstNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,224,269,256>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "First Name";
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <264,223>;
    preset Point1 = <6,223>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt LastNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,191,269,223>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "Last Name";
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <264,190>;
    preset Point1 = <6,190>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitials
  {
    preset Bounds = <100,78,170,169>;
    preset Descript = "Add Photo";
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <86,7,186,37>;
    preset String = "New Contact";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground SaveBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Enabled = false;
    preset OnActivate = onSave;
    preset Label = Res::CkeckIconTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground CloseButton
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onClose;
    preset Label = Res::CloseIconTxt;
  }

  $rect <530,320,730,360>
  slot onFieldChanged
  {
    UserInitials.Initials = Application::MyContacts.GetInitials( LastNameTxt.String, FirstNameTxt.String );
    InvalidateViewState();
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,50,970,190>;
  }
}

$rect <30,230,210,270>
$output false
class ContactEditPage : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,440>;

  $rect <760,60,960,100>
  inherited method UpdateViewState()
  {
    // Always give the ancestor class a chance to process this event.
    super( aState );

    if(Contact)
    {

    if (Contact.FirstName != FirstNameTxt.String ||
        Contact.LastName != LastNameTxt.String ||
        Contact.PhoneNumber !=  NumberTxt.String)
    {
      SaveBtn.Enabled = true;
    }

    else
     SaveBtn.Enabled = false;
     }
     
  }

  $rect <310,50,510,90>
  slot onSave
  {
    Contact.FirstName    = FirstNameTxt.String; 
    Contact.LastName     = LastNameTxt.String;
    Contact.PhoneNumber  = NumberTxt.String;
    Contact.NameInitials = Application::MyContacts.GetInitials( Contact.LastName, Contact.FirstName);

    signal OnSave;
  }

  $rect <520,50,720,90>
  property slot OnSave;

  $rect <310,91,510,131>
  slot onClose
  {
    signal OnClose;
  }

  $rect <520,91,720,131>
  property slot OnClose;

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,740,190>;
  }

  $rect <310,140,510,180>
  slot onDeleteContact
  {
    Application::MyContacts.Remove( Contact );
    signal OnDelete;
  }

  $rect <310,290,510,330>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <310,330,510,370>
  slot onContactUpdated
  {
    if ( Contact != null )
    {
      FirstNameTxt.String = Contact.FirstName;
      LastNameTxt.String  = Contact.LastName;
      NumberTxt.String    = Contact.PhoneNumber;  
      UserInitials.Initials  = Contact.NameInitials;
    }

  }

  $rect <310,250,510,290>
  property Application::Contact Contact;

  $rect <520,140,720,180>
  property slot OnDelete;

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,200,740,390>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Application::PushButtonDelete DeleteBtn
  {
    preset Bounds = <5,398,263,431>;
    preset Enabled = true;
    preset OnActivate = onDeleteContact;
    preset Label = "Delete contact";
  }

  $rect <20,20,160,60>
  object Application::InputEtxt NumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <7,244,265,273>;
    preset OnChange = onFieldModified;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0749320267";
    preset Color = Res::Blue;
    preset Font = Res::ContactFont15;
    preset Placeholder = "0749320267";
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <264,239>;
    preset Point1 = <6,239>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text MobileTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <6,207,264,240>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = " mobile";
    preset Font = Res::ContactFont15;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <263,206>;
    preset Point1 = <5,206>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt FirstNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <2,174,268,206>;
    preset OnChange = onFieldModified;
    preset String = "First name";
    preset Color = Res::Black;
    preset Placeholder = "First name";
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <263,173>;
    preset Point1 = <5,173>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt LastNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <2,141,268,173>;
    preset OnChange = onFieldModified;
    preset String = "Last name";
    preset Color = Res::Black;
    preset Placeholder = "Last name";
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <263,140>;
    preset Point1 = <5,140>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitials
  {
    preset Bounds = <99,29,169,120>;
    preset Initials = "";
    preset Descript = "Add Photo";
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground CloseBtn
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onClose;
    preset Label = Res::CloseIconTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonNoBackground SaveBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Enabled = false;
    preset OnActivate = onSave;
    preset Label = Res::CkeckIconTxt;
  }

  $rect <530,330,730,370>
  slot onFieldModified
  {
    UserInitials.Initials = Application::MyContacts.GetInitials( LastNameTxt.String, FirstNameTxt.String );
    InvalidateViewState();
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,0,970,140>;
  }
}

$rect <40,470,200,510>
$output false
class Contact
{
  $rect <0,60,200,100>
  property string FirstName;

  $rect <0,10,200,50>
  var Application::Contact next;

  $rect <0,100,200,140>
  property string LastName;

  $rect <20,290,220,330>
  method void TraceContact()
  {
    trace FirstName + " " + LastName;
  }

  $rect <0,140,200,180>
  property string PhoneNumber;

  $rect <200,60,400,100>
  onset FirstName
  {
    // The value doesn't change - nothing to do.
    if ( pure FirstName == value )
      return;

    // Remember the property's new value.
    pure FirstName = value;

    notifyobservers this;
  }

  $rect <200,100,400,140>
  onset LastName
  {
    // The value doesn't change - nothing to do.
    if ( pure LastName == value )
      return;

    // Remember the property's new value.
    pure LastName = value;

    notifyobservers this;
  }

  $rect <200,140,400,180>
  onset PhoneNumber
  {
    // The value doesn't change - nothing to do.
    if ( pure PhoneNumber == value )
      return;

    // Remember the property's new value.
    pure PhoneNumber = value;

    notifyobservers this;
  }

  $rect <0,180,200,220>
  property string NameInitials;

  $rect <200,180,400,220>
  onset NameInitials
  {
    // The value doesn't change - nothing to do.
    if ( pure NameInitials == value )
      return;

    // Remember the property's new value.
    pure NameInitials = value;

    notifyobservers this;
  }
}

$rect <10,430,200,470>
$output false
class Contacts
{
  $rect <0,0,200,40>
  var Application::Contact head = null;

  $rect <0,50,200,90>
  method void Add( arg Application::Contact aContact )
  {
    if ( head ==  null )
      head = aContact;

    else
    {
     var Application::Contact lastNode   = head;
     while ( lastNode.next != null )
     {
      lastNode = lastNode.next;
      }
      lastNode.next = aContact;
    }

    NoOfItems +=1;

  }

  $rect <0,90,200,130>
  method void Remove( arg Application::Contact aContact )
  {
    var Application::Contact contact = head;
    var Application::Contact prev = null;

    if (( contact != null) && ( contact == aContact ))
    {
      head = contact.next;
      NoOfItems -= 1;
    }
     
    else
    {
      while ((contact != null) && (contact != aContact))
      {
        prev = contact;
        contact = contact.next;
       }
       prev.next = contact.next;
       NoOfItems -= 1;
    }
  }

  $rect <0,210,200,250>
  method void TraceContacts()
  {
    var Application::Contact contact = head;

    while ( contact != null )
    {
      contact.TraceContact();
      contact = contact.next;
    }

  }

  $rect <430,0,630,40>
  property int32 NoOfItems = 0;

  $rect <430,40,630,80>
  onset NoOfItems
  {
    // The value doesn't change - nothing to do.
    if ( pure NoOfItems == value )
      return;

    // Remember the property's new value.
    pure NoOfItems = value;

    notifyobservers ^NoOfItems;

  }

  $rect <790,40,990,80>
  property string Filter;

  $rect <790,80,990,120>
  onset Filter
  {
    // The value doesn't change - nothing to do.
    if ( pure Filter == value )
      return;

    // Remember the property's new value.
    pure Filter = value;

    // TO DO:
    // 
    // Now you can handle the alternation of the property.
  }

  $rect <790,120,990,160>
  onget Filter
  {
    return pure Filter;
  }

  $rect <790,160,990,200>
  method int32 loadFilteredContacts( arg int32 aArg1 )
  {
    /* The template just returns the given argument... */
    return aArg1;
  }

  $rect <790,200,990,240>
  var Application::Contacts filteredContacts = null;

  $rect <0,130,200,170>
  method Application::Contact GetContact( arg int32 aNo )
  {
    var Application::Contact contact = head;
    var int32 it = 0;
    while ( it != aNo)
    {
      contact = contact.next;
      it +=1;
        
    }

    return contact;

  }

  // TO DO LATER
  note group Note
  {
    attr Bounds = <730,0,1030,300>;
  }

  $rect <0,170,200,210>
  method string GetInitials( arg string aLastName, arg string aFirstName )
  {
     return aLastName[0] + "" + aFirstName[0];
  }

  $rect <220,80,420,120>
  method void insertionSort()
  {
    var Application::Contact current = head;

    while ( current != null )
    {
      //store the currents next for next iteration 
      var Application::Contact next = current.next;
      //insert cuurent in sorted liked list
      sortedInsert ( current );

      //update current 
      current = next;
    }

    head = sorted;
    sorted = null;
  }

  $rect <220,40,420,80>
  method void sortedInsert( arg Application::Contact aContact )
  {
    if ((sorted == null) || 
        ((Sorting == Application::Sorting.Ascending)  && (sorted.LastName >= aContact.LastName )) ||
        ((Sorting == Application::Sorting.Descending) && (sorted.LastName <= aContact.LastName)))
    {
      aContact.next = sorted;
      sorted = aContact;
    }

    else
    {
      var Application::Contact current = sorted;

      
     while (( current.next != null) &&
              (((Sorting == Application::Sorting.Ascending) && (current.next.LastName < aContact.LastName)) ||
              ((Sorting == Application::Sorting.Descending) && (current.next.LastName > aContact.LastName))))
      {
        current = current.next;
      }
      aContact.next = current.next;
      current.next  = aContact;
    }


  }

  $rect <220,0,420,40>
  var Application::Contact sorted = null;

  $rect <440,120,640,160>
  property Application::Sorting Sorting = Application::Sorting.Ascending;

  $rect <440,160,640,200>
  onset Sorting
  {
    // The value doesn't change - nothing to do.
    if ( pure Sorting == value )
      return;

    // Remember the property's new value.
    pure Sorting = value;

    insertionSort();
    notifyobservers ^Sorting;
  }
}

// Data
note group Note2
{
  attr Bounds = <0,380,410,580>;
}

$rect <20,530,180,570>
$output false
autoobject Application::Contacts MyContacts;

$rect <210,430,400,470>
$variant $SimulateData
vclass VariantContacts : Application::Contacts
{
  $rect <10,10,160,50>
  inherited method Init()
  {
    CreateContactData( );
  }

  $rect <10,90,210,130>
  method void CreateContact( arg string aLastName, arg string aFirstName, arg string aPhoneNumber )
  {
    var Application::Contact MyContact = new Application::Contact;


    MyContact.FirstName = aFirstName;
    MyContact.LastName = aLastName;
    MyContact.PhoneNumber = aPhoneNumber;
    Add( MyContact );

  }

  $rect <10,50,210,90>
  method void CreateContactData()
  {
    CreateContact( "Buna", "Zsolt", "sfdg");
    CreateContact( "Benedek", "Norbert", "sfg");
    CreateContact( "Amota", "Adel", "zf");
    CreateContact( "Bacso", "Amalia", "sfd");
     insertionSort();

    //var int32 i =0;

    //for ( i=0; i<100; i++ )
    //{
    //  CreateContact( "Name" + (string)i, "LastName" + (string)i, "0722" + (string)i );
    //}


  }
}

// This component implements an editor.
$rect <640,90,830,130>
$output false
class InputEtxt : Templates::TextEditor
{
  $rect <670,620,870,660>
  inherited property Bounds = <0,0,266,32>;

  $rect <680,280,880,320>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited version of the method
    super( aState );

    // Activate the caret blinking if the editor component has the input focus
    if ( aState.contains( Core::ViewState[ Focused ]))
    {
      blinkEffect.Enabled = true;
    }
    // ... otherwise hide the caret
    else
    {
      blinkEffect.Enabled = false;
      Caret.Visible       = false;
    }

  }

  // To do:
  // 
  // - Adjust the visible size of the text editor (the thick blue border). This will \
  // be the editor's default size.
  // - Resize and arrange the member 'Text' so it covers the area where you intend \
  // to display the text. This is usually the entire area.
  // - Adjust the position and the size of the 'SimpleTouchHandler' and 'SlideTouchHandler', \
  // so they cover the 'Text' view.
  // - If your design it expects, add and configure more views in the component, \
  // e.g. views to display background, borders, etc.
  // - The editor implements several handler to process keyboard inputs. See the \
  // annotation 'Keyboard events'. Feel free to add more handler for other key events \
  // or remove the handler you don't need in your version.
  // - The editor displays a magnifying glass when the user touches and holds the \
  // finger for a while (see the method 'onHoldTouch'). If you don't want it, remove \
  // the contents within the annotation 'Magnifying glass' and the slot method 'onHoldTouch'.
  // - The editor reacts to touch interactions. See the annotation 'Touch screen \
  // events'. If your device is not touch driven, you can remove the both handlers \
  // 'SimpleTouchHandler', 'SlideTouchHandler' and the methods from the annotation \
  // 'Touch screen events'.
  // - Adapt the implementation of the 'UpdateViewState()' method. This method should \
  // update your views so they reflect the editor's current state (e.g. focused editor \
  // may appear with other colors, etc.)
  // - The editor is implemented with various properties allowing the configuration \
  // of the text (e.g. 'Font', 'Color', ...). If your version of the editor doesn't \
  // need such configuration, remove the properties and the associated OnSet methods.
  // - If you need other properties to configure the editor, add from the Gallery \
  // folder 'Chora' new properties. One property for every new setting (e.g. 'BorderWidth', \
  // etc.)
  // - Rename the properties accordingly their usage and remove their 'OnGet...' \
  // methods.
  // - For every newly added property adapt their 'OnSet...' method implementation. \
  // Ensure in the method that the assigned value is correctly passed to the corresponding \
  // view (e.g. a property 'BorderWidth' should update the eventually used 'Border' \
  // view, etc.).
  // - Feel free to modify any other member in this component accordingly your needs. \
  // Please note the member description and inline comments within methods.
  note legend Note6
  {
    attr Bounds = <10,690,990,1150>;
  }

  // Magnifying glass
  note group Note5
  {
    attr Bounds = <440,500,660,670>;
  }

  // Caret
  note group Note4
  {
    attr Bounds = <10,500,430,670>;
  }

  // State management
  note group Note3
  {
    attr Bounds = <670,240,890,330>;
  }

  // Touch screen events
  note group Note2
  {
    attr Bounds = <440,240,660,450>;
  }

  // Keyboard events
  note group Note1
  {
    attr Bounds = <10,240,430,490>;
  }

  // This internal variable refers to a temporary Views::Image object used to show \
  // the background for the augmented text content around the caret. This view appears \
  // during the user is moving this caret by touching the caret with the finger.
  $rect <450,620,650,660>
  var Views::Rectangle magnifyingBack = null;

  // This internal variable refers to a temporary Views::WarpGroup object used to \
  // show the augmented text content around the caret. This view appears during the \
  // user is moving this caret by touching the caret with the finger.
  $rect <450,580,650,620>
  var Views::WarpGroup magnifyingView = null;

  // This flag is set if it is evtl. necessary to scroll the editor content in order \
  // to ensure that the caret is still visible.
  $rect <220,620,420,660>
  var bool autoScroll;

  // This internal variable stores the current caret index. This is the position \
  // within Text.String property where the user can input text or delete signs.
  $rect <20,620,220,660>
  var int32 caretIndex = 0;

  // This slot method is called after the caret has been adjusted. Its job is to \
  // adjust too the position of the magnifying glass view where the augmented text \
  // content around the caret is shown.
  $rect <450,540,650,580>
  slot updateMagnifyingView
  {
    // There is actually no magnifying glass displayed. Nothing to do.
    if ( magnifyingView == null )
      return;

    var rect  srcArea = magnifyingView.SourceArea;
    var rect  extent  = magnifyingView.GetExtent();
    var rect  bounds  = Bounds;
    var point caret   = Caret.Point1;

    // Calculate the start position of the area to show in the magnifying
    // view. Preferably the caret should appear in the center of this area.
    var int32 srcX = caret.x - ( srcArea.w / 2 );

    // However, the part of magnifying glass displaying the caret should 
    // remain arranged horizontally within the editor area.
    if ( srcX < 0 )
      srcX = 0;

    if (( srcX + srcArea.w ) > bounds.w )
      srcX = bounds.w - srcArea.w;

    // The resulting start position of the area to augment
    magnifyingView.SourceArea.origin = point( srcX, caret.y );

    // Now calculate the position for the magnifyingView. Preferably the
    // the view should be arranged so it shows the augmented caret 
    // exactly above the origin caret
    var int32 dstX = ( bounds.x1 + caret.x ) - ( caret.x - srcX ) * 2;

    // From the new magnifyingView position and its current position calculate
    // an offset.
    var point ofs = point( dstX - extent.x1, bounds.y1 + caret.y - extent.y2 );

    // Move the magnifyingView and its background by the just calculated offset
    magnifyingView.MoveView( ofs, false );
    magnifyingBack.MoveView( ofs, false );
  }

  // This slot method is called after a short delay when the user has moved the caret \
  // or modified the text. Its job is to ensure that the caret is still visible. \
  // If necessary, the editor content is scrolled.
  $rect <220,540,420,580>
  slot updateScrollOffset
  {
    // Get the visible area of the text view
    var rect  bounds = Text.Bounds;
    var int32 ofsX   = 0;
    var int32 ofsY   = 0;

    // Calculate an offset to scroll the text content if the caret lies
    // outside the visible area
    if ( Caret.Point1.x < bounds.x1 ) ofsX = bounds.x1 - Caret.Point1.x;
    if ( Caret.Point1.x > bounds.x2 ) ofsX = bounds.x2 - Caret.Point1.x;
    if ( Caret.Point1.y < bounds.y1 ) ofsY = bounds.y1 - Caret.Point1.y;
    if ( Caret.Point2.y > bounds.y2 ) ofsY = bounds.y2 - Caret.Point2.y;

    // Should the cont be scrolled?
    if (( ofsX != 0 ) || ( ofsY != 0 ))
      Text.ScrollOffset = Text.ScrollOffset + point( ofsX, ofsY );

    // The following code takes care of the automatic adjustment of the
    // text scroll position if after modifying the text, its area is small
    // enough to be completely visible.
    ofsX = Text.ScrollOffset.x;
    ofsY = Text.ScrollOffset.y;

    // Get the current text area of the 
    var point size = Text.GetContentArea().size;

    // Does the area fit completely within the text editor?
    if ( size.x <= Text.Bounds.w ) ofsX = 0;
    if ( size.y <= Text.Bounds.h ) ofsY = 0;

    // If possible arrange the text so it fits within the text editor.
    Text.ScrollOffset = point( ofsX, ofsY );
  }

  // This slot method is attached to the Text view. Each time the Text view has rearranged \
  // the text, this method is called. Its job is to adjust the caret to the evtl. \
  // new position.
  $rect <20,540,220,580>
  slot updateCaret
  {
    // Without the font we don't know the height of the caret
    if ( Font == null )
      return;

    // Get the pixel position of the sign right to the caret
    var point rowCol = Text.StringIndex2RowCol( caretIndex );
    var point pos    = Text.RowCol2Position( rowCol );

    // Arrange the caret at the just determined position. The height of 
    // the caret corresponds to the height of a text row drawn with the
    // font
    Caret.Point1 = pos - point( 0, Font.Ascent  );
    Caret.Point2 = pos + point( 0, Font.Descent );

    // Restart the blink effect -> this ensures that the user can see the
    // caret while it is moved or the text is modified
    if ( blinkEffect.Enabled )
    {
      blinkEffect.Enabled = false;
      blinkEffect.Enabled = true;
    }

    // Should adjust the scroll position so that the caret remains in the visible
    // area? Finally clear the 'autoScroll' flag again.
    if ( autoScroll )
    {
      postsignal updateScrollOffset;
      autoScroll = false;
    }

    // If there is a magnifying glass view visible -> arrange it also to the
    // current caret position.
    if ( magnifyingView != null )
      postsignal updateMagnifyingView;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to hide the magnifying glass view again.
  $rect <450,400,650,440>
  slot onReleaseTouch
  {
    // Hide the views used temporarily to show the augmented editor content
    if ( magnifyingView != null )
    {
      Owner.Remove( magnifyingView );
      Owner.Remove( magnifyingBack );
      magnifyingView = null;
      magnifyingBack = null;

      // Free the temporary used off-screen memory
      Buffered = false;
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to move the caret accordingly to the user's finger movement.
  $rect <450,360,650,400>
  slot onDragTouch
  {
    // Does the user currently drag the caret?
    if ( magnifyingView != null )
    {
      // From the touched screen position estimate the corresponding position
      // within the text string.
      var point  rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
      var int32  newCaretIndex = Text.RowCol2StringIndex( rc );

      // Does the caret position change? Force the editor to update the
      // position of the blinking caret
      if ( newCaretIndex != caretIndex )
      {
        caretIndex = newCaretIndex;
        postsignal updateCaret;

        // Ensure the caret is still visible later in the updateText slot method
        autoScroll = true;
      }
    }

    // No, then redirect the touch interaction to the slide touch handler when the
    // user moved the finger a little bit. In this manner the user can scroll the text.
    else
    {
      var point ofs   = SimpleTouchHandler.CurrentPos - SimpleTouchHandler.HittingPos;
      var int32 limit = GetRoot().CursorDragLimit;

      // Start the slide mode if the user has dragged the finger a little bit
      if (( ofs.x < -limit ) || ( ofs.x > limit ) ||
          ( ofs.y < -limit ) || ( ofs.y > limit ))
        GetRoot().DeflectCursor( SlideTouchHandler, <0,0>);
    }
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to activate the caret movement mode if the user has pressed the finger on the \
  // screen for a while. The method also shows a small magnifying glass where the \
  // text around the caret is shown. This should help the user to navigate the caret \
  // with the finger.
  $rect <450,320,650,360>
  slot onHoldTouch
  {
    // When the user presses the finger within the text editor area,
    // the editor enters the caret dragging mode. In this mode the
    // user can move the caret with the finger. For convenience the
    // area below the finger is displayed in a kind of magnifying glass.
    // Does enter the mode?
    if (( SimpleTouchHandler.HoldPeriod >= 300 ) && ( magnifyingView == null ))
    {
      // Calculate the size of the area to augment
      var int32 height = Caret.Point2.y - Caret.Point1.y;
      var int32 width  = height * 3;

      // Limit to the available size of the editor component
      if ( height > Bounds.h ) height = Bounds.h;
      if ( width  > Bounds.w ) width  = Bounds.w;

      // The editor component should store its content in an off-screen bitmap
      // in order to be able to to show it augmented in an overlay 'magnifyingView'
      Buffered = true;

      // Create a temporary view to show the augmented content and to show the
      // 'magnifying glass' background
      magnifyingView = new Views::WarpGroup;
      magnifyingBack = new Views::Rectangle;

      // Prepare a magnifyingView to show an augmented content of the edited text
      // row. The content is augmented by the factor x 2
      magnifyingView.Group       = this;
      magnifyingView.Quality     = true;
      magnifyingView.Opacity     = 200;
      magnifyingView.SourceArea  = rect( 0, 0, width, height );
      magnifyingView.Point2.x    = width  * 2;
      magnifyingView.Point3.x    = width  * 2;
      magnifyingView.Point3.y    = height * 2;
      magnifyingView.Point4.y    = height * 2;

      // Also prepare the magnifying glass background view. It is a semitransparent
      // rectangle.
      magnifyingBack.Bounds.size   = point( width * 2, height * 2 ) + <20,20>;
      magnifyingBack.Bounds.origin = <-10,-10>;
      magnifyingBack.Color         = #EEEEEECC;

      // Make the just created views visible on the screen
      Owner.Add( magnifyingBack, 0 );
      Owner.Add( magnifyingView, 0 );

      // Arrange the 'magnifying glass' views at the correct position
      postsignal updateMagnifyingView;
    }

    // Even if the user is not moving the cursor (finger) continue the scrolling when
    // the user holds the finger near an edge of the text editor.
    if ( magnifyingView != null )
      signal onDragTouch;
  }

  // This method is called from the corresponding SimpleTouchHandler. Its job is \
  // to obtain the focused state for the editor so the user can interact with the \
  // editor content and to place the caret at the touched position.
  $rect <450,280,650,320>
  slot onPressTouch
  {
    // With the first touch focus the text editor
    if ( !HasViewState( Core::ViewState[ Focused ]))
     {
      ObtainFocus();
     }
    // Estimate the position within the text string corresponding to the
    // position touched on the screen.
    var point rc            = Text.Position2RowCol( SimpleTouchHandler.CurrentPos );
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the text editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // move the caret up/down/left or right in the editor text.
  $rect <220,440,420,480>
  slot onCursorKey
  {
    // No font specified to show the text -> no navigation
    // possible
    if ( Font == null )
      return;

    // Knowing the position of the caret within the string, get the
    // corresponding row/column position in the displayed text.
    var point rc = Text.StringIndex2RowCol( caretIndex );

    // Has the user moved the caret to the left? Get the new resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Left )
    {
      // Navigate to the previous column
      rc.x = rc.x - 1;

      // The begin of the row reached? Skip to the end of the preceding row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y - 1;
        rc.x = Text.GetRowString( rc.y ).length;
      }
    }

    // Has the user moved the caret to the right? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Right )
    {
      // Navigate to the next column
      rc.x = rc.x + 1;

      // The end of the current row reached? Skip to the begin of the next
      // following row.
      if ( Text.RowCol2StringIndex( rc ) == caretIndex )
      {
        rc.y = rc.y + 1;
        rc.x = 0;
      }
    }

    // Has the user moved the caret one row up? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Up )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just above
      rc = Text.Position2RowCol( pos - point( 0, rowHeight ));
    }

    // Has the user moved the caret one row down? Get the resulting
    // row/column number
    if ( CursorKeyHandler.Code == Core::KeyCode.Down )
    {
      // Get the pixel position where the sign at actual caret position
      // is displayed
      var point pos       = Text.RowCol2Position( rc );
      var int32 rowHeight = Font.Ascent + Font.Descent + Font.Leading;

      // Get the row/column corresponding to the sign in the row just below
      rc = Text.Position2RowCol( pos + point( 0, rowHeight ));
    }

    // From the just determined new row/column position get the corresponding
    // position within the text string
    var int32 newCaretIndex = Text.RowCol2StringIndex( rc );

    // Does the caret position change? Force the editor to update the
    // position of the blinking caret
    if ( newCaretIndex != caretIndex )
    {
      caretIndex = newCaretIndex;
      postsignal updateCaret;

      // Ensure the caret is still visible later in the updateText slot method
      autoScroll = true;
    }
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign preceding the current caret position and to move the caret accordingly.
  $rect <220,400,420,440>
  slot onBackspaceKey
  {
    // No signs preceding the caret -> Nothing to delete
    if ( caretIndex == 0 )
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex - 1 ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '%' ))
      count = 2;

    // Remove the affected text portion and adjust the caret position
    Text.String = Text.String.remove( caretIndex - count, count );
    caretIndex  = caretIndex - count;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal onChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // delete the sign at the current caret position.
  $rect <220,360,420,400>
  slot onDeleteKey
  {
    // No signs following the caret -> Nothing to delete
    if ( caretIndex >= ( Text.String.length - 1 ))
      return;

    // Get the sign which should be deleted from the text.
    var char  ch    = Text.String[ caretIndex ];
    var int32 count = 1;

    // The sign was a special control sign? In this case the sign comes
    // together with the preceding '%' escape sign - otherwise the user
    // couldn't see the sign
    if ( ch == '%' )
      count = 2;

    // Remove the affected text fragment
    Text.String = Text.String.remove( caretIndex, count );

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal onChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the <new line> sign and to move the caret \
  // to the next row.
  $rect <220,320,420,360>
  slot onNewlineKey
  {
    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( '\n', caretIndex );
    caretIndex  = caretIndex + 1;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal onChange;
  }

  // This method is called from the corresponding keyboard handler. Its job is to \
  // insert at the current caret position the sign which has been input by the user \
  // and to move the caret to the next column.
  $rect <220,280,420,320>
  slot onCharacterKey
  {
    var char   ch  = CharacterKeyHandler.CharCode;
    var string str = ch;

    // Precede all special control signs with the '%' escape sign. Otherwise
    // the user can't input nor see them
    if (( ch == '^' ) || ( ch == '~' ) || ( ch == '\xAD' ) || ( ch == '%' ))
      str = "%" + ch;

    // Take over the just input sign and adjust the caret position
    Text.String = Text.String.insert( str, caretIndex );
    caretIndex  = caretIndex + str.length;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll = true;

    // Inform the owner of this text editor component, that the text has been
    // modified by the user
    postsignal onChange;
  }

  $rect <480,170,680,210>
  onset WrapText
  {
    // The value doesn't change - nothing to do.
    if ( pure WrapText == value )
      return;

    // Remember the new value ...
    pure WrapText = value;
    Text.WrapText = value;

    // If the text is warp automatically in rows, there is no need to
    // scroll the text horizontally.
    SlideTouchHandler.SlideHorz = !value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <280,170,480,210>
  onset Alignment
  {
    // The value doesn't change - nothing to do.
    if ( pure Alignment == value )
      return;

    // Remember the new value ...
    pure Alignment = value;
    Text.Alignment = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  $rect <690,80,890,120>
  onget String
  {
    // Get the current text view content
    var string str = Text.String;

    // In the following steps remove any special text view control signs
    // which are usually used to control the text flow. The resulting string
    // should contain the 'pure' text only.
    var int32 inx = str.find( '%', 0 );

    // The special control/escape signs are not visible until there is a
    // '%' sign in front of them. Remove all superfluous '%' signs
    while ( inx >= 0 )
    {
      str = str.remove( inx, 1 );
      inx = str.find( '%', inx + 1 );
    }

    // Finally remove the <new line> sign at the end of text which was used
    // as workaround for a text flow parser issue
    return str.left( str.length - 1 );
  }

  $rect <690,40,890,80>
  onset String
  {
    // The value doesn't change - nothing to do.
    if ( pure String == value )
      return;

    // Remember the new string ...
    pure String = value;

    // In the following steps disarm in the assigned Unicode string the special
    // control and escape signs, which usually control the text flow in a  text
    // view. Without this conversion step, signs like '%' couldn't be seen in
    // the editor.
    var string str = value;
    var int32  inx = str.find( '%', 0 );

    // The special '%' escape sign is not visible until there is other
    // '%' sign in front of it. Convert all '%' signs into '%%' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '%', inx + 2 );
    }

    inx = str.find( '^', 0 );

    // The special '^' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '^' signs into '%^' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '^', inx + 2 );
    }

    inx = str.find( '~', 0 );

    // The special '~' control sign is not visible until there is a '%'
    // sign in front of it. Convert all '~' signs into '%~' sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '~', inx + 2 );
    }

    inx = str.find( '\xAD', 0 );

    // The special '\xAD' hyphen sign is not visible until there is a '%'
    // sign in front of it. Convert all '\xAD' hyphen signs into '%\xAD'
    // sequences
    while ( inx >= 0 )
    {
      str = str.insert( "%", inx );
      inx = str.find( '\xAD', inx + 2 );
    }

    // Ensure that the caret still refers to a sign within the string
    if ( caretIndex > str.length )
      caretIndex = str.length;

    // Now show the new string in the editor's text view. The additional
    // <new line> is a workaround for a flow text parser issue
    Text.String = str + "\n";

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;

    postsignal updatePlaceholder;
  }

  $rect <490,40,690,80>
  onset Color
  {
    // The value doesn't change - nothing to do.
    if ( pure Color == value )
      return;

    // Store the new Color
    pure Color  = value;
    Text.Color  = value;
    Caret.Color = value;

  }

  $rect <290,40,490,80>
  onset Font
  {
    // The value doesn't change - nothing to do.
    if ( pure Font == value )
      return;

    // Store the new font...
    pure Font = value;
    Text.Font = value;

    // Ensure the caret is still visible later in the updateText slot method
    autoScroll        = true;
    Text.ScrollOffset = <0,0>;
  }

  // This bool change effect is used to blink the caret.
  $rect <20,580,220,620>
  object Effects::BoolEffect blinkEffect
  {
    preset Value2 = false;
    preset Value1 = true;
    preset Outlet = ^Caret.Visible;
    preset CycleDuration = 500;
    preset InterCycleDelay = 500;
  }

  // The property 'OnChange' can refer to a slot method, which should be invoked \
  // by the text editor when the user modifies the text.
  $rect <690,120,890,160>
  property slot OnChange = null;

  // The property 'WrapText' determines whether long text rows should be wrapped \
  // automatically.
  $rect <490,120,690,160>
  property bool WrapText = true;

  // The property 'Alignment' determines how the editor should display the text rows \
  // if their size differ from the size of the editor. 
  // In this manner the rows can be aligned horizontally. The entire text block can \
  // be aligned vertically.
  $rect <290,120,490,160>
  property Views::TextAlignment Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];

  // The property 'String' stores the text of the editor.
  $rect <690,0,890,40>
  property string String = "Text";

  // The property 'Color' controls the color of the text.
  $rect <490,0,690,40>
  property color Color = #000000FF;

  // The property 'Font' refers to the font object used to display the text. The \
  // text is determined by the property @String.
  $rect <290,0,490,40>
  property Resources::Font Font = Resources::FontMedium;

  // This key handler reacts to user inputs if the user has pressed the 'up', 'down', \
  // 'left' or 'right' key. In this case the associated onCursorKey method is called.
  $rect <20,440,220,480>
  object Core::KeyPressHandler CursorKeyHandler
  {
    preset OnPress = onCursorKey;
    preset Filter = Core::KeyCode.CursorKeys;
    preset OnHold = onCursorKey;
  }

  // This key handler reacts to user inputs if the user has pressed the 'backspace' \
  // key. In this case the associated onBackspaceKey method is called.
  $rect <20,400,220,440>
  object Core::KeyPressHandler BackspaceKeyHandler
  {
    preset OnPress = onBackspaceKey;
    preset Filter = Core::KeyCode.Backspace;
    preset OnHold = onBackspaceKey;
  }

  $rect <890,40,1090,80>
  onset Placeholder
  {
    // The value doesn't change - nothing to do.
    if ( pure Placeholder == value )
      return;

    // Remember the new string ...
    pure Placeholder = value;

    TextPlaceholder.String = pure Placeholder;

    postsignal updatePlaceholder;
  }

  // The property 'String' stores the text of the editor.
  $rect <890,0,1090,40>
  property string Placeholder = "Insert Text here";

  // This key handler reacts to user inputs if the user has pressed the 'delete' \
  // key. In this case the associated onDeleteKey method is called.
  $rect <20,360,220,400>
  object Core::KeyPressHandler DeleteKeyHandler
  {
    preset OnPress = onDeleteKey;
    preset Filter = Core::KeyCode.Delete;
    preset OnHold = onDeleteKey;
  }

  $rect <690,160,890,200>
  slot onChange
  {
    signal OnChange;

    postsignal updatePlaceholder;
  }

  $rect <890,160,1090,200>
  slot updatePlaceholder
  {
    //TextPlaceholder.Visible = ( String == "Text\n" );
    if( String == "Text\n" || String == "" )
      TextPlaceholder.Visible = true;
    else
      TextPlaceholder.Visible = false;
  }

  // This key handler reacts to user inputs if the user has pressed the 'enter' key. \
  // In this case the associated onNewlineKey method is called.
  $rect <20,320,220,360>
  object Core::KeyPressHandler NewlineKeyHandler
  {
    preset OnPress = onNewlineKey;
    preset Filter = Core::KeyCode.Enter;
    preset OnHold = onNewlineKey;
  }

  // This key handler reacts to user inputs if the user has pressed a key corresponding \
  // to character/digit. In this case the associated onCharacterKey method is called.
  $rect <20,280,220,320>
  object Core::KeyPressHandler CharacterKeyHandler
  {
    preset OnPress = onCharacterKey;
    preset Filter = Core::KeyCode.CharacterKeys;
    preset OnHold = onCharacterKey;
  }

  // This slide gesture handler is used to scroll the text content.
  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,32>;
    preset SlideHorz = false;
    preset Friction = 0.05;
  }

  // This generic touch handler is used to move the caret.
  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,32>;
    preset Point3 = <272,32>;
    preset Point2 = <272,0>;
    preset Point1 = <0,0>;
    preset OnDrag = onDragTouch;
    preset OnHold = onHoldTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset MaxStrikeCount = 3;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <13,2,272,32>;
    preset OnUpdate = updateCaret;
    preset SlideHandler = SlideTouchHandler;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Text\n";
    preset Font = Resources::FontSmall;
    preset Color = #1E1E1EFD;
  }

  $rect <20,20,160,60>
  object Views::Text TextPlaceholder
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <14,2,272,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Resources::FontSmall;
    preset Color = #B9B9B9FD;
  }

  $rect <20,20,160,60>
  object Views::Line Caret
  {
    preset Point2 = <0,29>;
    preset Point1 = <0,5>;
    preset Width2 = 2;
    preset Width1 = 2;
    preset Color = #000000FF;
    preset Visible = false;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,260,630,300>
$output false
class PushButtonDelete : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <6,436,264,469>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    // Update the parameters of the text view (label)
    if ( Text != null )
    {
      var color clr = Res::Red; 
      Text.Font      = Res::ContactFont15;
      Text.String = Label;
      Text.Color     = clr;
      }


    if ( !isEnabled )
    {
      Background.Color = Res::WhiteTransparent;
      Text.Color       = Res::Grey;  
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
      Text.Color       = Res::RedLight;
    }

    else if ( isSelected )
    {
      Background.Color = Res::WhiteTransparent;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = Res::WhiteTransparent;
    }



    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,258,33>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,33>;
    preset Point3 = <258,33>;
    preset Point2 = <258,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <260,10,450,50>
  property slot OnActivate = null;

  $rect <450,50,650,90>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Label = "";

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <12,0,258,33>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Delete contact";
    preset Font = Resources::FontSmall;
    preset Color = #FF295BFF;
  }
}

$rect <210,70,410,110>
$output false
class CallPage : Core::Group
{
  $rect <770,20,970,60>
  inherited method Init()
  {
    attachobserver onCallState, ^Application::Device.CallState;
    postsignal onCallState;


  }

  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,480>;
    preset ColorBL = #838383FA;
    preset ColorBR = #4F4F4FFF;
    preset ColorTR = #898989FF;
    preset ColorTL = #898989FF;
    preset Color = #3C3C3CFF;
  }

  $rect <310,90,500,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <310,130,500,170>
  slot onContactUpdated
  {
    if ( pure Contact != null )
    {
      ContactNameTxt.String  = pure Contact.LastName + " "  + pure Contact.FirstName;
      UserInitials.Initials = Application::MyContacts.GetInitials( pure Contact.LastName, pure Contact.FirstName);
      
    }

  }

  $rect <310,50,500,90>
  property Application::Contact Contact;

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,0,760,200>;
  }

  $rect <310,250,510,290>
  property slot OnEndCall;

  $rect <520,250,720,290>
  slot onEndCallPress
  {
    Application::Device.UpdateCallState( Application::CallState.None );

    postsignal onCallState;
  }

  $rect <530,530,730,570>
  slot onSpeakerPress
  {
    //if button is pressed it changes sate from start/stop and icon PlayIcon/StopIcon

    Application::Device.Speaker =!   Application::Device.Speaker;

    SpeakerBtn.ButtonColor = Application::Device.Speaker ? Res::White : Res::WhiteTransparent;
    SpeakerBtn.IconColor   = Application::Device.Speaker ? Res::Black : Res::White ;
  }

  $rect <530,490,730,530>
  slot onMicPress
  {
    //if button is pressed it changes sate from start/stop and icon PlayIcon/StopIcon

    Application::Device.Microphone = !   Application::Device.Microphone;

    MuteBtn.ButtonColor = Application::Device.Microphone ? Res::White : Res::WhiteTransparent;

    MuteBtn.IconColor = Application::Device.Microphone ? Res::Black : Res::White;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,760,640>;
  }

  $rect <520,390,720,430>
  slot onKeypadPress
  {
    Keypad1.Bounds.origin =< 0, 30>;




    //keypadPage = new Application::Keypad;

    Keypad1.OnHide = onHide;

    //SwitchToDialog( keypadPage, Res::FadeInOutCentered, null, null, null, null, null, null, null, null, null );


  }

  $rect <310,490,510,530>
  slot onAddCallPress
  {
    sender; /* the method is called from the sender object */
  }

  $rect <310,530,510,570>
  slot onVideoCallPress
  {
    sender; /* the method is called from the sender object */
  }

  $rect <520,300,710,340>
  slot onContactsPress
  {
    contactsPage = new Application::ContactsInsideCall;

    contactsPage.OnCancel = onCancel; 

    SwitchToDialog( contactsPage, Res::SlideUpCentered, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumRed EndCallBtn
  {
    preset Bounds = <104,378,169,446>;
    preset OnActivate = onEndCallPress;
    preset Label = Res::EndCallTxt;
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans ContactsBtn
  {
    preset Bounds = <182,240,247,332>;
    preset OnActivate = onContactsPress;
    preset Icon = Res::UserIconTxt;
    preset Descript = "contacts";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans VideoCallBtn
  {
    preset Bounds = <104,241,169,333>;
    preset OnActivate = onVideoCallPress;
    preset Icon = Res::VideoCallTxt;
    preset Descript = "VideoCall";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans AddCallBtn
  {
    preset Bounds = <26,242,91,334>;
    preset OnActivate = onAddCallPress;
    preset Icon = Res::PlusIconTxt;
    preset Descript = "add call";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans SpeakerBtn
  {
    preset Bounds = <182,147,247,239>;
    preset OnActivate = onSpeakerPress;
    preset Icon = Res::SpeakerTxt;
    preset Descript = "speaker";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans KeyPadBtn
  {
    preset Bounds = <104,148,169,240>;
    preset OnActivate = onKeypadPress;
    preset Icon = Res::KeypadTxt;
    preset Descript = "keypad";
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans MuteBtn
  {
    preset Bounds = <26,149,91,241>;
    preset OnActivate = onMicPress;
    preset Icon = Res::MicOffTxt;
    preset Descript = "mute";
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <8,57,81,87>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "calling...";
    preset Font = Res::ContactFont12;
    preset Color = #FAFAFAFF;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitials
  {
    preset Bounds = <182,27,252,118>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  object Views::Text ContactNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <8,27,174,57>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont25;
    preset Color = #FAFAFAFF;
  }

  $rect <310,300,510,340>
  var Application::ContactsInsideCall contactsPage = null;

  $rect <530,340,700,380>
  slot onCancel
  {
    DismissDialog( contactsPage, Res::SlideDownCentered, null, null, null, null, false);
  }

  $rect <320,390,520,430>
  var Application::Keypad keypadPage;

  $rect <540,430,710,470>
  slot onHide
  {
    //DismissDialog( keypadPage, Res::FadeInOutCentered, null, null, null, null, null );
     // Move the keyboard below the bottom screen edge
    Keypad1.Bounds.origin.y = Bounds.y2;

  }

  $rect <20,20,160,60>
  object Application::KeypadInsideCall Keypad1
  {
    preset Bounds = <0,518,272,958>;
    preset HideFunction = false;
    preset HideCall = true;
    preset OnEditTextChanged = onKeypadEdit;
  }

  $rect <720,390,920,430>
  slot onKeypadEdit
  {
    ContactNameTxt.Visible = Keypad1.InputEtxt.String == "";
    TimeTxt.Visible = Keypad1.InputEtxt.String == "";
    UserInitials.Visible = Keypad1.InputEtxt.String == "";
  }

  $rect <760,60,960,100>
  slot onCallState
  {
    trace Application::Device.CallState, Application::Device.CallingNumber;

    if ( Application::Device.CallState == Application::CallState.None)
    {
      DismissDialog( this, null, null, null, null, null, false);
    } 
    else if ( Application::Device.CallState == Application::CallState.RingOutgoing)
    {
     AddCallBtn.Enabled =  false;
     VideoCallBtn.Enabled = false;

    }
    else if ( Application::Device.CallState == Application::CallState.Talk)
    {
     AddCallBtn.Enabled =  true;
     VideoCallBtn.Enabled = true;
    }


  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <430,130,630,170>
$output false
class PushButtonMediumTrans : Templates::PushButton
{
  $rect <490,380,690,420>
  inherited property Bounds = <0,0,65,92>;

  $rect <720,260,920,300>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    // Update the parameters of the text view (label)
    if ( IconTxt != null )
    {
       var color clr = IconColor; 
      IconTxt.Font      = Res::IconsFont25;
      IconTxt.String = Icon;
      IconTxt.Color     = clr;
      }

    // Update the parameters of the text view (label)
    if ( DescripTxt != null )
    {
       var color clr = DescriptColor; 
      DescripTxt.Font      = Res::ContactFont12;
      DescripTxt.String = Descript;
      DescripTxt.Color     = clr;
      }

    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
     
    }

    else if ( isPressed )
    {
      Background.Color = ButtonColorPressed;
    }

    else if ( isSelected )
    {
      Background.Color = ButtonColor;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }




    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <710,220,930,470>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <480,220,700,350>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <250,220,470,350>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <20,220,240,390>;
  }

  // This variable stores the current state of the button.
  $rect <720,380,920,420>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <720,340,920,380>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <720,300,920,340>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <490,260,690,300>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <260,260,460,300>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <490,300,690,340>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <260,300,460,340>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <30,340,230,380>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <30,300,230,340>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <30,260,230,300>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,65>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,65>;
    preset Point3 = <65,65>;
    preset Point2 = <65,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <90,0,290,40>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <0,0,65,65>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <290,40,490,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <290,0,490,40>
  property string Icon = "";

  $rect <720,420,920,460>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,65,65,92>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Res::ContactFont12;
  }

  $rect <710,0,910,40>
  property string Descript = "";

  $rect <710,40,910,80>
  onset Descript
  {
    // The value doesn't change - nothing to do.
    if ( pure Descript == value )
      return;

    // Remember the property's new value.
    pure Descript = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <500,0,700,40>
  property color ButtonColor = Res::WhiteTransparent;

  $rect <500,40,700,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <280,90,480,130>
  property color IconColor = Res::White;

  $rect <280,130,480,170>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <490,90,700,130>
  property color ButtonColorPressed = Res::WhiteSemiTransparent;

  $rect <490,130,700,170>
  onset ButtonColorPressed
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColorPressed == value )
      return;

    // Remember the property's new value.
    pure ButtonColorPressed = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <710,90,910,130>
  property color DescriptColor = Res::White;

  $rect <710,130,910,170>
  onset DescriptColor
  {
    // The value doesn't change - nothing to do.
    if ( pure DescriptColor == value )
      return;

    // Remember the property's new value.
    pure DescriptColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <640,130,840,170>
$output false
class PushButtonMediumRed : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,65,65>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    /*

      TO DO:

      Depending on your button design, you have surely added some new views
      to your button. In the below code you should update the properties of
      these views. For example, when your button has two images to appear
      exclusively for released and pressed button state, following can be
      done:

        imagePressed.Visible  =  isPressed;
        imageReleased.Visible = !isPressed;

      Depending on the state of the button, you can alternate any property 
      of your views. You can change their visibility, colors, opacity,
      bitmaps shown in image views, fonts used to render text, the position
      and the size the view, ...
       

      HINT:

      Instead of instantly alternate the views properties you can here also
      start effects to do this with an animation. Important: To decide when
      to start an effect you should compare the current state of the button
      (e.g. 'isPressed') with its preceding state (e.g. variable 'pressed').

      Assuming you have already added to your button component a new effect
      member, named it 'pressedEffect' and configured it to animate e.g. the
      opacity of an image within the button. Then following is sufficient to
      trigger the animation:

        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( !isEnabled )
    {
      Background.Color = Res::Red;
    }

    else if ( isPressed )
    {
      Background.Color = Res::RedLight;
    }

    else if ( isSelected )
    {
      Background.Color = Res::Red;
      }

    // Enabled but not pressed nor selected.
    else
    {
       Background.Color = Res::Red;
    }


    // Update the parameters of the text view (label)
    if ( Text != null )
    {
       var color clr = #FFFFFFFF; 
      Text.Font      = Res::IconsFont25;
      Text.String = Label;
      Text.Color     = clr;
      }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,65>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,65>;
    preset Point3 = <65,65>;
    preset Point2 = <65,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <0,0,65,65>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <450,50,650,90>
  onset Label
  {
    // The value doesn't change - nothing to do.
    if ( pure Label == value )
      return;

    // Remember the property's new value.
    pure Label = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Label = "";

  $rect <710,350,910,390>
  var Views::Text textView;
}

$rect <200,530,400,570>
$output false
enum Sorting
{
  $rect <10,10,210,50>
  item None;

  $rect <220,10,420,50>
  item Ascending;

  $rect <430,10,630,50>
  item Descending;
}

$rect <440,420,670,460>
$output false
class DeviceClass : Templates::DeviceClass
{
  $rect <0,40,200,80>
  inherited method Done()
  {
    // The following section is intended to perform de-initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         de-initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. de-register the object from the middleware if you have registered it
         beforehand.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           de-initialization steps. For example, you invoke some 'C' function:

             YourDevice_DeInitialize();

           IMPORTANT:
           ----------

           The variable 'thisObject' represents the actually de-initialized instance of the
           Application::DeviceClass. If you have stored this object at the initialization
           time (in the 'Init' method) in some global C variable or registered it by the
           middleware, it is important to perform now the opposite operation. Set the
           global variable to NULL or de-register 'thisObject' object from the middleware.
           
        */
      }
    $endif
  }

  $rect <0,0,200,40>
  inherited method Init()
  {
    // The following section is intended to perform initialization-related operations
    // in the underlying device or middleware. Consequently, the section is taken in
    // account only when generating code (not during prototyping).
    $if !$prototyper
      var object thisObject = this;

      /*
         TO DO:

         The following native statement is intended to enclose code to communicate with
         your device API. The variable 'thisObject' contains a pointer to the actually
         initialized Application::DeviceClass object. Use the 'thisObject' pointer to
         e.g. register the object by the middleware as receiver of events, etc.
         
      */

      native ( thisObject )
      {
        /*
           TO DO:

           Depending on your application case you call functions of the underlying
           middleware (or access the device directly) in order to perform the necessary
           initialization steps. For example, you invoke some 'C' function:

             YourDevice_Initialize();

           The variable 'thisObject' represents the actually initialized instance of the
           Application::DeviceClass. You can store this variable e.g. in the middleware
           and use it whenever the middleware needs to notify the GUI application about
           some state alternation or events. In this manner, the middleware will be able
           to invoke methods of the interface device object.

           For example, you can store 'thisObject' in some global C variable:

             // Declaration of the global C variable
             XObject theDeviceObject;

             // Store the instance in the global variable
             theDeviceObject = thisObject;

           Later use the global variable e.g. to provide the GUI application with events:

             ApplicationDeviceClass__TriggerSomeEvent( theDeviceObject );

           IMPORTANT:
           ----------

           If you store 'thisObject' for later use, don't forget to implement the opposite
           operation in the method 'Done'. Concrete, 'Done' should set the global variable
           again to the value NULL.

        */
      }
    $endif
  }

  $rect <200,90,400,130>
  property bool Microphone;

  $rect <600,90,800,130>
  onget Microphone
  {
    // Per default return the value stored already in the property.
    return pure Microphone;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,90,600,130>
  onset Microphone
  {
    // The property doesn't change -> nothing to do.
    if ( pure Microphone == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Microphone = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Microphone;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,90,200,130>
  $output true
  method void UpdateMicrophone( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Microphone )
    {
      // Remember the new value in the internal memory of the property.
      pure Microphone = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Microphone;
    }
  }

  $rect <200,130,400,170>
  property bool Speaker;

  $rect <600,130,800,170>
  onget Speaker
  {
    // Per default return the value stored already in the property.
    return pure Speaker;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,130,600,170>
  onset Speaker
  {
    // The property doesn't change -> nothing to do.
    if ( pure Speaker == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure Speaker = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^Speaker;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,130,200,170>
  $output true
  method void UpdateSpeaker( arg bool aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure Speaker )
    {
      // Remember the new value in the internal memory of the property.
      pure Speaker = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^Speaker;
    }
  }

  $rect <200,180,400,220>
  property Application::CallState CallState = Application::CallState.None;

  $rect <600,180,800,220>
  onget CallState
  {
    // Per default return the value stored already in the property.
    return pure CallState;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,180,600,220>
  onset CallState
  {
    // The property doesn't change -> nothing to do.
    if ( pure CallState == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure CallState = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^CallState;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,180,200,220>
  $output true
  method void UpdateCallState( arg int32 aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure CallState )
    {
      // Remember the new value in the internal memory of the property.
      pure CallState = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^CallState;
    }
  }

  $rect <200,220,400,260>
  property string CallingNumber;

  $rect <600,220,800,260>
  onget CallingNumber
  {
    // Per default return the value stored already in the property.
    return pure CallingNumber;

    /*

      TO DO:

      If the property should return the value stored in the underlying device
      or in the middleware, remove the above 'return' statement and instead do
      following:

      Declare a local variable to receive the value from the underlying device.
      The type of the variable has to correspond to the data type of the property.
      For example in case of an 'int32' property:
      
        var int32 result;

      Implement a native statement to access the value and to store it in the
      variable 'result'. Then return the value. For example:

        $if !$prototyper
          native ( result )
          {
            result = YourDevice_GetSomeValue();
          }
        $endif

        return result;

    */
  }

  $rect <400,220,600,260>
  onset CallingNumber
  {
    // The property doesn't change -> nothing to do.
    if ( pure CallingNumber == value )
      return;

    // Remember the new value in the internal memory of the property.
    pure CallingNumber = value;

    // For target code generation you will use your specific device API 
    // to change the affected value.
    $if !$prototyper
      native ( value )
      {
        /*
           TO DO:

           You can call a function of your own device API or you simply
           modify a variable existing in your middleware to reflect the
           new value:

           YourDevice_SetSomeValue( value );

           or

           YourDevice_SomeVariable = value;
        */
      }
    $endif

    // Notify all associated property observers.
    notifyobservers ^CallingNumber;
  }

  // This method is intended to be called by the device to notify the GUI application \
  // about an alternation of its setting or state value.
  $rect <0,220,200,260>
  $output true
  method void UpdateCallingNumber( arg string aNewValue )
  {
    // Only if the reported value does differ from the one stored currently in the property.
    if ( aNewValue != pure CallingNumber )
    {
      // Remember the new value in the internal memory of the property.
      pure CallingNumber = aNewValue;

      // Notify all associated property observers.
      notifyobservers ^CallingNumber;
    }
  }
}

$rect <440,470,670,510>
autoobject Application::DeviceClass Device;

// Device
note group Note3
{
  attr Bounds = <420,380,710,580>;
}

$rect <30,310,210,350>
$output false
class Keypad : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272, 440>;

  $rect <10,530,210,570>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);


    if ( !isEnabled )
    {
      Background.Color = BackgoundColor;
    }

    // Enabled but not pressed nor selected.
    else
    {
       Background.Color = BackgoundColor;
    }


  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons
  {
    preset Bounds = <39,80,104,145>;
    preset Text = "1";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons1
  {
    preset Bounds = <169,80,234,145>;
    preset Text = "3";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons2
  {
    preset Bounds = <104,80,169,145>;
    preset Text = "2";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons3
  {
    preset Bounds = <39,145,104,210>;
    preset Text = "4";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons4
  {
    preset Bounds = <169,145,234,210>;
    preset Text = "6";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons5
  {
    preset Bounds = <104,145,169,210>;
    preset Text = "5";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons6
  {
    preset Bounds = <39,210,104,275>;
    preset Text = "7";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons7
  {
    preset Bounds = <169,210,234,275>;
    preset Text = "9";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons8
  {
    preset Bounds = <104,210,169,275>;
    preset Text = "8";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons9
  {
    preset Bounds = <39,275,104,340>;
    preset Text = "*";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons10
  {
    preset Bounds = <169,275,234,340>;
    preset Text = "#";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons11
  {
    preset Bounds = <104,275,169,340>;
    preset Text = "0";
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons14
  {
    preset Bounds = <104,340,169,405>;
    preset Icon = Res::CallTxt;
    preset ButtonColor = Res::Green;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt InputEtxt
  {
    preset Bounds = <9,48,264,80>;
    preset String = "";
  }

  $rect <20,20,160,60>
  object Application::TextButton HideBtn
  {
    preset Bounds = <42,359,107,384>;
    preset Text = "Hide";
    preset OnActivate = onHide;
    preset TextColor = Res::Black;
    preset TextColorPress = Res::Grey;
  }

  $rect <290,10,490,50>
  property slot OnHide;

  $rect <490,10,690,50>
  slot onHide
  {
    postsignal OnHide;
  }

  $rect <290,70,490,110>
  property color BackgoundColor = Res::WhiteSemiTransparent;

  $rect <490,70,690,110>
  onset BackgoundColor
  {
    // The value doesn't change - nothing to do.
    if ( pure BackgoundColor == value )
      return;

    // Remember the property's new value.
    pure BackgoundColor = value;

    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons12
  {
    preset Bounds = <169,340,234,405>;
    preset Icon = Res::Backspace;
    preset Text = "";
    preset ButtonColor = Res::Transparent;
    preset IconColor = Res::Black;
  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <640,170,840,210>
$output false
class KeyPadButtons : Templates::PushButton
{
  $rect <90,40,290,80>
  inherited property Bounds = <0,0,65,65>;

  $rect <690,310,890,350>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    // Update the parameters of the text view (label)
    if ( IconTxt != null )
    {
       var color clr = IconColor; 
      IconTxt.Font      = Res::IconsFont25;
      IconTxt.String = Icon;
      IconTxt.Color     = clr;
      }

    // Update the parameters of the text view (label)
    if ( DescripTxt != null )
    {
       var color clr = TextColor; 
      DescripTxt.Font      = Res::TitileFont25;
      DescripTxt.String = Text;
      DescripTxt.Color     = clr;
      }



    if ( !isEnabled )
    {
      Background.Color = Res::PressColor;
      IconTxt.Color    = Res::Grey;
      DescripTxt.Color  = Res::Grey;
    }

    else if ( isPressed )
    {
      Background.Color = ButtonColorPressed;
      IconTxt.Color    = IconColorPressed;
      DescripTxt.Color  = TextColorPressed;
    }

    else if ( isSelected )
    {
      Background.Color = ButtonColor;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }

    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <680,270,900,520>;
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <300,0,500,40>
  property string Icon;

  $rect <690,470,890,510>
  var Views::Text textView;

  $rect <510,0,710,40>
  property string Text = "";

  $rect <510,40,710,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <720,0,920,40>
  property color ButtonColor = Res::WhiteTransparent;

  $rect <720,40,920,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <300,90,500,130>
  property color IconColor = Res::White;

  $rect <300,130,500,170>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <450,270,670,400>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <220,270,440,400>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <-10,270,210,440>;
  }

  // This variable stores the current state of the button.
  $rect <690,430,890,470>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <690,390,890,430>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <690,350,890,390>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <460,310,660,350>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <230,310,430,350>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <460,350,660,390>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <230,350,430,390>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <300,40,500,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <0,390,200,430>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <0,350,200,390>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <90,0,290,40>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <0,310,200,350>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Image Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,65,65>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,65>;
    preset Point3 = <65,65>;
    preset Point2 = <65,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <0,0,65,65>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Bounds = <0,0,65,65>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <510,90,710,130>
  property color TextColor = Res::White;

  $rect <510,130,710,170>
  onset TextColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColor == value )
      return;

    // Remember the property's new value.
    pure TextColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <720,90,920,130>
  property color ButtonColorPressed = Res::WhiteSemiTransparent;

  $rect <720,130,920,170>
  onset ButtonColorPressed
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColorPressed == value )
      return;

    // Remember the property's new value.
    pure ButtonColorPressed = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <300,180,500,220>
  property color IconColorPressed = Res::WhiteSemiTransparent;

  $rect <300,220,500,260>
  onset IconColorPressed
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColorPressed == value )
      return;

    // Remember the property's new value.
    pure IconColorPressed = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <510,180,710,220>
  property color TextColorPressed = Res::WhiteSemiTransparent;

  $rect <510,220,710,260>
  onset TextColorPressed
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColorPressed == value )
      return;

    // Remember the property's new value.
    pure TextColorPressed = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <640,210,840,250>
$output false
class TextButton : Templates::PushButton
{
  $rect <480,310,680,350>
  inherited property Bounds = <0,0,66,25>;

  $rect <710,190,910,230>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    // Update the parameters of the text view (label)
    if ( TextTxt != null )
    {
      var color clr = TextColor; 
      TextTxt.Font      = Res::ContactFont15;
      TextTxt.String = Text;
      TextTxt.Color     = clr;
      }

    if ( !isEnabled )
    {
     // Background.Color = Res::WhiteTransparent;
      TextTxt.Color       = Res::Grey;
    }

    else if ( isPressed )
    {
      //Background.Color = Res::WhiteTransparent;
      TextTxt.Color       = TextColorPress;
    }

    else if ( isSelected )
    {
     // Background.Color = Res::WhiteTransparent ;
      }

    // Enabled but not pressed nor selected.
    else
    {
    // Background.Color = Res::WhiteTransparent ;
    }


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;

  }

  // State management
  note group Note4
  {
    attr Bounds = <700,150,920,400>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <470,150,690,280>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <240,150,460,280>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,150,230,320>;
  }

  // This variable stores the current state of the button.
  $rect <710,310,910,350>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <710,270,910,310>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <710,230,910,270>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <480,190,680,230>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <250,190,450,230>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <480,230,680,270>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <250,230,450,270>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,270,220,310>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,230,220,270>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,190,220,230>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <450,50,650,90>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <450,10,650,50>
  property string Text = "";

  $rect <710,350,910,390>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,25>;
    preset Point3 = <66,25>;
    preset Point2 = <66,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,66,25>;
    preset Color = #FFFFFF00;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <250,10,450,50>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text TextTxt
  {
    preset Bounds = <0,0,66,25>;
    preset String = "";
    preset Font = Res::IconsFont25;
    preset Color = #FFFFFFFF;
  }

  $rect <650,50,850,90>
  onset TextColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColor == value )
      return;

    // Remember the property's new value.
    pure TextColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <650,10,850,50>
  property color TextColor = Res::Blue;

  $rect <850,50,1050,90>
  onset TextColorPress
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColorPress == value )
      return;

    // Remember the property's new value.
    pure TextColorPress = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <850,10,1050,50>
  property color TextColorPress = Res::BlueLight;

  $reorder Bounds 1
  $reorder first 1
  $reorder last 1
  $reorder keyHandlers 1
  $reorder buffer 1
  $reorder dialogStack 1
  $reorder fadersQueue 1
  $reorder pendingFader 1
  $reorder processKeyHandlers 1
  $reorder updateBufferSlot 1
  $reorder drawContent 1
  $reorder recalculateLayout 1
  $reorder updateComponent 1
  $reorder OnSetFocus 1
  $reorder OnGetBuffered 1
  $reorder OnSetBuffered 1
  $reorder OnGetEnabled 1
  $reorder OnSetEnabled 1
  $reorder OnSetOpacity 1
  $reorder OnGetEmbedded 1
  $reorder OnSetEmbedded 1
  $reorder OnGetAlphaBlended 1
  $reorder OnSetAlphaBlended 1
  $reorder OnGetVisible 1
  $reorder OnSetVisible 1
  $reorder DrawForeground 1
  $reorder DrawBackground 1
  $reorder GetMinimalSize 1
  $reorder FindActiveDialogByClass 1
  $reorder FindDialogByClass 1
  $reorder FindCurrentDialog 1
  $reorder IsCurrentDialog 1
  $reorder IsActiveDialog 1
  $reorder IsDialog 1
  $reorder GetIndexOfDialog 1
  $reorder GetDialogAtIndex 1
  $reorder CountDialogs 1
  $reorder SwitchToDialog 1
  $reorder DismissDialog 1
  $reorder PresentDialog 1
  $reorder ObtainFocus 1
  $reorder HasViewState 1
  $reorder LocalPosition 1
  $reorder GlobalPosition 1
  $reorder DispatchEvent 1
  $reorder BroadcastEventAtPosition 1
  $reorder BroadcastEvent 1
  $reorder UpdateLayout 1
  $reorder UpdateViewState 1
  $reorder InvalidateLayout 1
  $reorder InvalidateViewState 1
  $reorder InvalidateArea 1
  $reorder GetIndexOfView 1
  $reorder GetViewAtIndex 1
  $reorder CountViews 1
  $reorder FindViewInDirection 1
  $reorder FindViewWithinArea 1
  $reorder FindViewAtPosition 1
  $reorder FindPrevView 1
  $reorder FindNextView 1
  $reorder FindSiblingView 1
  $reorder GetContentArea 1
  $reorder FadeGroup 1
  $reorder RestackBehind 1
  $reorder RestackBack 1
  $reorder RestackTop 1
  $reorder Restack 1
  $reorder RemoveAll 1
  $reorder Remove 1
  $reorder AddBehind 1
  $reorder Add 1
  $reorder Focus 1
  $reorder Buffered 1
  $reorder Enabled 1
  $reorder Opacity 1
  $reorder Embedded 1
  $reorder AlphaBlended 1
  $reorder Visible 1
  $reorder Note4 1
  $reorder Note3 1
  $reorder Note2 1
  $reorder Note1 1
  $reorder pressed 1
  $reorder selected 1
  $reorder enabled 1
  $reorder FlashTimer 1
  $reorder KeyHandler 1
  $reorder onFlashTimer 1
  $reorder onPressKey 1
  $reorder onEnterLeaveTouch 1
  $reorder onReleaseTouch 1
  $reorder onPressTouch 1
  $reorder OnSetText 1
  $reorder Text 1
  $reorder textView 1
  $reorder TouchHandler 1
  $reorder Background 1
  $reorder OnActivate 1
  $reorder TextTxt 1
}

// This class implements a 'push button' widget. When the user presses the button, \
// a signal is sent to the slot method stored in its @OnActivate property.
$rect <640,250,840,290>
$output false
class NavBarButtons : Templates::PushButton
{
  $rect <470,440,670,480>
  inherited property Bounds = <0,0,68,40>;

  $rect <700,320,900,360>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = isSelected();
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;
    /*
        if ( isPressed && !pressed )
        {
          pressedEffect.Reversed = false;
          pressedEffect.Enabled  = true;
        }
        else if ( !isPressed && pressed )
        {
          pressedEffect.Reversed = true;
          pressedEffect.Enabled  = true;
        }

    */

    if ( IconTxt != null )
    {
       var color clr = IconColor; 
      IconTxt.Font      = Res::IconsFont20;
      IconTxt.String = Icon;
      IconTxt.Color     = clr;
      }

    // Update the parameters of the text view (label)
    if ( DescripTxt != null )
    {
        var color clr = DescrpitColor; 
      DescripTxt.Font      = Res::ContactFont12;
      DescripTxt.String = Descript;
      DescripTxt.Color     = clr;
      }

    if ( !isEnabled )
    {
      IconTxt.Color     = Res::GeryLight;
      DescripTxt.Color  = Res::GeryLight;
    }

    else if ( isPressed )
    {

      IconTxt.Color     = Res::BlueLight;
      DescripTxt.Color  = Res::BlueLight;

    }

    else if ( isSelected )
    {
      IconTxt.Color     = Res::Blue;
      DescripTxt.Color  = Res::Blue;
    }

    // Enabled but not pressed nor selected.
    else
    { 
      IconTxt.Color     = Res::Grey;
      DescripTxt.Color  = Res::Grey;
    }


    // Finally set the color of the knob depending on the button's state.
    if      ( isPressed &&  isSelected ) IconTxt.Color = Res::Blue;
    else if ( isPressed && !isSelected ) IconTxt.Color = Res::BlueLight;
    else if ( isEnabled &&  isSelected ) IconTxt.Color = Res::Blue;
    else if ( isEnabled && !isSelected ) IconTxt.Color = Res::Grey;
    else if ( isSelected )               IconTxt.Color = Res::Blue;
    else                                IconTxt.Color = Res::RedLight;


    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // State management
  note group Note4
  {
    attr Bounds = <690,280,910,530>;
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <460,280,680,410>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <230,280,450,410>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <10,280,230,450>;
  }

  // This variable stores the current state of the button.
  $rect <700,440,900,480>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <700,400,900,440>
  var bool selected = true;

  // This variable stores the current state of the button.
  $rect <700,360,900,400>
  var bool enabled;

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <470,320,670,360>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <240,320,440,360>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <470,360,670,400>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <240,360,440,400>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      FlashTimer.Enabled = false;

      // Select the button and notify the owner of the button.
      if ( !isSelected() )
      {
        postsignal OnSelect;

        // If a property is associated to the button, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <20,400,220,440>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <20,360,220,400>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
    {
      // Select the button and notify the owner of the button.
      if ( !isSelected() )
      {
        
        postsignal OnSelect;

        // If a property is associated to the button, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
    }

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <20,320,220,360>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      FlashTimer.Enabled = false;

      // Select the button and notify the owner of the button.
      if ( !isSelected() )
      {
        postsignal OnSelect;

        // If a property is associated to the button, update it accordingly and notify
        // other widgets also associated to this property.
        if ( Outlet != null )
        {
          Outlet^ = OutletSelector;
          notifyobservers Outlet; 
        }
      }
    }
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,40>;
    preset Point3 = <65,40>;
    preset Point2 = <65,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <90,0,290,40>
  property slot OnActivate = null;

  $rect <20,20,160,60>
  object Views::Text IconTxt
  {
    preset Bounds = <0,0,68,25>;
    preset String = "";
    preset Font = Res::IconsFont20;
    preset Color = #FFFFFFFF;
  }

  $rect <100,150,250,190>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <100,110,250,150>
  property string Icon;

  $rect <700,480,900,520>
  var Views::Text textView;

  $rect <20,20,160,60>
  object Views::Text DescripTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,25,68,40>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "";
    preset Font = Res::ContactFont12;
  }

  $rect <260,110,430,150>
  property string Descript = "Text";

  $rect <260,150,430,190>
  onset Descript
  {
    // The value doesn't change - nothing to do.
    if ( pure Descript == value )
      return;

    // Remember the property's new value.
    pure Descript = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <100,200,250,240>
  property color IconColor = Res::Grey;

  $rect <100,240,250,280>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <260,200,430,240>
  property color DescrpitColor = Res::Grey;

  $rect <260,240,430,280>
  onset DescrpitColor
  {
    // The value doesn't change - nothing to do.
    if ( pure DescrpitColor == value )
      return;

    // Remember the property's new value.
    pure DescrpitColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <450,40,620,80>
  onset OutletSelector
  {
    // Check if the given value differs from the current value
    if ( pure OutletSelector == value )
      return;

    pure OutletSelector = value;

    InvalidateViewState();
  }

  $rect <300,40,450,80>
  onset Outlet
  {
    // Check if the new outlet differs from the currently used outlet
    if ( pure Outlet == value )
      return;

    // Detach from the previous outlet
    if ( pure Outlet != null )
      detachobserver onOutlet, pure Outlet;

    // Store the new outlet ...
    pure Outlet = value;

    // ... and attach to the new one
    if ( value != null )
      attachobserver onOutlet, value;

    // Finally, retrieve the current state of the property associated via 'Outlet'.
    if ( value != null )
      postsignal onOutlet;
  }

  // The property 'OnSelect' can refer to a slot method, which will receive a signal \
  // as soon as the user has selected the radio button. Thereupon the method's logic \
  // will be executed.
  $rect <630,0,790,40>
  property slot OnSelect = null;

  // The property 'OutletSelector' contains a value identifying the radio button \
  // within a group of radio buttons. At the runtime, the button compares this value \
  // with the value of the property referred by @Outlet and if both are equal, the \
  // radio button assumes the 'selected' state (its property @Selected is 'true'). \
  // If the values are different, the radio button appears not selected. This selector \
  // is useful to build a group of radio buttons that refers to the same outlet. \
  // Different selectors for each radio button manages automatically the group of \
  // radio buttons.
  $rect <450,0,620,40>
  property int32 OutletSelector = 0;

  // The property 'Outlet' can refer to any other 'int32' property the widget should \
  // remain synchronized with. When the user selects the radio button, the affected \
  // property is automatically updated to the value found in the property @OutletSelector. \
  // On the other hand, when the referred property is modified by another one, the \
  // radio button is automatically notified to remain in sync with the property. \
  // The button appears selected, when the referred property has the value equal \
  // to @OutletSelector.
  // This approach follows the Model-View-Controller (MVC) programming paradigm. \
  // Here the radio button represents the 'View' and 'Controller' and the property \
  // referred via 'Outlet' can be seen as a part of the 'Model'.
  $rect <300,0,450,40>
  property ^int32 Outlet = null;

  // Controller events
  note group Note5
  {
    attr Bounds = <230,410,450,500>;
  }

  // This slot method will receive a signal, if the value of the property assigned \
  // to @Outlet has been changed by another widget or by the application logic. In \
  // response to this notification, the widget will update itself.
  $rect <240,450,440,490>
  slot onOutlet
  {
    // ... and finally, request an update
    InvalidateViewState();
  }

  $rect <790,0,990,40>
  method bool isSelected()
  {

    return Outlet != null && Outlet^ == OutletSelector;
  }
}

$rect <210,280,400,320>
$output false
class Keypad1 : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272, 440>;

  $rect <730,140,930,180>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);

    if ( HideFunction == false)
    {
      HideBtn.Visible= true;
    }

    if ( HideFunction == true)
    {
      HideBtn.Visible= false;
    }

    if ( HideCall == false)
    {
      KeyPadButtons14.Visible= true;
    }

    if ( HideCall == true)
    {
      KeyPadButtons14.Visible= false;
    }


    if ( !isEnabled )
    {
      Background.Color = BackgoundColor;
    }

    // Enabled but not pressed nor selected.
    else
    {
       Background.Color = BackgoundColor;
    }


  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn1
  {
    preset Bounds = <39,80,104,145>;
    preset Text = "1";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn3
  {
    preset Bounds = <169,80,234,145>;
    preset Text = "3";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn2
  {
    preset Bounds = <104,80,169,145>;
    preset Text = "2";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn4
  {
    preset Bounds = <39,145,104,210>;
    preset Text = "4";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn6
  {
    preset Bounds = <169,145,234,210>;
    preset Text = "6";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn5
  {
    preset Bounds = <104,145,169,210>;
    preset Text = "5";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn7
  {
    preset Bounds = <39,210,104,275>;
    preset Text = "7";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn9
  {
    preset Bounds = <169,210,234,275>;
    preset Text = "9";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn8
  {
    preset Bounds = <104,210,169,275>;
    preset Text = "8";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons9
  {
    preset Bounds = <39,275,104,340>;
    preset Text = "*";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn
  {
    preset Bounds = <169,275,234,340>;
    preset Text = "#";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons btn0
  {
    preset Bounds = <104,275,169,340>;
    preset Text = "0";
    preset OnActivate = onButtonsPress;
  }

  $rect <20,20,160,60>
  object Application::InputEtxt InputEtxt
  {
    preset Bounds = <39,48,234,80>;
    preset String = "";
    preset Color = Res::Black;
    preset Font = Res::TitileFont25;
  }

  $rect <20,20,160,60>
  object Application::TextButton HideBtn
  {
    preset Bounds = <42,359,107,384>;
    preset Text = "Hide";
    preset OnActivate = onHide;
    preset TextColor = Res::Black;
    preset TextColorPress = Res::Grey;
  }

  $rect <290,10,490,50>
  property slot OnHide;

  $rect <490,10,690,50>
  slot onHide
  {
    postsignal OnHide;
  }

  $rect <290,70,490,110>
  property color BackgoundColor = Res::WhiteSemiTransparent;

  $rect <490,70,690,110>
  onset BackgoundColor
  {
    // The value doesn't change - nothing to do.
    if ( pure BackgoundColor == value )
      return;

    // Remember the property's new value.
    pure BackgoundColor = value;

    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons BtnErase
  {
    preset Bounds = <169,340,234,405>;
    preset Icon = Res::Backspace;
    preset Text = "";
    preset ButtonColor = Res::Transparent;
    preset IconColor = Res::Black;
    preset OnActivate = onButtonsPress;
  }

  $rect <290,120,490,160>
  property bool HideFunction = true;

  $rect <490,120,690,160>
  onset HideFunction
  {
    // The value doesn't change - nothing to do.
    if ( pure HideFunction == value )
      return;

    // Remember the property's new value.
    pure HideFunction = value;
    InvalidateViewState();
  }

  $rect <290,220,490,260>
  slot onButtonsPress
  {
    var Application::KeyPadButtons b = (Application::KeyPadButtons)sender;

    if ( sender == BtnErase)
      InputEtxt.String = InputEtxt.String.remove( InputEtxt.String.length-1, 1);
    else if ( b != null )
    {
      InputEtxt.String += b.Text;
    }

    signal OnEditTextChanged;        

  }

  $rect <20,20,160,60>
  object Application::KeyPadButtons KeyPadButtons14
  {
    preset Bounds = <104,340,169,405>;
    preset Icon = Res::CallTxt;
    preset ButtonColor = Res::Green;
    preset OnActivate = onCallPress;
  }

  $rect <290,160,490,200>
  property bool HideCall = false;

  $rect <490,160,690,200>
  onset HideCall
  {
    // The value doesn't change - nothing to do.
    if ( pure HideCall == value )
      return;

    // Remember the property's new value.
    pure HideCall = value;
    InvalidateViewState();
  }

  $rect <290,260,490,300>
  slot onCallPress
  {
    var Application::CallPage callpg= new Application::CallPage;

    SwitchToDialog( callpg, null, null, null, null, null, null, null, null, null, false );
  }

  $rect <874,317,1074,357>
  property slot OnEditTextChanged = null;
}

// This is the root component of the entire GUI application.
$rect <10,70,210,110>
$output false
class ContactsApp : Core::Group
{
  $rect <726,148,906,188>
  inherited method Init()
  {
    SelectedPage = 2;
  }

  $rect <280,0,480,40>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  object Core::Group Outline
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,440,272,480>;
  }

  $rect <20,20,160,60>
  object Application::NavBarButtons NavBarButtons
  {
    preset Bounds = <0,440,68,480>;
    preset Icon = Res::HeartTxt;
    preset Descript = "Favorites";
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Application::NavBarButtons NavBarButtons1
  {
    preset Bounds = <68,440,136,480>;
    preset Icon = Res::CallTxt;
    preset Descript = "Recent";
    preset OutletSelector = 1;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Application::NavBarButtons NavBarButtons2
  {
    preset Bounds = <136,440,204,480>;
    preset Icon = Res::UserIconTxt;
    preset Descript = "Contacts";
    preset OutletSelector = 2;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Application::NavBarButtons NavBarButtons3
  {
    preset Bounds = <204,440,272,480>;
    preset Icon = Res::KeypadTxt;
    preset Descript = "Keypad";
    preset OutletSelector = 3;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <270,440>;
    preset Point1 = <0,440>;
    preset Color = Res::Grey;
  }

  $rect <290,270,490,310>
  property int32 SelectedPage = -1;

  $rect <290,310,490,350>
  onset SelectedPage
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedPage == value )
      return;

    // Remember the property's new value.
    pure SelectedPage = value;

    notifyobservers ^SelectedPage;

    switch ( pure SelectedPage )
    {
      case 0: 
      {
        var Core::Group contacts = new Application::ContactsPage;
        Outline.SwitchToDialog( contacts, null, null, null, null, null, null, null, null, null,false );
      }
      case 1: 
      {
        var Core::Group contacts = new Application::ContactsPage;
        Outline.SwitchToDialog( contacts, null, null, null, null, null, null, null, null, null,false );
      }
      case 2: 
      {
        var Core::Group contacts = new Application::ContactsPage;
        Outline.SwitchToDialog( contacts, null, null, null, null, null, null, null, null, null,false );
      }
      case 3: 
      {
        var Core::Group keypad = new Application::Keypad1;
        Outline.SwitchToDialog( keypad, null, null, null, null, null, null,
                                null, null, null,false );
      }

      default:
        trace "ERROR: invalid selected page ", pure SelectedPage;
    }

  }

  $rect <290,350,490,390>
  onget SelectedPage
  {
    return pure SelectedPage;
  }
}

$rect <10,30,210,70>
$output false
class Application : Core::Root
{
  $rect <290,50,490,90>
  inherited method Init()
  {
    attachobserver onCallState, ^Application::Device.CallState;
    postsignal onCallState;


  }

  $rect <290,0,490,40>
  inherited property Bounds = <0,0,272,480>;

  // To do:
  // 
  // - Adjust the visible size of your application (the thick blue border). It should \
  // correspond to the size of your target display.
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <10,510,790,740>;
  }

  $rect <20,20,160,60>
  object Application::ContactsApp CoontactsApp
  {
    preset Bounds = <0,0,272,480>;
  }

  $rect <290,90,490,130>
  slot onCallState
  {
    var Application::CallPage  outgoingCall     = new Application::CallPage;
    var Application::InComingCall  incomingCall = new Application::InComingCall;
    CoontactsApp

    trace Application::Device.CallState, Application::Device.CallingNumber;

    if ( Application::Device.CallState == Application::CallState.None)
    {
    PresentDialog( outgoingCall, null, null, null, null, null, null, null, null, false );
    }

    else if ( Application::Device.CallState == Application::CallState.RingOutgoing)
    {
      PresentDialog( outgoingCall, null, null, null, null, null, null, null, null, false );
    }
    else if ( Application::Device.CallState == Application::CallState.RingIncoming)
    {
      PresentDialog( incomingCall, null, null, null, null, null, null, null, null, false );
    }



  }

  $rect <700,0,900,40>
  var Application::DeviceClass deviceInstance = Application::Device;

  $rect <490,0,690,40>
  var Application::Contacts myContactInstance = Application::MyContacts;
}

$rect <210,320,400,360>
$output false
class KeypadInsideCall : Application::Keypad1
{
  $rect <20,20,160,60>
  object Views::Rectangle BackgroundSmall
  {
    preset Bounds = <0,80,272,340>;
    preset ColorBL = #868686FA;
    preset ColorBR = #636363FF;
    preset ColorTR = #898989FF;
    preset ColorTL = #898989FF;
    preset Color = #3C3C3CFF;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  inherited object btn1
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn3
  {
    preset Enabled = true;
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn2
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn4
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn6
  {
    preset ButtonColor = Res::WhiteTransparent;
  }

  $rect <20,20,160,60>
  inherited object btn5
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn7
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn9
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn8
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object KeyPadButtons9
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object btn0
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object InputEtxt
  {
    preset Bounds = <39,32,234,64>;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  inherited object HideBtn
  {
    preset TextColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object BtnErase
  {
    preset Text = "";
    preset IconColor = Res::White;
    preset ButtonColorPressed = Res::Transparent;
  }

  $rect <20,20,160,60>
  inherited object KeyPadButtons14
  {
    preset Visible = false;
  }

  $reorder BackgroundSmall 28
}

$rect <230,230,400,270>
$output false
class EditInsideCall : Application::ContactEditPage
{
  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,42,272,480>;
  }

  $rect <20,20,160,60>
  inherited object DeleteBtn
  {
    preset Bounds = <7,431,265,464>;
  }

  $rect <20,20,160,60>
  inherited object NumberTxt
  {
    preset Bounds = <7,294,265,323>;
  }

  $rect <20,20,160,60>
  inherited object Line4
  {
    preset Point2 = <264,289>;
    preset Point1 = <6,289>;
  }

  $rect <20,20,160,60>
  inherited object MobileTxt
  {
    preset Bounds = <6,257,264,290>;
  }

  $rect <20,20,160,60>
  inherited object Line3
  {
    preset Point2 = <263,256>;
    preset Point1 = <5,256>;
  }

  $rect <20,20,160,60>
  inherited object FirstNameTxt
  {
    preset Bounds = <2,224,268,256>;
  }

  $rect <20,20,160,60>
  inherited object Line2
  {
    preset Point2 = <263,223>;
    preset Point1 = <5,223>;
  }

  $rect <20,20,160,60>
  inherited object LastNameTxt
  {
    preset Bounds = <2,191,268,223>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <263,190>;
    preset Point1 = <5,190>;
  }

  $rect <20,20,160,60>
  inherited object UserInitials
  {
    preset Bounds = <101,74,171,165>;
  }

  $rect <20,20,160,60>
  inherited object CloseBtn
  {
    preset Bounds = <7,43,32,68>;
  }

  $rect <20,20,160,60>
  inherited object SaveBtn
  {
    preset Bounds = <239,42,264,67>;
  }
}

$rect <230,190,400,230>
$output false
class AddInsideCall : Application::ContactAddPage
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,42,272,480>;
  }

  $rect <20,20,160,60>
  inherited object Line4
  {
    preset Point2 = <265,321>;
    preset Point1 = <7,321>;
  }

  $rect <20,20,160,60>
  inherited object PhoneNumberTxt
  {
    preset Bounds = <3,289,269,321>;
  }

  $rect <20,20,160,60>
  inherited object Line3
  {
    preset Point2 = <264,288>;
    preset Point1 = <6,288>;
  }

  $rect <20,20,160,60>
  inherited object FirstNameTxt
  {
    preset Bounds = <3,255,269,287>;
  }

  $rect <20,20,160,60>
  inherited object Line2
  {
    preset Point2 = <264,255>;
    preset Point1 = <6,255>;
  }

  $rect <20,20,160,60>
  inherited object LastNameTxt
  {
    preset Bounds = <3,222,269,254>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <264,222>;
    preset Point1 = <6,222>;
  }

  $rect <20,20,160,60>
  inherited object UserInitials;

  $rect <20,20,160,60>
  inherited object TitleTxt
  {
    preset Bounds = <86,42,186,72>;
  }

  $rect <20,20,160,60>
  inherited object SaveBtn
  {
    preset Bounds = <240,42,265,67>;
  }

  $rect <20,20,160,60>
  inherited object CloseButton
  {
    preset Bounds = <7,42,32,67>;
  }
}

$rect <230,110,400,150>
$output false
class ContactsInsideCall : Application::ContactsPage
{
  $rect <490,70,690,110>
  inherited slot onAddPress
  {
    addContact = new Application::AddInsideCall;

    addContact.OnSave  = onSaveAdd;
    addContact.OnClose = onCancelAdd; 
    addContact.Contact = new Application::Contact;

    SwitchToDialog( addContact, Res::SlideUpCentered, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <290,70,490,110>
  inherited var addContact;

  $rect <290,110,490,150>
  inherited var detailsPage;

  $rect <20,20,160,60>
  inherited object Background;

  $rect <20,20,160,60>
  inherited object VerticalList;

  $rect <20,20,160,60>
  inherited object SlideTouchHandler;

  $rect <20,20,160,60>
  inherited object UpButton;

  $rect <20,20,160,60>
  inherited object DownButton;

  $rect <20,20,160,60>
  inherited object SearchExt;

  $rect <20,20,160,60>
  inherited object TitleTxt
  {
    preset Bounds = <11,12,261,61>;
    preset Font = Res::ContactFontBold15;
  }

  $rect <20,20,160,60>
  inherited object PlusButton
  {
    preset Bounds = <166,12,196,42>;
  }

  $rect <490,110,690,150>
  inherited slot onContactActivated
  {
    var Application::ContactItem itemView = (Application::ContactItem)sender;

    if ( itemView != null )
    {
      detailsPage = new Application::DetailsInsideCall;
      detailsPage.OnBack = onCloseContact;
      detailsPage.OnDelete = onDeleteContact;

      detailsPage.Contact = itemView.Contact;
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }

  }

  $rect <20,20,160,60>
  object Application::TextButton TextButton
  {
    preset Bounds = <196,15,262,40>;
    preset Text = "Cancel";
    preset OnActivate = onCancel;
  }

  $rect <290,0,490,40>
  property slot OnCancel;

  $rect <490,0,690,40>
  slot onCancel
  {
    postsignal OnCancel;
  }
}

$rect <230,150,400,190>
$output false
class DetailsInsideCall : Application::ContactDetailsPage
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,480>;

  $rect <490,20,690,60>
  inherited slot onTapEdit
  {
    edit = new Application::EditInsideCall;

    edit.OnSave  = onSaveEdit;
    edit.OnClose = onCancelEdit;
    edit.Contact = Contact;
    edit.OnDelete = onDelete;

    SwitchToDialog( edit, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );
     



  }

  $rect <290,20,490,60>
  inherited var edit;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,42,272,480>;
  }

  $rect <20,20,160,60>
  inherited object Line2
  {
    preset Point2 = <265,351>;
    preset Point1 = <7,351>;
  }

  $rect <20,20,160,60>
  inherited object NumberTxt
  {
    preset Bounds = <19,322,263,351>;
  }

  $rect <20,20,160,60>
  inherited object MobileTxt
  {
    preset Bounds = <7,296,265,329>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <265,296>;
    preset Point1 = <7,296>;
  }

  $rect <20,20,160,60>
  inherited object CallBtn
  {
    preset Bounds = <51,201,101,276>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  inherited object VideoCallBtn
  {
    preset Bounds = <111,201,161,276>;
  }

  $rect <20,20,160,60>
  inherited object PushButtonMediumBlue2
  {
    preset Bounds = <171,201,221,276>;
  }

  $rect <20,20,160,60>
  inherited object ContactName
  {
    preset Bounds = <11,154,268,184>;
  }

  $rect <20,20,160,60>
  inherited object UserInitialsBtn
  {
    preset Bounds = <101,70,171,161>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  inherited object EditBtn
  {
    preset Bounds = <240,45,265,70>;
  }

  $rect <20,20,160,60>
  inherited object BackBtn
  {
    preset Bounds = <7,45,32,70>;
  }
}

$rect <842,63,1042,103>
$output false
class Component : Core::Group
{
  $rect <10,230,210,270>
  inherited property Bounds = <0,0,669,480>;

  $rect <10,390,210,430>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <10,350,210,390>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Application::ContactsPage ContactsPage
  {
    preset Bounds = <256,41,608,395>;
  }
}

$rect <450,530,650,570>
$output false
enum CallState
{
  $rect <10,10,210,50>
  item None;

  $rect <220,10,420,50>
  item RingIncoming;

  $rect <430,10,630,50>
  item RingOutgoing;

  $rect <640,10,840,50>
  item Talk;
}

$rect <740,427,940,467>
$variant Simulation
vclass ApplicationSimulation : Application::Application
{
  $rect <810,0,1010,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <399,105,549,155>;
    preset OnActivate = onIncomingCall;
    preset Label = "Incoming call";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <844,104,1044,144>
  slot onIncomingCall
  {
    Application::Device.UpdateCallState( Application::CallState.RingIncoming );
    Application::Device.UpdateCallingNumber( "+40723494923" );
  }
}

$rect <740,470,990,510>
$output false
autoobject Effects::FadeInOutTransition FadeInOutTransition;

// Simulation

note group Note4
{
  attr Bounds = <720,380,1010,580>;
}

$rect <210,30,410,70>
$output false
class InComingCall : Core::Group
{
  $rect <980,20,1180,60>
  inherited method Init()
  {
    attachobserver onCallState, ^Application::Device.CallState;
    postsignal onCallState;


  }

  $rect <770,20,970,60>
  inherited property Bounds = <0,0,272,480>;

  $rect <310,90,500,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <310,130,500,170>
  slot onContactUpdated
  {
    if ( pure Contact != null )
    {
      ContactNameTxt.String  = pure Contact.LastName + " "  + pure Contact.FirstName;
      UserInitials.Initials = Application::MyContacts.GetInitials( pure Contact.LastName, pure Contact.FirstName);
      
    }

  }

  $rect <310,50,500,90>
  property Application::Contact Contact;

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,0,760,200>;
  }

  $rect <310,250,510,290>
  property bool OnDesclineCall = false;

  $rect <520,250,720,290>
  slot onDesclineCall
  {
    Application::Device.UpdateCallState( Application::CallState.None );

    postsignal onCallState;

  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,760,640>;
  }

  $rect <770,90,970,130>
  slot onCallState
  {
    var Application::CallPage  talkCall     = new Application::CallPage;
    trace Application::Device.CallState, Application::Device.CallingNumber;

    if ( Application::Device.CallState == Application::CallState.None)
    {
      DismissDialog( this, null, null, null, null, null, false);
    } 
    else if (Application::Device.CallState == Application::CallState.Talk)
    {
      PresentDialog( talkCall, null, null, null, null, null, null, null, null, false );
    }

  }

  $rect <310,290,510,330>
  property bool OnAcceptCall = false;

  $rect <520,290,720,330>
  slot onAcceptCall
  {
    Application::Device.UpdateCallState( Application::CallState.Talk);

    postsignal onCallState;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,480>;
    preset ColorBL = #838383FA;
    preset ColorBR = #4F4F4FFF;
    preset ColorTR = #898989FF;
    preset ColorTL = #898989FF;
    preset Color = #3C3C3CFF;
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans PushButtonMediumTrans
  {
    preset Bounds = <171,340,236,432>;
    preset OnActivate = onAcceptCall;
    preset Icon = Res::CallTxt;
    preset Descript = "Accept";
    preset ButtonColor = Res::GreenDark;
  }

  $rect <20,20,160,60>
  object Application::PushButtonMediumTrans PushButtonMediumTrans1
  {
    preset Bounds = <36,340,101,432>;
    preset OnActivate = onDesclineCall;
    preset Icon = Res::EndCallTxt;
    preset Descript = "Descline";
    preset ButtonColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <18,87,91,117>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "calling...";
    preset Font = Res::ContactFont12;
    preset Color = #FAFAFAFF;
  }

  $rect <20,20,160,60>
  object Views::Text ContactNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <18,57,184,87>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont25;
    preset Color = #FAFAFAFF;
  }

  $rect <20,20,160,60>
  object Application::PushButtonBig UserInitials
  {
    preset Bounds = <184,57,254,148>;
    preset Enabled = false;
    preset Descript = "";
  }
}
