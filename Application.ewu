$version 11.00

$rect <250,160,430,200>
$output false
class ContactsPage : Core::Group
{
  $rect <310,40,480,80>
  inherited method Init()
  {
    attachobserver onNoOfContactsChanged, ^Device::Device.Contacts.NoOfItems;
    postsignal onNoOfContactsChanged;

    attachobserver onContactsSortingChanged, ^Device::Device.Contacts.Sorting;
    postsignal onContactsSortingChanged;






  }

  $rect <310,80,480,120>
  inherited property Bounds = <0,0,272,440>;

  $rect <450,210,650,250>
  slot onAddPress
  {
    addContact = new Application::ContactAddPage;

    addContact.OnSave  = onSaveAdd;
    addContact.OnClose = onCancelAdd; 
    addContact.Contact = new Device::Contact;

    SwitchToDialog( addContact, Res::SlideUpCentered, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <300,210,450,250>
  var Application::ContactAddPage addContact = null;

  $rect <470,250,650,290>
  slot onSaveAdd
  {
    Device::Device.Contacts.AddLast( addContact.Contact );

    DismissDialog( addContact, Res::SlideDownCentered, null, null, null, null, false);

    addContact = null;
  }

  $rect <470,290,650,330>
  slot onCancelAdd
  {
    DismissDialog( addContact, Res::SlideDownCentered, null, null, null, null, false);
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,660,140>;
  }

  $rect <900,40,1100,80>
  property int32 SelectedContact;

  $rect <900,80,1100,120>
  onset SelectedContact
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedContact == value )
      return;

    // Remember the property's new value.
    pure SelectedContact = value;

    notifyobservers ^SelectedContact; 
  }

  $rect <470,420,650,460>
  slot onDeleteContact
  {
    VerticalList.InvalidateItems( SelectedContact, VerticalList.NoOfItems - 1 );
     
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);
  }

  $rect <690,180,890,220>
  slot onSearch
  {
    /*var Device::Contact it = contact;
    var string filter                = SearchExt.String;
    var int32  i;
    var int32  j = 0;


    while ( it != null )
    {
      if (( it.FirstName.find( filter, 0 ) >= 0 ) ||
          ( it.LastName.find( filter, 0 ) >= 0 ))
          ///////////////////////// 
        Filtered_Array[j++] = Original_Array[i];
      
      contact = contact.next;
      j++;
    }

    // Inform the list about its changed size
    VerticalList.NoOfItems = j;
    VerticalList.InvalidateItems( 0, j );
    */
  }

  $rect <300,340,450,380>
  var Application::ContactDetailsPage detailsPage;

  $rect <470,380,650,420>
  slot onCloseContact
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,150,660,470>;
  }

  $rect <690,230,890,270>
  slot onUpPress
  {
    Device::Device.Contacts.Sorting = Device::Sorting.Ascending;


  }

  $rect <690,270,890,310>
  slot onDownPress
  {
    Device::Device.Contacts.Sorting = Device::Sorting.Descending;

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <690,140,890,180>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var int32 itemNo = VerticalList.Item;

    var Device::Contact contact = Device::Device.Contacts.GetContact( itemNo );

    var Application::ContactItem itemView = (Application::ContactItem)VerticalList.View;
                                                  
    if ( itemView == null )
      return;

    itemView.Contact    = contact;
    itemView.OnActivate = onContactActivated;

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <680,40,890,80>
  slot onNoOfContactsChanged
  {
    VerticalList.NoOfItems = Device::Device.Contacts.NoOfItems;

  }

  // Vertical list
  note group Note1
  {
    attr Bounds = <670,0,1110,320>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,167,261,440>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 32;
    preset ItemClass = Application::ContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -1;
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <12,167,261,440>;
    preset SnapNext = <0,35>;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground UpButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <236,141,262,167>;
    preset OnActivate = onUpPress;
    preset Icon = Res::Uptxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground DownButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <210,141,236,167>;
    preset Enabled = true;
    preset OnActivate = onDownPress;
    preset Icon = Res::DownTxt;
  }

  $rect <20,20,160,60>
  object Components::SearchEtxt SearchExt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <3,67,269,99>;
    preset OnChange = onSearch;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <11,27,261,61>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::ContactsTxtx;
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground PlusButton
  {
    preset Bounds = <242,12,272,42>;
    preset Enabled = true;
    preset OnActivate = onAddPress;
    preset Icon = Res::PlusIconTxt;
  }

  $rect <680,80,890,120>
  slot onContactsSortingChanged
  {
    VerticalList.InvalidateItems ( 0, VerticalList.NoOfItems -1 );
  }

  $rect <450,340,650,380>
  slot onContactActivated
  {
    var Application::ContactItem itemView = (Application::ContactItem)sender;

    if ( itemView != null )
    {
      detailsPage          = new Application::ContactDetailsPage;
      detailsPage.OnBack   = onCloseContact;
      detailsPage.OnDelete = onDeleteContact;
      detailsPage.Contact  = itemView.Contact;
      
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }

  }

  $rect <20,20,160,60>
  object Views::Text MyCardTxt
  {
    preset Bounds = <65,103,165,126>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "My Card";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::PushButtonSmall PushButtonSmall
  {
    preset Bounds = <29,112,54,137>;
    preset Icon = Res::UserIconTxt;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  object Templates::TextEditor TextEditor1
  {
    preset Bounds = <186,130,186,130>;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt InputEtxt
  {
    preset Bounds = <65,125,165,157>;
    preset OnChange = onSetMyNumber;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Color = Res::Grey;
    preset Placeholder = "ex. 123";
  }

  $rect <480,40,650,80>
  slot onSetMyNumber
  {
    Device::Device.MyNumber = InputEtxt.String;
  }
}

// GUI
note group Note
{
  attr Bounds = <0,0,980,400>;
}

$rect <271,200,430,240>
$output false
class ContactItem : Core::Group
{
  $rect <503,147,683,187>
  inherited method Init()
  {
    $if $composer
      FirstNameTxt.String = "Firstname";
      LastNameTxt.String = "Lastname";
    $endif
  }

  $rect <10,500,210,540>
  inherited property Bounds = <0,0,272,32>;

  $rect <10,100,210,140>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GreyLight;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }




    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  $rect <230,110,430,150>
  property Device::Contact Contact = null;

  $rect <230,150,430,190>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
    }
    postsignal onContactUpdated;

  }

  $rect <230,190,430,230>
  slot onContactUpdated
  {
    if ( Contact == null )
    {
      FirstNameTxt.String = "";
      LastNameTxt.String = "";
      PrfofilButton.Text = "";
    }
    else
    {
      if ( pure Contact.LastName == "")
        LastNameTxt.String = pure Contact.FirstName;
      else
      {
        FirstNameTxt.String = pure Contact.FirstName;
        LastNameTxt.String  = pure Contact.LastName;
       }
      PrfofilButton.Text  = pure Contact.NameInitials;
     
    }

      //FavoritTxt.Visible  =  pure Contact.Favorite ? true : false;
  }

  // Contact data
  note group Note4
  {
    attr Bounds = <220,60,440,270>;
  }

  // State management
  note group Note5
  {
    attr Bounds = <0,60,220,310>;
  }

  $rect <10,260,210,300>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <10,220,210,260>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <10,180,210,220>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <10,140,210,180>
  var bool enabled;

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <580,0,780,40>
  property string Icon;

  $rect <790,0,990,40>
  property string Text = "";

  $rect <790,40,990,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <990,0,1190,40>
  property color ButtonColor = Res::White;

  $rect <990,40,1190,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <1190,0,1390,40>
  property color IconColor = Res::White;

  $rect <1190,40,1390,80>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <460,320,680,450>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <230,320,450,450>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <0,320,220,490>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <470,360,670,400>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <240,360,440,400>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <470,400,670,440>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <240,400,440,440>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <580,40,780,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <10,440,210,480>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <10,400,210,440>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <370,0,570,40>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <10,360,210,400>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <1390,0,1590,40>
  property color TextColor = Res::Black;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,32>;
    preset Point3 = <268,32>;
    preset Point2 = <268,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,32>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text LastNameTxt
  {
    preset Bounds = <55,2,146,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text FirstNameTxt
  {
    preset StackingPriority = 0;
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz];
    preset Bounds = <146,2,268,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <272,32>;
    preset Point1 = <0,32>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Components::PushButtonSmall PrfofilButton
  {
    preset Bounds = <6,4,31,29>;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <267,0>;
    preset Point1 = <0,0>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }
}

$rect <270,240,430,280>
$output false
class ContactDetailsPage : Core::Group
{
  $rect <-10,510,190,550>
  inherited property Bounds = <0,0,272,440>;

  $rect <450,50,630,90>
  slot onTapEdit
  {
    editContact = new Application::ContactEditPage;

    editContact.OnSave   = onSaveEdit;
    editContact.OnClose  = onCancelEdit;
    editContact.Contact  = Contact;
    editContact.OnDelete = onDelete;

    SwitchToDialog( editContact, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );
     



  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <770,0,1240,200>;
  }

  $rect <300,220,460,260>
  slot onDelete
  {
    signal OnDelete;
    DismissDialog( editContact, Res::FadeInOutCentered, null, null, null, null, false);
  }

  $rect <460,220,620,260>
  property slot OnDelete;

  $rect <300,50,450,90>
  var Application::ContactEditPage editContact;

  $rect <310,280,490,320>
  slot onTapCall
  {
    Device::Device.OutgoingCallContact( Contact );
  }

  $rect <460,90,620,130>
  slot onSaveEdit
  {
    DismissDialog( editContact, Res::FadeInOutCentered, null, null, null, null, false);
  }

  $rect <460,130,620,170>
  slot onCancelEdit
  {
    DismissDialog( editContact, Res::FadeInOutCentered, null, null, null, null, false);
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,760,340>;
  }

  $rect <460,180,620,220>
  property slot OnBack;

  $rect <300,180,460,220>
  slot onBack
  {
    signal OnBack;
  }

  $rect <790,90,980,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <790,130,980,170>
  slot onContactUpdated
  {
    if ( pure Contact != null )
    {
      ContactName.String =       pure Contact.LastName + " "  + pure Contact.FirstName;
      NumberTxt.String = pure Contact.PhoneNumber;   
      UserInitialsBtn.Initials =  pure Contact.NameInitials;
      FavoritTxt.Visible  =  pure Contact.Favorite ? true : false;  
    }

  }

  $rect <790,50,980,90>
  property Device::Contact Contact;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <266,287>;
    preset Point1 = <8,287>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text NumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <20,258,264,287>;
    preset ColorBR = #FFFFFF00;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = " +0749320298";
    preset Font = Res::ContactFont15;
    preset Color = Res::Blue;
  }

  $rect <20,20,160,60>
  object Views::Text MobileTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <8,232,266,265>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::MobileTxt;
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <266,232>;
    preset Point1 = <8,232>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumBlue CallBtn
  {
    preset Bounds = <51,145,101,220>;
    preset OnActivate = onTapCall;
    preset Icon = Res::CallTxt;
    preset Descrip = Strings::callTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumBlue VideoCallBtn
  {
    preset Bounds = <111,145,161,220>;
    preset Enabled = false;
    preset Icon = Res::VideoCallTxt;
    preset Descrip = Strings::VideoTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumBlue PushButtonMediumBlue2
  {
    preset Bounds = <171,145,221,220>;
    preset Enabled = false;
    preset Icon = Res::MessageIconTxt;
    preset Descrip = Strings::messageTxt;
  }

  $rect <20,20,160,60>
  object Views::Text ContactName
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <8,98,265,145>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont29;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::PushButtonBig UserInitialsBtn
  {
    preset Bounds = <101,22,171,113>;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground EditBtn
  {
    preset Bounds = <240,4,265,29>;
    preset OnActivate = onTapEdit;
    preset Icon = Res::EditIconTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground BackBtn
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onBack;
    preset Icon = Res::BackIconTxt;
  }

  $rect <20,20,160,60>
  object Views::Text FavoritTxt
  {
    preset Bounds = <60,233,84,263>;
    preset String = Res::HeartTxt;
    preset Font = Res::IconsFont20;
    preset Color = Res::Grey;
    preset Visible = false;
  }
}

$rect <270,320,430,360>
$output false
class ContactAddPage : Core::Group
{
  $rect <0,450,200,490>
  inherited property Bounds = <0,0,272,440>;

  $rect <760,50,960,90>
  inherited method UpdateViewState()
  {
    // Always give the ancestor class a chance to process this event.
    super( aState );

    if(Contact)
    {

    if (FirstNameTxt.String != "" ||
        LastNameTxt.String != "" ||
        PhoneNumberTxt.String !=  "")
    {
      SaveBtn.Enabled = true;
    }

    else
     SaveBtn.Enabled = false;
     }
     
  }

  $rect <311,50,511,90>
  slot onSave
  {
    notifyobservers pure Contact;
    signal OnSave;
  }

  $rect <521,50,721,90>
  property slot OnSave;

  $rect <310,190,510,230>
  property Device::Contact Contact;

  $rect <310,230,510,270>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }
  }

  $rect <310,270,510,310>
  slot onContactUpdated
  {
    Contact.FirstName    = FirstNameTxt.String;
    Contact.LastName     = LastNameTxt.String;
    Contact.PhoneNumber  = PhoneNumberTxt.String;
    Contact.NameInitials = Device::Device.Contacts.GetInitials( LastNameTxt.String, FirstNameTxt.String);

    if ( Contact.LastName == "" &&  Contact.FirstName == "")
      Contact.LastName =  Contact.PhoneNumber;


         



  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,140,740,340>;
  }

  $rect <311,91,511,131>
  slot onClose
  {
    signal OnClose;
  }

  $rect <521,91,721,131>
  property slot OnClose;

  // Touch screen events
  note group Note
  {
    attr Bounds = <291,0,740,140>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <265,289>;
    preset Point1 = <7,289>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt PhoneNumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,257,269,289>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Blue;
    preset Placeholder = "Mobile number";
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <264,256>;
    preset Point1 = <6,256>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt FirstNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,224,269,256>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "First Name";
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <264,223>;
    preset Point1 = <6,223>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt LastNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,191,269,223>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "Last Name";
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <264,190>;
    preset Point1 = <6,190>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::PushButtonBig UserInitials
  {
    preset Bounds = <100,78,170,169>;
    preset Descript = Strings::AddPhototTxt;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <86,7,186,37>;
    preset String = Strings::NewContactTxt;
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground SaveBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Enabled = false;
    preset OnActivate = onSave;
    preset Icon = Res::CkeckIconTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground CloseButton
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onClose;
    preset Icon = Res::CloseIconTxt;
  }

  $rect <530,270,730,310>
  slot onFieldChanged
  {
    UserInitials.Initials = Device::Device.Contacts.GetInitials( LastNameTxt.String, FirstNameTxt.String );
    InvalidateViewState();
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,0,970,140>;
  }
}

$rect <270,280,430,320>
$output false
class ContactEditPage : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,440>;

  $rect <760,60,960,100>
  inherited method UpdateViewState()
  {
    // Always give the ancestor class a chance to process this event.
    super( aState );

    if(Contact)
    {

    if (Contact.FirstName != FirstNameTxt.String ||
        Contact.LastName != LastNameTxt.String ||
        Contact.PhoneNumber !=  NumberTxt.String)
    {
      SaveBtn.Enabled = true;
    }

    else
     SaveBtn.Enabled = false;
     }
     
  }

  $rect <310,50,510,90>
  slot onSave
  {
    Contact.FirstName    = FirstNameTxt.String; 
    Contact.LastName     = LastNameTxt.String;
    Contact.PhoneNumber  = NumberTxt.String;
    Contact.NameInitials = Device::Device.Contacts.GetInitials( Contact.LastName, Contact.FirstName );

    signal OnSave;
  }

  $rect <520,50,720,90>
  property slot OnSave;

  $rect <310,91,510,131>
  slot onClose
  {
    signal OnClose;
  }

  $rect <520,91,720,131>
  property slot OnClose;

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,740,190>;
  }

  $rect <310,130,510,170>
  slot onDeleteContact
  {
    Device::Device.Contacts.Remove( Contact );
    signal OnDelete;
  }

  $rect <310,290,510,330>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <310,330,510,370>
  slot onContactUpdated
  {
    if ( Contact != null )
    {
      FirstNameTxt.String = Contact.FirstName;
      LastNameTxt.String  = Contact.LastName;
      NumberTxt.String    = Contact.PhoneNumber;  
      UserInitials.Initials  = Contact.NameInitials;
    }

  }

  $rect <310,250,510,290>
  property Device::Contact Contact;

  $rect <520,130,720,170>
  property slot OnDelete;

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,200,740,390>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Components::PushButtonDelete DeleteBtn
  {
    preset Bounds = <5,398,263,431>;
    preset Enabled = true;
    preset OnActivate = onDeleteContact;
    preset Label = Strings::DeleteContactTxt;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt NumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <7,244,265,273>;
    preset OnChange = onFieldModified;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0749320267";
    preset Color = Res::Blue;
    preset Font = Res::ContactFont15;
    preset Placeholder = "0749320267";
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <264,239>;
    preset Point1 = <6,239>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text MobileTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <6,207,264,240>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::MobileTxt;
    preset Font = Res::ContactFont15;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <263,206>;
    preset Point1 = <5,206>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt FirstNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <2,174,268,206>;
    preset OnChange = onFieldModified;
    preset String = "First name";
    preset Color = Res::Black;
    preset Placeholder = "First name";
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <263,173>;
    preset Point1 = <5,173>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt LastNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <2,141,268,173>;
    preset OnChange = onFieldModified;
    preset String = "Last name";
    preset Color = Res::Black;
    preset Placeholder = "Last name";
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <263,140>;
    preset Point1 = <5,140>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::PushButtonBig UserInitials
  {
    preset Bounds = <99,29,169,120>;
    preset Initials = "";
    preset Descript = Strings::AddPhototTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground CloseBtn
  {
    preset Bounds = <7,4,32,29>;
    preset OnActivate = onClose;
    preset Icon = Res::CloseIconTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground SaveBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Enabled = false;
    preset OnActivate = onSave;
    preset Icon = Res::CkeckIconTxt;
  }

  $rect <530,330,730,370>
  slot onFieldModified
  {
    UserInitials.Initials = Device::Device.Contacts.GetInitials( Contact.LastName, Contact.FirstName );
    InvalidateViewState();
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,0,970,140>;
  }
}

$rect <30,190,210,230>
$output false
class CallPage : Application::CallPageBase
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,480>;

  $rect <300,150,500,190>
  inherited slot onContactUpdated
  {
    if (  Contact.CallState == Device::CallState.Speaking )
    {
      AddCallBtn.Enabled = true;
      VideoCallBtn.Enabled = true;
    } 

    super( sender );
  }

  $rect <20,20,160,60>
  inherited object DesclineButton
  {
    preset Bounds = <104,374,169,466>;
  }

  $rect <500,520,700,560>
  slot onSpeakerPress
  {
    //if button is pressed it changes sate from start/stop and icon PlayIcon/StopIcon

    Device::Device.Speaker =! Device::Device.Speaker;

    SpeakerBtn.ButtonColor = Device::Device.Speaker ? Res::White : Res::WhiteTransparent;
    SpeakerBtn.IconColor   = Device::Device.Speaker ? Res::Black : Res::White ;
  }

  $rect <500,480,700,520>
  slot onMicPress
  {
    //if button is pressed it changes sate from start/stop and icon PlayIcon/StopIcon

    Device::Device.Microphone = ! Device::Device.Microphone;

    MuteBtn.ButtonColor = Device::Device.Microphone ? Res::White : Res::WhiteTransparent;
    MuteBtn.IconColor   = Device::Device.Microphone ? Res::Black : Res::White;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,710,640>;
  }

  $rect <700,370,900,410>
  slot onKeypadPress
  {
    Keypad.Bounds.origin =< 0, 30>;

    Keypad.OnHide = onHide;


  }

  $rect <500,340,700,380>
  slot onAddCallPress
  {
    addCall = new Application::ContactsAppInsideCall;

    addCall.OnCancel = onCancel1;

    PresentDialog( addCall, Res::SlideUpCenteredLimit, null, null, null, null, null, null, null, false );
  }

  $rect <300,520,500,560>
  slot onVideoCallPress
  {
    sender; /* the method is called from the sender object */
  }

  $rect <510,250,700,290>
  slot onContactsPress
  {
    contactsPage = new Application::ContactsInsideCall;

    contactsPage.OnCancel = onCancel; 

    SwitchToDialog( contactsPage, Res::SlideUpCenteredLimit, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumTrans ContactsBtn
  {
    preset Bounds = <182,240,247,332>;
    preset OnActivate = onContactsPress;
    preset Icon = Res::UserIconTxt;
    preset Descript = Strings::contactsTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumTrans VideoCallBtn
  {
    preset Bounds = <104,241,169,333>;
    preset Enabled = false;
    preset OnActivate = onVideoCallPress;
    preset Icon = Res::VideoCallTxt;
    preset Descript = Strings::videocallTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumTrans AddCallBtn
  {
    preset Bounds = <26,242,91,334>;
    preset Enabled = false;
    preset OnActivate = onAddCallPress;
    preset Icon = Res::PlusIconTxt;
    preset Descript = Strings::addcallTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumTrans SpeakerBtn
  {
    preset Bounds = <182,147,247,239>;
    preset OnActivate = onSpeakerPress;
    preset Icon = Res::SpeakerTxt;
    preset Descript = Strings::speakerTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumTrans KeyPadBtn
  {
    preset Bounds = <104,148,169,240>;
    preset OnActivate = onKeypadPress;
    preset Icon = Res::KeypadTxt;
    preset Descript = Strings::keypadTxt;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumTrans MuteBtn
  {
    preset Bounds = <26,149,91,241>;
    preset OnActivate = onMicPress;
    preset Icon = Res::MicOffTxt;
    preset Descript = Strings::muteTxt;
  }

  $rect <300,250,500,290>
  var Application::ContactsInsideCall contactsPage = null;

  $rect <520,290,690,330>
  slot onCancel
  {
    DismissDialog( contactsPage, Res::SlideDownCentered, null, null, null, null, false);

    contactsPage = null;
  }

  $rect <730,450,900,490>
  slot onHide
  {
    Keypad.Bounds.origin.y = Bounds.y2;

    Keypad.InputEtxt.String = "";
    ContactNameTxt.Visible  = true;
    TimeTxt.Visible         = true;
    UserInitials.Visible    = true;

  }

  $rect <20,20,160,60>
  object Application::KeypadInsideCall Keypad
  {
    preset Bounds = <0,518,272,958>;
    preset HideFunction = false;
    preset HideCall = true;
    preset OnEditTextChanged = onKeypadEdit;
  }

  $rect <700,410,900,450>
  slot onKeypadEdit
  {
    ContactNameTxt.Visible = Keypad.InputEtxt.String == "";
    TimeTxt.Visible        = Keypad.InputEtxt.String == "";
    UserInitials.Visible   = Keypad.InputEtxt.String == "";
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,710,200>;
  }

  $rect <300,340,500,380>
  var Application::ContactsAppInsideCall addCall = null;

  $rect <530,380,700,420>
  slot onCancel1
  {
    DismissDialog( addCall, Res::SlideDownCentered, null, null, null, null, false);

    addCall = null;
  }
}

$rect <50,270,210,310>
$output false
class DetailsInsideCall : Application::ContactDetailsPage
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,440>;

  $rect <490,20,690,60>
  inherited slot onTapEdit
  {
    editContact = new Application::ContactEditPage;

    editContact.OnSave  = onSaveEdit;
    editContact.OnClose = onCancelEdit;
    editContact.Contact = Contact;
    editContact.OnDelete = onDelete;

    SwitchToDialog( editContact, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );
     



  }

  $rect <290,20,490,60>
  inherited var editContact;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  inherited object Line2
  {
    preset Point2 = <264,311>;
    preset Point1 = <6,311>;
  }

  $rect <20,20,160,60>
  inherited object NumberTxt
  {
    preset Bounds = <18,282,262,311>;
  }

  $rect <20,20,160,60>
  inherited object MobileTxt
  {
    preset Bounds = <6,256,264,289>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <264,256>;
    preset Point1 = <6,256>;
  }

  $rect <20,20,160,60>
  inherited object CallBtn
  {
    preset Bounds = <50,161,100,236>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  inherited object VideoCallBtn
  {
    preset Bounds = <110,161,160,236>;
  }

  $rect <20,20,160,60>
  inherited object PushButtonMediumBlue2
  {
    preset Bounds = <170,161,220,236>;
  }

  $rect <20,20,160,60>
  inherited object ContactName
  {
    preset Bounds = <10,114,267,144>;
  }

  $rect <20,20,160,60>
  inherited object UserInitialsBtn
  {
    preset Bounds = <100,30,170,121>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  inherited object EditBtn
  {
    preset Bounds = <239,5,264,30>;
  }

  $rect <20,20,160,60>
  inherited object BackBtn
  {
    preset Bounds = <6,5,31,30>;
  }
}

$rect <790,160,970,200>
$output false
class KeypadPage : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272, 440>;

  $rect <760,40,960,80>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);

    if ( HideFunction == false)
    {
      HideBtn.Visible= true;
    }

    if ( HideFunction == true)
    {
      HideBtn.Visible= false;
    }

    if ( HideCall == false)
    {
      callbtn.Visible= true;
    }

    if ( HideCall == true)
    {
      callbtn.Visible= false;
    }


    if ( !isEnabled )
    {
      Background.Color = Res::Grey;
    }

    // Enabled but not pressed nor selected.
    else
    {
       Background.Color = BackgoundColor;
    }


  }

  $rect <300,60,500,100>
  property slot OnHide;

  $rect <500,60,700,100>
  slot onHide
  {
    postsignal OnHide;
  }

  $rect <760,90,960,130>
  property color BackgoundColor = Res::White;

  $rect <960,90,1160,130>
  onset BackgoundColor
  {
    // The value doesn't change - nothing to do.
    if ( pure BackgoundColor == value )
      return;

    // Remember the property's new value.
    pure BackgoundColor = value;

    InvalidateViewState();
  }

  $rect <760,130,960,170>
  property bool HideFunction = true;

  $rect <960,130,1160,170>
  onset HideFunction
  {
    // The value doesn't change - nothing to do.
    if ( pure HideFunction == value )
      return;

    // Remember the property's new value.
    pure HideFunction = value;

    InvalidateViewState();
  }

  $rect <300,110,500,150>
  slot onButtonsPress
  {
    var Components::KeyPadButtons b = (Components::KeyPadButtons)sender;

    if ( sender == BtnErase)
      InputEtxt.String = InputEtxt.String.remove( InputEtxt.String.length-1, 1);
    else if ( b != null )
    {
      InputEtxt.String += b.Text;
    }

    signal OnEditTextChanged;        

  }

  $rect <760,170,960,210>
  property bool HideCall = false;

  $rect <960,170,1160,210>
  onset HideCall
  {
    // The value doesn't change - nothing to do.
    if ( pure HideCall == value )
      return;

    // Remember the property's new value.
    pure HideCall = value;

    InvalidateViewState();
  }

  $rect <300,150,500,190>
  slot onCallPress
  {
    if( InputEtxt.String != "")
    {
      Device::Device.OutgoingCallNumber( InputEtxt.String );

    }
  }

  $rect <300,220,500,260>
  property slot OnEditTextChanged = null;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons callbtn
  {
    preset Bounds = <104,340,169,405>;
    preset Icon = Res::CallTxt;
    preset ButtonColor = Res::GreenDark;
    preset OnActivate = onCallPress;
    preset ButtonColorPressed = Res::Green;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons BtnErase
  {
    preset Bounds = <169,340,234,405>;
    preset Icon = Res::BackspaceTxt;
    preset Text = "";
    preset ButtonColor = Res::Transparent;
    preset IconColor = Res::Black;
    preset OnActivate = onButtonsPress;
    preset ButtonColorPressed = Res::Transparent;
    preset IconColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn1
  {
    preset Bounds = <39,80,104,145>;
    preset Text = "1";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn3
  {
    preset Bounds = <169,80,234,145>;
    preset Text = "3";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn2
  {
    preset Bounds = <104,80,169,145>;
    preset Text = "2";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn4
  {
    preset Bounds = <39,145,104,210>;
    preset Text = "4";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn6
  {
    preset Bounds = <169,145,234,210>;
    preset Text = "6";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn5
  {
    preset Bounds = <104,145,169,210>;
    preset Text = "5";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn7
  {
    preset Bounds = <39,210,104,275>;
    preset Text = "7";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn9
  {
    preset Bounds = <169,210,234,275>;
    preset Text = "9";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn8
  {
    preset Bounds = <104,210,169,275>;
    preset Text = "8";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btnstar
  {
    preset Bounds = <39,275,104,340>;
    preset Text = "*";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btnDiez
  {
    preset Bounds = <169,275,234,340>;
    preset Text = "#";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::KeyPadButtons btn0
  {
    preset Bounds = <104,275,169,340>;
    preset Text = "0";
    preset ButtonColor = Res::GreyLight;
    preset OnActivate = onButtonsPress;
    preset TextColor = Res::Black;
    preset ButtonColorPressed = Res::PressColor;
    preset TextColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt InputEtxt
  {
    preset Bounds = <39,48,234,80>;
    preset String = "";
    preset Color = Res::Black;
    preset Font = Res::TitileFont25;
  }

  $rect <20,20,160,60>
  object Components::TextButton HideBtn
  {
    preset Bounds = <39,360,101,385>;
    preset Text = Strings::HideTxt;
    preset OnActivate = onHide;
    preset TextColor = Res::Black;
    preset TextColorPress = Res::Grey;
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,0,1170,220>;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,740,280>;
  }
}

// This is the root component of the entire GUI application.
$rect <440,110,640,150>
$output false
class ContactsApp : Core::Group
{
  $rect <300,40,480,80>
  inherited method Init()
  {
    SelectedPage = 2;
  }

  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  object Core::Group Outline
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,440,272,480>;
  }

  $rect <20,20,160,60>
  object Components::NavBarButtons NavBarButtons
  {
    preset Bounds = <0,440,68,480>;
    preset Icon = Res::HeartTxt;
    preset Descript = Strings::FavoritesTxt;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Components::NavBarButtons NavBarButtons1
  {
    preset Bounds = <68,440,136,480>;
    preset Icon = Res::CallTxt;
    preset Descript = Strings::RecentTxt;
    preset OutletSelector = 1;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Components::NavBarButtons NavBarButtons2
  {
    preset Bounds = <136,440,204,480>;
    preset Icon = Res::UserIconTxt;
    preset Descript = Strings::ContactsTxtx;
    preset OutletSelector = 2;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Components::NavBarButtons NavBarButtons3
  {
    preset Bounds = <204,440,272,480>;
    preset Icon = Res::KeypadTxt;
    preset Descript = Strings::KeypadTxt;
    preset OutletSelector = 3;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <270,440>;
    preset Point1 = <0,440>;
    preset Color = Res::Grey;
  }

  $rect <300,90,500,130>
  property int32 SelectedPage = -1;

  $rect <300,130,500,170>
  onset SelectedPage
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedPage == value )
      return;

    // Remember the property's new value.
    pure SelectedPage = value;

    notifyobservers ^SelectedPage;

    switch ( pure SelectedPage )
    {
      case 0: 
      {
        var Core::Group favorites = new Application::FavoritesPage;
        Outline.SwitchToDialog( favorites, null, null, null, null, null, null, null, null, null,false );
      }
      case 1: 
      {
        var Core::Group recent = new Application::RecentPage;
        Outline.SwitchToDialog( recent, null, null, null, null, null, null, null, null, null,false );
      }
      case 2: 
      {
        var Core::Group contacts = new Application::ContactsPage;
        Outline.SwitchToDialog( contacts, null, null, null, null, null, null, null, null, null,false );
      }
      case 3: 
      {
        var Core::Group keypad = new Application::KeypadPage;
        Outline.SwitchToDialog( keypad, null, null, null, null, null, null,
                                null, null, null,false );
      }

      default:
        trace "ERROR: invalid selected page ", pure SelectedPage;
    }

  }

  $rect <300,170,500,210>
  onget SelectedPage
  {
    return pure SelectedPage;
  }

  // Initialization
  note group Note
  {
    attr Bounds = <290,0,510,230>;
  }
}

$rect <10,50,210,90>
$output false
class Application : Core::Root
{
  $rect <290,40,490,80>
  inherited method Init()
  {
    attachobserver onCallState, ^Device::Device.Ongoing.NoOfItems;
    postsignal onCallState;


  }

  $rect <290,0,490,40>
  inherited property Bounds = <0,0,272,480>;

  // To do:
  // 
  // - Adjust the visible size of your application (the thick blue border). It should \
  // correspond to the size of your target display.
  // 
  // - The simplest way to compose the appearance of the application is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To store values use the 'Variable', 'Array' and 'Property' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  note legend Note1
  {
    attr Bounds = <10,510,790,740>;
  }

  $rect <290,80,490,120>
  slot onCallState
  {
    if ( historyContact != null)
      detachobserver onCallState, historyContact;

    historyContact = (Device::HistoryContact)Device::Device.Ongoing.GetContact( 0 );

    if ( ongoingPage != null )
    {
      DismissDialog( ongoingPage, Res::FadeInOutCentered, null, null, null, null, false );
      ongoingPage = null;
    }  

    if ( historyContact != null )
    {
      if ( historyContact.CallDirection == Device::CallDirection.Incoming )
      {
        if ( historyContact.CallState == Device::CallState.Speaking )
        {
          ongoingPage = new Application::CallPage;
          ongoingPage.Contact = historyContact;
        }
        else
        {
          ongoingPage = new Application::IncomingCall;
          ongoingPage.Contact = historyContact;
        }
        
        PresentDialog( ongoingPage, Res::FadeInOutCentered, null, null, null, null, null, null, null, false );
      }
      else if ( historyContact.CallDirection == Device::CallDirection.Outgoing )
      {
        ongoingPage = new Application::CallPage;
        ongoingPage.Contact = historyContact;
        PresentDialog( ongoingPage, Res::FadeInOutCentered, null, null, null, null, null, null, null, false );
      }
      attachobserver onCallState, historyContact;
      
    }





  }

  $rect <520,40,720,80>
  var Device::DeviceClass deviceInstance = Device::Device;

  $rect <20,20,160,60>
  object Application::ContactsApp ContactsApp
  {
    preset Bounds = <0,0,272,480>;
  }

  $rect <320,120,490,160>
  var Application::CallPageBase ongoingPage = null;

  $rect <490,120,690,160>
  var Device::HistoryContact historyContact = null;
}

$rect <50,310,210,350>
$output false
class KeypadInsideCall : Application::KeypadPage
{
  $rect <20,20,160,60>
  inherited object Background
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle BackgroundSmall
  {
    preset Bounds = <0,80,272,340>;
    preset ColorBL = #838383FA;
    preset ColorBR = #4F4F4FFF;
    preset ColorTR = #898989FF;
    preset ColorTL = #898989FF;
    preset Color = #3C3C3CFF;
  }

  $rect <20,20,160,60>
  inherited object callbtn
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  inherited object BtnErase
  {
    preset Text = "";
    preset IconColor = Res::White;
    preset ButtonColorPressed = Res::Transparent;
  }

  $rect <20,20,160,60>
  inherited object btn1
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn3
  {
    preset Enabled = true;
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn2
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn4
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn6
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn5
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn7
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn9
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn8
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btnstar
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btnDiez
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object btn0
  {
    preset ButtonColor = Res::WhiteTransparent;
    preset IconColor = Res::White;
    preset TextColor = Res::White;
    preset ButtonColorPressed = Res::WhiteSemiTransparent;
    preset TextColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  inherited object InputEtxt
  {
    preset Bounds = <39,32,234,64>;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  inherited object HideBtn
  {
    preset TextColor = Res::White;
  }

  $reorder BackgroundSmall 16
}

$rect <50,230,210,270>
$output false
class ContactsInsideCall : Application::ContactsPage
{
  $rect <290,110,490,150>
  inherited var detailsPage;

  $rect <20,20,160,60>
  inherited object Background;

  $rect <20,20,160,60>
  inherited object VerticalList;

  $rect <20,20,160,60>
  inherited object SlideTouchHandler;

  $rect <20,20,160,60>
  inherited object UpButton;

  $rect <20,20,160,60>
  inherited object DownButton;

  $rect <20,20,160,60>
  inherited object SearchExt;

  $rect <20,20,160,60>
  inherited object TitleTxt
  {
    preset Bounds = <11,12,261,61>;
    preset Font = Res::ContactFontBold15;
  }

  $rect <20,20,160,60>
  inherited object PlusButton
  {
    preset Bounds = <166,12,196,42>;
  }

  $rect <490,110,690,150>
  inherited slot onContactActivated
  {
    var Application::ContactItem itemView = (Application::ContactItem)sender;

    if ( itemView != null )
    {
      detailsPage = new Application::DetailsInsideCall;
      detailsPage.OnBack = onCloseContact;
      detailsPage.OnDelete = onDeleteContact;

      detailsPage.Contact = itemView.Contact;
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }

  }

  $rect <20,20,160,60>
  object Components::TextButton TextButton
  {
    preset Bounds = <196,15,262,40>;
    preset Text = Strings::CancelTxt;
    preset OnActivate = onCancel;
  }

  $rect <290,0,490,40>
  property slot OnCancel;

  $rect <490,0,690,40>
  slot onCancel
  {
    postsignal OnCancel;
  }
}

$rect <1010,47,1210,87>
$variant Simulation
vclass ApplicationSimulation : Application::Application
{
  $rect <810,0,1010,40>
  inherited property Bounds = <0,0,800,480>;

  $rect <20,20,160,60>
  object WidgetSet::PushButton PushButton
  {
    preset Bounds = <421,155,571,205>;
    preset OnActivate = onIncomingCall;
    preset Label = "Incoming call";
    preset Appearance = WidgetSet::PushButton_Medium;
  }

  $rect <844,104,1044,144>
  slot onIncomingCall
  {
    Device::Device.UpdateIncomingCall( "+40723494923" );
  }
}

$rect <1010,90,1260,130>
$output false
autoobject Effects::FadeInOutTransition FadeInOutTransition
{
  preset MarginTop = 30;
  preset Alignment = Effects::DialogAlignment[AlignHorzLeft];
}

// Simulation
note group Note4
{
  attr Bounds = <990,0,1280,200>;
}

$rect <30,150,210,190>
$output false
class IncomingCall : Application::CallPageBase
{
  $rect <300,40,500,80>
  inherited method Init()
  {
    /*attachobserver onCallState, ^Device::Device.CallState;
    postsignal onCallState;

    postsignal updateCurrentTime;
    */
    //getContact();


  }

  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  inherited object DesclineButton;

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,760,320>;
  }

  $rect <310,260,510,300>
  slot onAcceptCall
  {
    Device::Device.AnswerCall( Contact );
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumTrans AcceptButton
  {
    preset Bounds = <171,340,236,432>;
    preset OnActivate = onAcceptCall;
    preset Icon = Res::CallTxt;
    preset Descript = Strings::acceptTxt;
    preset ButtonColor = Res::GreenDark;
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,760,200>;
  }

  $reorder Note 2
  $reorder onAcceptCall 2
  $reorder AcceptButton 2
  $reorder Note2 2
}

// The global autoobject Effects::SlideUpCentered represents the fade-in/out operation \
// affecting the position and the opacity of the given GUI component. When using \
// the transition for the fade-in operation, the GUI component slides from the bottom \
// edge of its owner component and continues moving vertically until it reaches the \
// owner's center position. When using the transition for the fade-out operation, \
// the component slides up until it leaves the visible area of its owner component. \
// Additionally, while the transitions are performed, the opacity of the GUI component \
// fades-in or fades-out accordingly. This transition is thus ideal wherever one \
// GUI component should smoothly slide-in/out in context of another component. The \
// duration of the transition is configured per default to take 500 ms and the timing \
// is configured to start fast and then slow down the animation (FastIn_EaseOut).
// This object exists for your convenience permitting you to simply refer the transition \
// wherever it is required in your implementation without having to take care of \
// the creation and configuration of the object. If you require the transition to \
// run with other configuration (e.g. other timing parameters), create a copy of \
// this object and adapt its properties accordingly.
$rect <1020,140,1270,180>
$output false
autoobject Effects::SlideTransition SlideUpCentered
{
  preset MarginTop = 40;
  preset Direction = Core::Direction.Top;
}

$rect <610,160,790,200>
$output false
class FavoritesPage : Core::Group
{
  $rect <290,50,470,90>
  inherited method Init()
  {
    attachobserver onNoOfContactsChanged, ^Device::Device.Favorites.NoOfItems;
    postsignal onNoOfContactsChanged;
  }

  $rect <0,450,190,490>
  inherited property Bounds = <0,0,272,440>;

  $rect <470,260,660,300>
  slot onAddPress
  {
    addFav = new Application::ContactsList;

    addFav.OnCancel      = onClose;
    addFav.OnAddFav      = onAdd;
    addFav.Contact = new Device::Contact;

    SwitchToDialog( addFav, Res::SlideUpCentered, null, null, null, null, null, null, null, null, false );

  }

  $rect <290,260,470,300>
  var Application::ContactsList addFav = null;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <820,60,1020,100>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var int32 itemNo = VerticalList.Item;

    var Device::Contact contact = Device::Device.Favorites.GetContact( itemNo );

    var Application::FavContactItem itemView = (Application::FavContactItem)VerticalList.View;
    Contact = itemView.Contact;
                                                  
    if ( itemView == null )
      return;

    itemView.Contact    = contact;
    itemView.OnActivate = onPressedContact;
    itemView.OnDelete   = onDeleteContact;
    itemView.OnInfo     = onInfoContact;  
    itemView.EditMode   = EditMode;


    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );


  }

  $rect <850,100,1020,140>
  slot onPressedContact
  {
    Contact = (( Application::FavContactItem ) sender ).Contact;

    Device::Device.OutgoingCallContact( Contact );

    Contact = null;

  }

  $rect <490,300,660,340>
  slot onClose
  {
    DismissDialog( addFav, Res::SlideDownCentered, null, null, null, null, false );

  }

  $rect <290,90,470,130>
  slot onNoOfContactsChanged
  {
    VerticalList.NoOfItems = Device::Device.Favorites.NoOfItems;

  }

  $rect <490,50,660,90>
  property Device::Contact Contact = null;

  $rect <490,90,660,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    // Remember the property's new value.
    pure Contact = value;

    notifyobservers ^Contact; 
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <280,170,670,390>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <11,95,261,408>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 32;
    preset ItemClass = Application::FavContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -2;
    preset Bounds = <11,95,261,408>;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt1
  {
    preset Bounds = <11,42,261,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::FavoritesTxt;
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::PushButtonNoBackground PlusButton
  {
    preset Bounds = <11,12,41,42>;
    preset Enabled = true;
    preset OnActivate = onAddPress;
    preset Icon = Res::PlusIconTxt;
  }

  $rect <20,20,160,60>
  object Components::TextButton TextButton
  {
    preset Bounds = <213,12,263,37>;
    preset Text = Strings::EditTxt;
    preset OnActivate = onEdit;
  }

  $rect <690,180,850,220>
  var Application::ContactDetailsPage detailsPage;

  $rect <850,180,1020,220>
  slot onInfoContact
  {
    detailsPage         = new Application::ContactDetailsPage;
    detailsPage.Contact = (( Application::FavContactItem ) sender ).Contact;
    detailsPage.OnBack  = onCloseDetailsPage;

    SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null, null, null, null, false );


  }

  $rect <850,140,1020,180>
  slot onDeleteContact
  {
    Contact = (( Application::FavContactItem ) sender ).Contact;
    var Device::Contact contact = Device::Device.Contacts.FindByID( Contact );

    if ( contact != null)
      contact.Favorite = false;

    Device::Device.Favorites.Remove( Contact );

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );

    Contact = null;
  }

  $rect <870,220,1020,260>
  slot onCloseDetailsPage
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false );

    Contact = null;
  }

  // Vertical list
  note group Note2
  {
    attr Bounds = <680,0,1030,390>;
  }

  // Initialization
  note group Note3
  {
    attr Bounds = <280,0,670,170>;
  }

  $rect <480,210,660,250>
  property bool EditMode = false;

  $rect <290,210,480,250>
  slot onEdit
  {
    EditMode = !EditMode;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
  }

  $rect <490,340,660,380>
  slot onAdd
  {
    Device::Device.Favorites.AddLast ( addFav.Contact );
    VerticalList.InvalidateItems ( 0, VerticalList.NoOfItems -1 );

    DismissDialog ( addFav, Res::SlideDownCentered, null, null, null, null, false );
                               
    addFav = null;

  }
}

$rect <430,160,610,200>
$output false
class RecentPage : Core::Group
{
  $rect <290,40,480,80>
  inherited method Init()
  {
    attachobserver onNoOfContactsChanged, ^Device::Device.History.NoOfItems;
    postsignal onNoOfContactsChanged;
  }

  $rect <0,460,190,500>
  inherited property Bounds = <0,0,272,440>;

  $rect <0,570,200,610>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,530,200,570>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt1
  {
    preset Bounds = <11,42,261,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::RecentTxt;
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::TextButton TextButton
  {
    preset Bounds = <213,12,263,37>;
    preset Text = Strings::EditTxt;
    preset OnActivate = onEdit;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <11,95,261,408>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 50;
    preset ItemClass = Application::RecentItm;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -1;
    preset Bounds = <11,95,261,408>;
    preset SlideHorz = false;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <690,40,890,80>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var int32 itemNo = VerticalList.Item;

    var Device::HistoryContact contactHistory = (Device::HistoryContact )Device::Device.History.GetContact( itemNo );

    var Application::RecentItm itemView = (Application::RecentItm)VerticalList.View;
                                                  
    if ( itemView == null )
      return;

    if ( contactHistory != null )
    {
      itemView.ContactHistory = contactHistory;  
      itemView.EditMode = EditMode;
      itemView.OnActivate = onPressedContact;
      itemView.OnDelete = onDeleteContact;
      itemView.OnInfo = onInfoContact;
      
    }

    // Ensure that the item has correct size. The position of the item will be
    // managed by the list component.
    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );


  }

  $rect <290,80,480,120>
  slot onNoOfContactsChanged
  {
    VerticalList.NoOfItems = Device::Device.History.NoOfItems;

  }

  $rect <490,40,660,80>
  property Device::HistoryContact SelectedContact = null;

  $rect <490,80,660,120>
  onset SelectedContact
  {
    // The value doesn't change - nothing to do.
    if ( pure SelectedContact == value )
      return;

    // Remember the property's new value.
    pure SelectedContact = value;

    notifyobservers ^SelectedContact; 
  }

  $rect <290,230,470,270>
  property bool EditMode = false;

  $rect <470,230,650,270>
  slot onEdit
  {
    EditMode = !EditMode;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <280,180,670,280>;
  }

  // Vertical list
  note group Note2
  {
    attr Bounds = <680,0,1100,280>;
  }

  // Initialization
  note group Note3
  {
    attr Bounds = <280,0,670,170>;
  }

  $rect <720,80,890,120>
  slot onPressedContact
  {
    var Application::RecentItm itemView = (Application::RecentItm)sender;
    SelectedContact = itemView.ContactHistory;

    Device::Device.OutgoingCallContact( SelectedContact );

    SelectedContact = null;

  }

  $rect <900,160,1060,200>
  var Application::RecentDetailsPage detailsPage;

  $rect <720,160,890,200>
  slot onInfoContact
  {
    var Application::RecentItm itemView = (Application::RecentItm)sender;

    if ( itemView != null )
    {
      detailsPage = new Application::RecentDetailsPage;
      detailsPage.OnBack = onCloseDetailsPage;
      detailsPage.OnDelete = onCloseDetailsPage;

      detailsPage.HistoryContact = itemView.ContactHistory;
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }
  }

  $rect <720,120,890,160>
  slot onDeleteContact
  {
    var Application::RecentItm itemView = (Application::RecentItm)sender;
    SelectedContact = itemView.ContactHistory;

    Device::Device.History.Remove( SelectedContact );
    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );

    SelectedContact = null;
  }

  $rect <740,200,890,240>
  slot onCloseDetailsPage
  {
    VerticalList.InvalidateItems( 0, Device::Device.History.NoOfItems -1 );
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);

    SelectedContact = null;
  }
}

$rect <630,240,790,280>
$output false
class ContactsList : Application::ContactsInsideCall
{
  $rect <20,20,160,60>
  inherited object PlusButton
  {
    preset Visible = false;
  }

  $rect <520,240,720,280>
  inherited slot onContactActivated
  {
    //add contact to favorites
    Contact =  ((Application::ContactItem ) sender ).Contact;

    if ( Contact.Favorite == false )
    {
      Contact.Favorite = true;
      postsignal OnAddFav; 
    }
    else
    {
      trace "ERROR: Contact already in the list";
      postsignal OnCancel;
    }



  }

  $rect <20,20,160,60>
  inherited object TextButton
  {
    preset Bounds = <202,24,268,49>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <12,0,261,30>;
    preset String = Strings::AddToFavTxt;
    preset Font = Res::ContactFont12;
    preset Color = Res::Black;
  }

  $rect <310,240,510,280>
  property slot OnAddFav;

  $rect <310,50,510,90>
  property Device::Contact Contact = null;

  $rect <310,90,510,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    // Remember the property's new value.
    pure Contact = value;

    notifyobservers ^Contact; 
  }

  // Contact data
  note group Note4
  {
    attr Bounds = <290,0,520,190>;
  }

  // Touch screen events
  note group Note8
  {
    attr Bounds = <290,190,740,310>;
  }
}

$rect <630,200,789,240>
$output false
class FavContactItem : Application::ContactItem
{
  $rect <360,0,560,40>
  inherited property Bounds = <0,0,250,32>;

  $rect <10,230,170,270>
  object Effects::Int32Effect EditEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 25;
    preset Value1 = 0;
  }

  $rect <170,250,320,290>
  slot onAnimate
  {
    RemoveButton.Bounds.x    = EditEffect.Value - 25  - DeleteEffect.Value;
    PrfofilButton.Bounds.x   = EditEffect.Value + 6   - DeleteEffect.Value;
    LastNameTxt.Bounds.x     = EditEffect.Value + 55  - DeleteEffect.Value;
    FirstNameTxt.Bounds.x    = EditEffect.Value + 146 - DeleteEffect.Value;
    InfoButton.Bounds.x      = EditEffect.Value + 217  - DeleteEffect.Value;
    TouchHandler.Point1.x    = RemoveButton.Bounds.x2;
    TouchHandler.Point4.x    = RemoveButton.Bounds.x2;
    DeleteButton.Bounds.x    = EditEffect.Value + 273 - DeleteEffect.Value;
  }

  $rect <10,100,210,140>
  property bool EditMode = false;

  $rect <10,140,210,180>
  onset EditMode
  {
    // The value doesn't change - nothing to do.
    if ( pure EditMode == value )
      return;

    // Remember the property's new value.
    pure EditMode = value;

    EditEffect.Reversed = !EditMode;

    if ( EditMode )
    {
      InfoButton.Icon = Res::MenuTxt;
      InfoButton.IconColor = Res::Grey; 
    }
    else
    {
      InfoButton.Icon = Res::InfoTxt;
      InfoButton.IconColor = Res::Blue;
      
      if ( DeleteEffect.Enabled || DeleteEffect.Value == DeleteEffect.Value2 )
      {
        DeleteEffect.Reversed = true;
        signal DeleteEffect.StartEffect;
      }
    }

    signal EditEffect.StartEffect;



  }

  $rect <10,270,170,310>
  object Effects::Int32Effect DeleteEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 110;
    preset Value1 = 0;
  }

  $rect <350,150,550,190>
  slot onDelete
  {
    DeleteEffect.Reversed = true;
    signal DeleteEffect.StartEffect;
    postsignal OnDelete;
  }

  $rect <350,110,550,150>
  slot onShowDelete
  {
    DeleteEffect.Reversed = false;
    signal DeleteEffect.StartEffect;

  }

  $rect <550,150,750,190>
  property slot OnDelete;

  $rect <350,190,550,230>
  slot onInfo
  {
    signal OnInfo;
  }

  $rect <550,190,750,230>
  property slot OnInfo;

  $rect <20,20,160,60>
  inherited object TouchHandler
  {
    preset StackingPriority = -1;
    preset Point3 = <217,32>;
    preset Point2 = <217,0>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,250,32>;
  }

  $rect <20,20,160,60>
  object Components::PushButtonSmall RemoveButton
  {
    preset Bounds = <-25,5,0,30>;
    preset OnActivate = onShowDelete;
    preset ButtonColor = Res::Red;
    preset Icon = Res::RemoveTxt;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  object Components::TextButton DeleteButton
  {
    preset Bounds = <250,0,316,32>;
    preset Text = Strings::deleteTxt;
    preset OnActivate = onDelete;
    preset TextColor = Res::White;
    preset TextColorPress = Res::WhiteSemiTransparent;
    preset BackgoundColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Components::PushButtonSmall InfoButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <217,5,242,30>;
    preset OnActivate = onInfo;
    preset ButtonColor = Res::Transparent;
    preset Icon = Res::InfoTxt;
    preset IconColor = Res::Blue;
  }

  $rect <20,20,160,60>
  inherited object LastNameTxt
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <44,8,113,26>;
    preset AutoSize = true;
  }

  $rect <20,20,160,60>
  inherited object FirstNameTxt
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <131,8,201,26>;
    preset AutoSize = true;
    preset String = "FirstName";
  }

  $rect <20,20,160,60>
  inherited object Line
  {
    preset Point2 = <250,32>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  inherited object PrfofilButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <6,4,31,29>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <250,0>;
  }

  // Moving effect
  note group Note
  {
    attr Bounds = <0,190,330,330>;
  }

  // Initialization
  note group Note7
  {
    attr Bounds = <0,60,330,190>;
  }

  // Touch screen events
  note group Note8
  {
    attr Bounds = <340,60,800,320>;
  }

  $reorder EditEffect 11
  $reorder onAnimate 11
  $reorder EditMode 11
  $reorder OnSetEditMode 11
  $reorder DeleteEffect 11
  $reorder onDelete 11
  $reorder onShowDelete 11
  $reorder OnDelete 11
  $reorder onInfo 11
  $reorder OnInfo 11
  $reorder RemoveButton 5
  $reorder DeleteButton 5
  $reorder InfoButton 5
}

$rect <451,200,610,240>
$output false
class RecentItm : Core::Group
{
  $rect <30,450,230,490>
  inherited property Bounds = <0,0,250,50>;

  $rect <580,110,780,150>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    if (LastNameTxt != null )
    {
      var color clr = ColorText1;
      var Resources::Font font = Res::ContactFontBold15; 
      LastNameTxt.Font  = font;
      LastNameTxt.Color     = clr;
     }
    if (FirstNameTxt!= null)
    {
      var color clr = ColorText1;
      var Resources::Font font = Res::ContactFont15; 
      FirstNameTxt.Font = font;
      FirstNameTxt.Color = clr;
     }

    if (CallTypeTxt != null)
    {
      var color clr = ColorText2; 
      CallTypeTxt.Font = Res::ContactFont12;
      CallTypeTxt.Color = clr;
     }

    if (TimeTxt != null)
    {
      var color clr = ColorText2; 
      TimeTxt.Font = Res::ContactFont12;
      TimeTxt.Color = clr;
     }



    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
      PushButtonSmall.IconColor = Res::Grey;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
      
      PushButtonSmall.IconColor = Res::Grey;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GreyLight;
      
      PushButtonSmall.IconColor = Res::Grey;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
      
      PushButtonSmall.IconColor = Res::Grey;
    }




    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // Contact data
  note group Note4
  {
    attr Bounds = <570,330,790,520>;
  }

  // State management
  note group Note5
  {
    attr Bounds = <570,70,790,320>;
  }

  $rect <580,270,780,310>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <580,230,780,270>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <580,190,780,230>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <580,150,780,190>
  var bool enabled;

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <10,108,159,148>
  property string Icon = Res::OutgoingCallTxt;

  $rect <170,110,320,150>
  property string Text = "";

  $rect <170,150,320,190>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <10,270,159,310>
  property color ButtonColor = Res::White;

  $rect <10,310,159,350>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <10,188,159,228>
  property color IconColor = Res::White;

  $rect <10,228,159,268>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <340,390,560,520>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <340,250,560,380>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <340,70,560,240>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <350,430,550,470>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <350,290,550,330>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <350,470,550,510>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <350,330,550,370>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <10,148,159,188>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <350,190,550,230>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <350,150,550,190>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <10,378,159,418>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <350,110,550,150>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,250,52>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <25,52>;
    preset Point3 = <205,52>;
    preset Point2 = <205,0>;
    preset Point1 = <25,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <250,50>;
    preset Point1 = <0,50>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Views::Text LastNameTxt
  {
    preset Bounds = <32,4,114,22>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "LastName";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text FirstNameTxt
  {
    preset StackingPriority = 0;
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz];
    preset Bounds = <114,4,220,22>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "FirstName";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text CallTypeTxt
  {
    preset Bounds = <32,33,101,47>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Call type";
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Bounds = <162,22,220,36>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Time ";
    preset Font = Resources::DefaultFont;
  }

  $rect <170,190,320,230>
  property color ColorText1 = Res::Black;

  $rect <170,230,320,270>
  onset ColorText1
  {
    // The value doesn't change - nothing to do.
    if ( pure ColorText1 == value )
      return;

    // Remember the property's new value.
    pure ColorText1 = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <170,270,320,310>
  property color ColorText2 = Res::Grey;

  $rect <170,310,320,350>
  onset ColorText2
  {
    // The value doesn't change - nothing to do.
    if ( pure ColorText2 == value )
      return;

    // Remember the property's new value.
    pure ColorText2 = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Components::PushButtonSmall InfoButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <225,2,250,27>;
    preset OnActivate = onInfo;
    preset ButtonColor = Res::Transparent;
    preset Icon = Res::InfoTxt;
    preset IconColor = Res::Blue;
  }

  $rect <20,20,160,60>
  object Components::PushButtonSmall PushButtonSmall
  {
    preset Bounds = <0,17,25,42>;
    preset AlphaBlended = true;
    preset ButtonColor = Res::Transparent;
    preset TextColor = Res::Grey;
    preset Icon = Res::OutgoingCallTxt;
  }

  // Design
  note group Note6
  {
    attr Bounds = <0,70,330,520>;
  }

  $rect <20,20,160,60>
  object Components::PushButtonSmall RemoveButton
  {
    preset Bounds = <-25,11,0,36>;
    preset OnActivate = onShowDelete;
    preset ButtonColor = Res::Red;
    preset Icon = Res::RemoveTxt;
    preset IconColor = Res::White;
  }

  $rect <20,20,160,60>
  object Components::TextButton DeleteButton
  {
    preset Bounds = <250,1,316,51>;
    preset Text = Strings::deleteTxt;
    preset OnActivate = onDelete;
    preset TextColor = Res::White;
    preset TextColorPress = Res::WhiteSemiTransparent;
    preset BackgoundColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <250,0>;
    preset Point1 = <0,0>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <10,720,170,760>
  object Effects::Int32Effect EditEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 25;
    preset Value1 = 0;
  }

  $rect <180,740,320,780>
  slot onAnimate
  {
    RemoveButton.Bounds.x    = EditEffect.Value - 25  - DeleteEffect.Value;
    PushButtonSmall.Bounds.x = EditEffect.Value + 6   - DeleteEffect.Value;
    LastNameTxt.Bounds.x     = EditEffect.Value + 55  - DeleteEffect.Value;
    FirstNameTxt.Bounds.x    = EditEffect.Value + 146 - DeleteEffect.Value;
    CallTypeTxt.Bounds.x        = EditEffect.Value + 55 - DeleteEffect.Value;
    InfoButton.Bounds.x      = EditEffect.Value + 217  - DeleteEffect.Value;
    TimeTxt.Bounds.x            = EditEffect.Value + 192  - DeleteEffect.Value;
    TouchHandler.Point1.x    = RemoveButton.Bounds.x2;
    TouchHandler.Point4.x    = RemoveButton.Bounds.x2;
    DeleteButton.Bounds.x    = EditEffect.Value + 273 - DeleteEffect.Value;
  }

  $rect <10,570,210,610>
  property bool EditMode = false;

  $rect <10,610,210,650>
  onset EditMode
  {
    // The value doesn't change - nothing to do.
    if ( pure EditMode == value )
      return;

    // Remember the property's new value.
    pure EditMode = value;

    EditEffect.Reversed = !EditMode;

    if ( EditMode )
    {
      InfoButton.Visible = false;
    }
    else
    {
      InfoButton.Visible = true;
      
      if ( DeleteEffect.Enabled || DeleteEffect.Value == DeleteEffect.Value2 )
      {
        DeleteEffect.Reversed = true;
        signal DeleteEffect.StartEffect;
      }
    }

    signal EditEffect.StartEffect;



  }

  $rect <10,760,170,800>
  object Effects::Int32Effect DeleteEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 110;
    preset Value1 = 0;
  }

  // Moving effect
  note group Note
  {
    attr Bounds = <0,670,330,810>;
  }

  // Initialization
  note group Note7
  {
    attr Bounds = <0,530,330,660>;
  }

  $rect <350,620,520,660>
  slot onDelete
  {
    DeleteEffect.Reversed = true;
    signal DeleteEffect.StartEffect;
    postsignal OnDelete;
  }

  $rect <350,580,520,620>
  slot onShowDelete
  {
    DeleteEffect.Reversed = false;
    signal DeleteEffect.StartEffect;

  }

  $rect <520,620,690,660>
  property slot OnDelete;

  $rect <350,660,520,700>
  slot onInfo
  {
    postsignal OnInfo;
  }

  $rect <520,660,690,700>
  property slot OnInfo;

  // Touch screen events
  note group Note8
  {
    attr Bounds = <340,530,700,790>;
  }

  $rect <590,410,780,450>
  onset ContactHistory
  {
    // The value doesn't change - nothing to do.
    if ( pure ContactHistory == value )
      return;

    if ( pure ContactHistory != null )
    {
       detachobserver onContactRistoryUpdate, pure ContactHistory;
    }

    // Remember the property's new value.
    pure ContactHistory = value;

    if ( pure ContactHistory != null )
    {
      attachobserver onContactRistoryUpdate, pure ContactHistory;
      postsignal onContactRistoryUpdate;
    }

  }

  $rect <590,450,780,490>
  slot onContactRistoryUpdate
  {
    if ( pure ContactHistory != null )
    {
      LastNameTxt.String  =  pure ContactHistory.LastName;
      FirstNameTxt.String = pure ContactHistory.FirstName;
      
      if ( pure ContactHistory.CallDirection == Device::CallDirection.Incoming )
        PushButtonSmall.Icon = Res::IncomingCallTxt;
      else
        PushButtonSmall.Icon = Res::OutgoingCallTxt;
      
      CallTypeTxt.String  = pure ContactHistory.GetCallDirection();
      TimeTxt.String      = pure ContactHistory.GetTimeOfCall();
      
      if ( pure ContactHistory.CallState == Device::CallState.Missed )
      {
        ColorText1 = Res::Red;
       }
      else
        ColorText1 = Res::Black;
    }

  }

  $rect <590,370,780,410>
  property Device::HistoryContact ContactHistory = null;
}

$rect <450,240,610,280>
$output false
class RecentDetailsPage : Application::ContactDetailsPage
{
  $rect <320,130,520,170>
  inherited slot onContactUpdated
  {
    if ( pure HistoryContact != null )
    {
      UserInitialsBtn.Initials =  pure HistoryContact.NameInitials;
      ContactName.String        = pure HistoryContact.LastName + " " + pure HistoryContact.FirstName;
      NumberTxt.String          = pure HistoryContact.PhoneNumber; 
      
      DateTxt.String = pure HistoryContact.TimeOfCall.Format( "%d %m %Y" );
      TimeTxt.String = pure HistoryContact.TimeOfCall.Format( "%H:%M %p" );

      if (( HistoryContact.CallState == Device::CallState.EndCall ) &&
          (( HistoryContact.CallDirection == Device::CallDirection.Incoming) ||
           ( HistoryContact.CallDirection == Device::CallDirection.Outgoing )))
      {
        TypeTxt.String     = HistoryContact.GetCallDirection();
        DurationTxt.String = HistoryContact.GetDuration();
      }
      else
      {
        TypeTxt.String     = HistoryContact.GetCallState();
        DurationTxt.String = HistoryContact.GetDuration();
      } 
    }

  }

  $rect <20,20,160,60>
  inherited object Line2
  {
    preset Point2 = <265,371>;
    preset Point1 = <7,371>;
  }

  $rect <20,20,160,60>
  inherited object NumberTxt
  {
    preset Bounds = <19,342,263,371>;
  }

  $rect <20,20,160,60>
  inherited object MobileTxt
  {
    preset Bounds = <7,316,265,349>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <265,316>;
    preset Point1 = <7,316>;
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <265,237>;
    preset Point1 = <7,237>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text DateTxt
  {
    preset Bounds = <8,246,263,267>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "30 nov 2022";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text TypeTxt
  {
    preset Bounds = <67,267,263,289>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Outgoing Call";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Bounds = <7,267,67,289>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "5:37 PM";
    preset Font = Res::ContactFont12;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text DurationTxt
  {
    preset Bounds = <67,289,263,311>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "22 seconds";
    preset Font = Res::ContactFont12;
    preset Color = Res::Grey;
  }

  $rect <330,90,520,130>
  onset HistoryContact
  {
    // The value doesn't change - nothing to do.
    if ( pure HistoryContact == value )
      return;

    if ( pure HistoryContact != null )
    {
       detachobserver onContactUpdated, pure HistoryContact;
    }

    // Remember the property's new value.
    pure HistoryContact = value;

    if ( pure HistoryContact != null )
    {
      attachobserver onContactUpdated, pure HistoryContact;
      postsignal onContactUpdated;
    }

  }

  $rect <330,50,520,90>
  property Device::HistoryContact HistoryContact;

  // Contact data
  note group Note8
  {
    attr Bounds = <290,0,580,260>;
  }
}

$rect <10,110,210,150>
$output false
class CallPageBase : Core::Group
{
  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <310,120,510,160>
  slot onContactUpdated
  {
    //if the calling number is in the contact list display info
    if ( pure Contact != null )
    {
      ContactNameTxt.String  = pure Contact.LastName + " "  + pure Contact.FirstName;
      UserInitials.Initials = pure Contact.NameInitials; 
    }
    //if not display number and hide UserInitials
    else
    {
       ContactNameTxt.String = Device::Device.Ongoing.GetContact( 0 ).PhoneNumber;
       UserInitials.Visible = false;
    }

  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,-10,700,190>;
  }

  $rect <310,240,510,280>
  slot onDesclineCall
  {
    Device::Device.EndCall( Contact );
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,200,700,360>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,480>;
    preset ColorBL = #838383FA;
    preset ColorBR = #4F4F4FFF;
    preset ColorTR = #898989FF;
    preset ColorTL = #898989FF;
    preset Color = #3C3C3CFF;
  }

  $rect <20,20,160,60>
  object Components::PushButtonMediumTrans DesclineButton
  {
    preset Bounds = <36,340,101,432>;
    preset OnActivate = onDesclineCall;
    preset Icon = Res::EndCallTxt;
    preset Descript = Strings::declineTxt;
    preset ButtonColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <18,73,91,103>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "calling...";
    preset Font = Res::ContactFont12;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  object Views::Text ContactNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <18,42,171,72>;
    preset EnableBidiText = false;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont25;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  object Components::PushButtonBig UserInitials
  {
    preset Bounds = <184,28,254,119>;
    preset Enabled = false;
    preset Descript = "";
  }

  $rect <310,40,510,80>
  property Device::HistoryContact Contact = null;

  $rect <310,80,510,120>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }
}

$rect <50,350,210,390>
$output false
class ContactsAppInsideCall : Application::ContactsApp
{
  $rect <290,-10,490,30>
  inherited property Bounds = <0,0,272,440>;

  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <0,400,272,440>;
  }

  $rect <20,20,160,60>
  inherited object NavBarButtons
  {
    preset Bounds = <0,400,68,440>;
  }

  $rect <20,20,160,60>
  inherited object NavBarButtons1
  {
    preset Bounds = <68,400,136,440>;
  }

  $rect <20,20,160,60>
  inherited object NavBarButtons2
  {
    preset Bounds = <136,400,204,440>;
  }

  $rect <20,20,160,60>
  inherited object NavBarButtons3
  {
    preset Bounds = <204,400,272,440>;
  }

  $rect <20,20,160,60>
  object Components::TextButton TextButton
  {
    preset Bounds = <170,14,236,39>;
    preset Text = Strings::CancelTxt;
    preset OnActivate = onCancel;
  }

  $rect <290,40,490,80>
  property slot OnCancel;

  $rect <490,40,690,80>
  slot onCancel
  {
    postsignal OnCancel;
  }
}
