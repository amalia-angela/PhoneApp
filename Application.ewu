$version 12.00

$rect <40,300,220,340>
$output false
class ContactsPage : Core::Group
{
  $rect <310,40,480,80>
  inherited method Init()
  {
    attachobserver onListItemsUpdate, ^Device::Device.Contacts.NoOfItems;
    postsignal onListItemsUpdate;

    attachobserver onListItemsUpdate, ^Device::Device.Contacts.Sorting;
    postsignal onListItemsUpdate;

    attachobserver onListItemsUpdate, ^Device::Device.MyContact;
    postsignal onListItemsUpdate;









  }

  $rect <310,80,480,120>
  inherited property Bounds = <0,0,272,440>;

  $rect <830,60,1030,100>
  slot onCreateNewContact
  {
    createContact = new Application::AddContactPage;

    createContact.OnSave  = onSaveAdd;
    createContact.OnClose = onCancelAdd; 
    createContact.Contact = new Device::Contact;

    SwitchToDialog( createContact, Res::SlideUpCentered, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <680,60,830,100>
  var Application::AddContactPage createContact = null;

  $rect <850,100,1030,140>
  slot onSaveAdd
  {
    Device::Device.Contacts.AddLast( createContact.Contact );

    DismissDialog( createContact, Res::SlideDownCentered, null, null, null, null, false);

    createContact = null;
  }

  $rect <850,140,1030,180>
  slot onCancelAdd
  {
    DismissDialog( createContact, Res::SlideDownCentered, null, null, null, null, false);

    createContact = null;

  }

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,660,140>;
  }

  $rect <850,270,1030,310>
  slot onDelete
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);

    postsignal onListItemsUpdate;

    detailsPage = null;
  }

  $rect <309,389,509,429>
  slot onSearch
  {
    if ( SearchExt.String != "" )
    {
      
      Device::Device.Contacts.Search( SearchExt.String );

      ContactsInsideSearch.Bounds.origin = <0,0>;

      SearchExt.Icon = Res::XIcon;
    }
    else
    {
      postsignal onCancelSearch;
    }
  }

  $rect <680,190,830,230>
  var Application::DetailsPage detailsPage;

  $rect <850,230,1030,270>
  slot onClose
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);

    postsignal onListItemsUpdate;

    detailsPage = null;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <669,0,1229,440>;
  }

  $rect <300,240,500,280>
  slot onUpPress
  {
    Device::Device.Contacts.Sorting = Device::Sorting.Ascending;


  }

  $rect <300,280,500,320>
  slot onDownPress
  {
    Device::Device.Contacts.Sorting = Device::Sorting.Descending;

  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <296,189,496,229>
  slot OnLoadItem
  {
    var int32 itemNo = VerticalList.Item;

    var Device::Contact contact = Device::Device.Contacts.GetContactAtIndex( itemNo );

    var Application::ContactItem itemView = (Application::ContactItem)VerticalList.View;
                                                  
    if ( itemView == null )
      return;

    itemView.Contact    = contact;
    itemView.OnActivate = onContactPressed;

    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  // Vertical list
  note group Note1
  {
    attr Bounds = <289,149,660,329>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,167,261,440>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 32;
    preset ItemClass = Application::ContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -1;
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <12,167,261,440>;
    preset SnapNext = <0,35>;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 UpButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <236,141,262,167>;
    preset Icon = Res::UpIcon;
    preset OnActivate = onUpPress;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
    preset BackgroundColorEnabled = Res::Transparent;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 DownButton
  {
    preset Layout = Core::Layout[AlignToRight, AlignToTop];
    preset Bounds = <210,141,236,167>;
    preset Enabled = true;
    preset Icon = Res::DownIcon;
    preset OnActivate = onDownPress;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
    preset BackgroundColorEnabled = Res::Transparent;
  }

  $rect <20,20,160,60>
  object Components::InputBtnEtxt SearchExt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <3,67,269,99>;
    preset OnChange = onSearch;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "Type..";
    preset OnIcon = onCancelSearch;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <11,27,261,61>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::ContactsTxtx;
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 PlusButton
  {
    preset Bounds = <242,12,272,42>;
    preset Enabled = true;
    preset Icon = Res::PlusIcon;
    preset OnActivate = onCreateNewContact;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
    preset BackgroundColorEnabled = Res::Transparent;
  }

  $rect <830,190,1030,230>
  slot onContactPressed
  {
    var Application::ContactItem itemView = (Application::ContactItem)sender;

    if ( itemView != null )
    {
      detailsPage          = new Application::DetailsPage;
      detailsPage.OnBack   = onClose;
      detailsPage.OnDelete = onDelete;
      detailsPage.Contact  = itemView.Contact;
      
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }

  }

  $rect <487,190,657,230>
  slot onListItemsUpdate
  {
    VerticalList.NoOfItems = Device::Device.Contacts.NoOfItems;
    VerticalList.InvalidateItems ( 0, VerticalList.NoOfItems -1 );

  }

  $rect <20,20,160,60>
  object Application::MyCardItem MyCardItem
  {
    preset Bounds = <6,99,266,144>;
    preset OnActivate = onMyCardPress;
  }

  $rect <849,389,1029,429>
  slot onMyCardPress
  {
    if ( Device::Device.MyContact != null )
    {
      var Device::Contact contact = Device::Device.Contacts.FindMatchingIDContact( Device::Device.MyContact );

      if ( contact != null ){

        detailsPage          = new Application::DetailsPage;
        detailsPage.OnBack   = onClose;
        detailsPage.Contact  = contact;
      
        SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                                   null, null, null, false );
       }
    }
  }

  $rect <849,329,1029,369>
  slot onTapMessage
  {
    postsignal OnMessage;
     
  }

  $rect <689,329,849,369>
  property slot OnMessage;

  $rect <309,429,509,469>
  slot onCancelSearch
  {
    Device::Device.Contacts.CancelSearch();

    ContactsInsideSearch.Bounds.origin.y = Bounds.y2; 

    SearchExt.Text.String = " ";
    SearchExt.Icon = Res::SerachIcon;
  }

  $rect <20,20,160,60>
  object Application::ContactsInsideSearch ContactsInsideSearch
  {
    preset Bounds = <1,457,273,937>;
    preset OnSelectedContact = onFilteredContactPressed;
  }

  // Search
  note group Note3
  {
    attr Bounds = <291,340,660,520>;
  }

  $rect <1029,189,1229,229>
  slot onFilteredContactPressed
  {
    detailsPage          = new Application::DetailsPage;
    detailsPage.OnBack   = onClose;
    detailsPage.OnDelete = onDelete;
    detailsPage.Contact  = ContactsInsideSearch.Contact;
      
    SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
  }
}

// Contacts
note group Note
{
  attr Bounds = <0,220,429,789>;
}

$rect <51,340,220,379>
$output false
class ContactItem : Core::Group
{
  $rect <503,147,683,187>
  inherited method Init()
  {
    $if $composer
      FirstNameTxt.String = "Firstname";
      LastNameTxt.String = "Lastname";
    $endif

    attachobserver onContactUpdated, ^Device::Device.MyContact;
    postsignal onContactUpdated; 

  }

  $rect <10,500,210,540>
  inherited property Bounds = <0,0,250,32>;

  $rect <10,100,210,140>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    // Determine the new state of the push button.
    //
    // isEnabled  --> the button can react to user inputs.
    // isSelected --> the button can receive keyboard events.
    // isPressed  --> the button should appear pressed.
    //
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
      LastNameTxt.Color = Res::Grey;
      FirstNameTxt.Color = Res::Grey;
      MeTxt.Color = Res::Transparent;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GreyLight;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
      LastNameTxt.Color = TextColor;
      FirstNameTxt.Color = TextColor;
      MeTxt.Color = Res::Transparent;
    }




    // Remember the current state. Next time when the UpdateViewState() is called
    // you can compare the 'old' state with the 'new' state and perform more
    // sophisticated update, e.g. you can start an animation effect for the
    // pressed <<-->> not pressed transition.  

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  $rect <230,110,430,150>
  property Device::Contact Contact = null;

  $rect <230,150,430,190>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
    }
    postsignal onContactUpdated;

  }

  $rect <230,190,430,230>
  slot onContactUpdated
  {
    if ( Contact == null ){
      FirstNameTxt.String = "";
      LastNameTxt.String = "";
      PrfofilButton.Icon = "";
    }else{
      if ( pure Contact.LastName == "")
        LastNameTxt.String = pure Contact.FirstName;
      else{
        FirstNameTxt.String = pure Contact.FirstName;
        LastNameTxt.String  = pure Contact.LastName;
       }
      PrfofilButton.Icon  = pure Contact.NameInitials;

    if (  Device::Device.MyContact != null )
    {
      if ( pure Contact.ID == Device::Device.MyContact.ID ){
        MeTxt.Color = Res::Grey;
        }
      }
    }
  }

  // Contact data
  note group Note4
  {
    attr Bounds = <220,60,440,270>;
  }

  // State management
  note group Note5
  {
    attr Bounds = <0,60,220,310>;
  }

  $rect <10,260,210,300>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <10,220,210,260>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <10,180,210,220>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <10,140,210,180>
  var bool enabled;

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <580,0,780,40>
  property string Icon;

  $rect <790,0,990,40>
  property string Text = "";

  $rect <790,40,990,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <990,0,1190,40>
  property color ButtonColor = Res::White;

  $rect <990,40,1190,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <460,320,680,450>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <230,320,450,450>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <0,320,220,490>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <470,360,670,400>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <240,360,440,400>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <470,400,670,440>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <240,400,440,440>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <580,40,780,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <10,440,210,480>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <10,400,210,440>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <370,0,570,40>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <10,360,210,400>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <1200,0,1400,40>
  property color TextColor = Res::Black;

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,32>;
    preset Point3 = <250,32>;
    preset Point2 = <250,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,250,32>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text LastNameTxt
  {
    preset Bounds = <39,3,130,33>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text FirstNameTxt
  {
    preset StackingPriority = 0;
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz];
    preset Bounds = <129,3,244,33>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <250,32>;
    preset Point1 = <0,32>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 PrfofilButton
  {
    preset Bounds = <6,4,31,29>;
    preset DescriptColor = Res::White;
    preset DescriptFont = Res::ContactFont15;
    preset IconFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <250,0>;
    preset Point1 = <0,0>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Views::Text MeTxt
  {
    preset Bounds = <231,10,244,22>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "me";
    preset Font = Resources::DefaultFont;
    preset Color = Res::Transparent;
    preset Visible = true;
  }
}

$rect <50,421,220,460>
$output false
class DetailsPage : Core::Group
{
  $rect <-10,510,190,550>
  inherited property Bounds = <0,0,272,440>;

  $rect <450,50,630,90>
  slot onTapEdit
  {
    editPage = new Application::EditPage;

    editPage.OnSave   = onSaveEdit;
    editPage.OnClose  = onCancelEdit;
    editPage.Contact  = Contact;
    editPage.OnDelete = onDelete;

    SwitchToDialog( editPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
     



  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <770,0,1020,200>;
  }

  $rect <300,220,460,260>
  slot onDelete
  {
    signal OnDelete;

    DismissDialog( editPage, Res::FadeInOutCentered, null, null, null, null, false);

    editPage = null;
  }

  $rect <460,220,620,260>
  property slot OnDelete;

  $rect <300,50,450,90>
  var Application::EditPage editPage;

  $rect <300,280,480,320>
  slot onCall
  {
    Device::Device.SendCallFromContact( Contact );
  }

  $rect <460,90,620,130>
  slot onSaveEdit
  {
    DismissDialog( editPage, Res::FadeInOutCentered, null, null, null, null, false);

    editPage = null;
  }

  $rect <460,130,620,170>
  slot onCancelEdit
  {
    DismissDialog( editPage, Res::FadeInOutCentered, null, null, null, null, false);

    editPage = null;

  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,760,430>;
  }

  $rect <460,180,620,220>
  property slot OnBack;

  $rect <300,180,460,220>
  slot onBackHome
  {
    signal OnBack;
  }

  $rect <790,90,980,130>
  onset Contact
  {

    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <790,130,980,170>
  slot onContactUpdated
  {
    if ( pure Contact != null )
    {
      ContactName.String   = pure Contact.LastName + " "  + pure Contact.FirstName;
      NumberTxt.String     = pure Contact.PhoneNumber;   
      UserInitialsBtn.Icon = pure Contact.NameInitials;
      FavoritTxt.Visible   = pure Contact.IsFavorite ? true : false;  
    }

  }

  $rect <790,50,980,90>
  property Device::Contact Contact;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <266,287>;
    preset Point1 = <8,287>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text NumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <20,258,264,287>;
    preset ColorBR = #FFFFFF00;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = " +0749320298";
    preset Font = Res::ContactFont15;
    preset Color = Res::Blue;
  }

  $rect <20,20,160,60>
  object Views::Text MobileTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <8,232,266,265>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::MobileTxt;
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <266,232>;
    preset Point1 = <8,232>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::Button50x75 CallBtn
  {
    preset Bounds = <51,145,101,220>;
    preset Icon = Res::CallIcon;
    preset OnActivate = onCall;
    preset Descript = Strings::callTxt;
    preset BackgoundColor = Res::Blue;
    preset BackgoundColorPressed = Res::BlueLight;
    preset IconFont = Res::IconsFont20;
    preset Backgound = Res::ButtonRoundMedium;
  }

  $rect <20,20,160,60>
  object Components::Button50x75 VideoCallBtn
  {
    preset Bounds = <111,145,161,220>;
    preset Enabled = false;
    preset Icon = Res::VideoCallIcon;
    preset Descript = Strings::VideoTxt;
    preset BackgoundColor = Res::Blue;
    preset BackgoundColorPressed = Res::BlueLight;
    preset IconFont = Res::IconsFont20;
    preset Backgound = Res::ButtonRoundMedium;
    preset IconColorEnabled = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Components::Button50x75 PushButtonMediumBlue2
  {
    preset Bounds = <171,145,221,220>;
    preset Enabled = true;
    preset Icon = Res::MessageIcon;
    preset OnActivate = onTapMessage;
    preset Descript = Strings::messageTxt;
    preset BackgoundColor = Res::Blue;
    preset BackgoundColorPressed = Res::BlueLight;
    preset IconFont = Res::IconsFont20;
    preset Backgound = Res::ButtonRoundMedium;
  }

  $rect <20,20,160,60>
  object Views::Text ContactName
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <8,98,265,145>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont29;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::ButtonBase70x90 UserInitialsBtn
  {
    preset Bounds = <101,22,171,113>;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 EditBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Icon = Res::EditIcon;
    preset OnActivate = onTapEdit;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 BackBtn
  {
    preset Bounds = <7,4,32,29>;
    preset Icon = Res::BackIcon;
    preset OnActivate = onBackHome;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Views::Text FavoritTxt
  {
    preset Bounds = <60,233,84,263>;
    preset String = Res::HeartIcon;
    preset Font = Res::IconsFont20;
    preset Color = Res::Grey;
    preset Visible = false;
  }

  $rect <490,330,670,370>
  slot onTapMessage
  {
    chat = new Application::ChatPage;

    chat.Contact = Contact;
    chat.OnBack  = onBack;

    Owner.Owner.Owner.SwitchToDialog( chat, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
     
     
  }

  $rect <290,330,490,370>
  var Application::ChatPage chat = null;

  $rect <510,370,670,410>
  slot onBack
  {
    Owner.Owner.Owner.DismissDialog( chat, Res::FadeInOutCentered, null, null, null, null, false);

    chat = null;
  }
}

$rect <50,501,220,540>
$output false
class AddContactPage : Core::Group
{
  $rect <0,450,200,490>
  inherited property Bounds = <0,0,272,440>;

  $rect <760,100,960,140>
  inherited method UpdateLayout()
  {
    super(aSize);

    LastNameTxt.Bounds.origin = <3,191>;
    FirstNameTxt.Bounds.origin = <3, 224>;
    PhoneNumberTxt.Bounds.origin = <3, 257>;

    Background.Bounds = Bounds.orect;
  }

  $rect <760,50,960,90>
  inherited method UpdateViewState()
  {
    // Always give the ancestor class a chance to process this event.
    super( aState );

    if(Contact)
    {

    if (FirstNameTxt.String != "" ||
        LastNameTxt.String != "" ||
        PhoneNumberTxt.String !=  "")
    {
      SaveBtn.Enabled = true;
    }

    else
     SaveBtn.Enabled = false;
     }
     
  }

  $rect <311,50,511,90>
  slot onSave
  {
    notifyobservers pure Contact;

    signal OnSave;
  }

  $rect <521,50,721,90>
  property slot OnSave;

  $rect <310,190,510,230>
  property Device::Contact Contact;

  $rect <310,230,510,270>
  onset Contact
  {
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }
  }

  $rect <310,270,510,310>
  slot onContactUpdated
  {
    Contact.FirstName    = FirstNameTxt.String;
    Contact.LastName     = LastNameTxt.String;
    Contact.PhoneNumber  = PhoneNumberTxt.String;
    Contact.NameInitials = Device::Device.Contacts.GetInitials( LastNameTxt.String, FirstNameTxt.String);

    if ( Contact.LastName == "" &&  Contact.FirstName == "")
      Contact.LastName =  Contact.PhoneNumber;


         



  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,140,740,340>;
  }

  $rect <311,91,511,131>
  slot onClose
  {
    signal OnClose;
  }

  $rect <521,91,721,131>
  property slot OnClose;

  // Touch screen events
  note group Note
  {
    attr Bounds = <291,0,740,140>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <265,289>;
    preset Point1 = <7,289>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt PhoneNumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,257,269,289>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Blue;
    preset Placeholder = "Mobile number";
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <264,256>;
    preset Point1 = <6,256>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt FirstNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,224,269,256>;
    preset OnChange = onFieldChanged;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "First Name";
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <264,223>;
    preset Point1 = <6,223>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt LastNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <3,191,269,223>;
    preset OnChange = onFieldChanged;
    preset Alignment = Views::TextAlignment[];
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "Last Name";
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <264,190>;
    preset Point1 = <6,190>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::ButtonBase70x90 UserInitials
  {
    preset Bounds = <100,78,170,169>;
    preset Descript = Strings::AddPhototTxt;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <86,7,186,37>;
    preset String = Strings::NewContactTxt;
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 SaveBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Enabled = false;
    preset Icon = Res::CkeckIcon;
    preset OnActivate = onSave;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
    preset BackgroundColorEnabled = Res::Transparent;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 CloseButton
  {
    preset Bounds = <7,4,32,29>;
    preset Icon = Res::CloseIcon;
    preset OnActivate = onClose;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
    preset BackgroundColorEnabled = Res::Transparent;
  }

  $rect <530,270,730,310>
  slot onFieldChanged
  {
    UserInitials.Icon = Device::Device.Contacts.GetInitials( LastNameTxt.String, FirstNameTxt.String );

    InvalidateViewState();
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,0,970,170>;
  }
}

$rect <50,461,220,500>
$output false
class EditPage : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,440>;

  $rect <760,100,960,140>
  inherited method UpdateLayout()
  {
    super(aSize);

    LastNameTxt.Bounds.origin = <2,141>;
    FirstNameTxt.Bounds.origin = <2,174>;
    NumberTxt.Bounds.origin = <7,244>;

    Background.Bounds = Bounds.orect;
  }

  $rect <760,60,960,100>
  inherited method UpdateViewState()
  {
    // Always give the ancestor class a chance to process this event.
    super( aState );

    if(Contact){

      if (Contact.FirstName != FirstNameTxt.String ||
          Contact.LastName != LastNameTxt.String ||
          Contact.PhoneNumber !=  NumberTxt.String 
          ){
        SaveBtn.Enabled = true;
      }else
        SaveBtn.Enabled = false;
    }
     
  }

  $rect <310,50,510,90>
  slot onSave
  {
    Contact.FirstName    = FirstNameTxt.String; 
    Contact.LastName     = LastNameTxt.String;
    Contact.PhoneNumber  = NumberTxt.String;
    Contact.NameInitials = Device::Device.Contacts.GetInitials( Contact.LastName, Contact.FirstName );

    signal OnSave;
  }

  $rect <520,50,720,90>
  property slot OnSave;

  $rect <310,91,510,131>
  slot onClose
  {
    signal OnClose;
  }

  $rect <520,91,720,131>
  property slot OnClose;

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,740,190>;
  }

  $rect <310,130,510,170>
  slot onDeleteContact
  {
    Device::Device.Contacts.Remove( Contact );

    signal OnDelete;
  }

  $rect <310,290,510,330>
  onset Contact
  {
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <310,330,510,370>
  slot onContactUpdated
  {
    if ( Contact != null )
    {
      FirstNameTxt.String = Contact.FirstName;
      LastNameTxt.String  = Contact.LastName;
      NumberTxt.String    = Contact.PhoneNumber;  
      UserInitials.Icon  = Contact.NameInitials;
    }

  }

  $rect <310,250,510,290>
  property Device::Contact Contact;

  $rect <520,130,720,170>
  property slot OnDelete;

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,200,740,390>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Components::Button265x470 DeleteBtn
  {
    preset Bounds = <5,398,263,431>;
    preset Enabled = true;
    preset OnActivate = onDeleteContact;
    preset String = Strings::DeleteContactTxt;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt NumberTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <7,244,265,273>;
    preset OnChange = onFieldModified;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "0749320267";
    preset Color = Res::Blue;
    preset Font = Res::ContactFont15;
    preset Placeholder = "0749320267";
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <264,239>;
    preset Point1 = <6,239>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text MobileTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <6,207,264,240>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::MobileTxt;
    preset Font = Res::ContactFont15;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Line Line3
  {
    preset Point2 = <263,206>;
    preset Point1 = <5,206>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt FirstNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <2,174,268,206>;
    preset OnChange = onFieldModified;
    preset String = "First name";
    preset Color = Res::Black;
    preset Placeholder = "First name";
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Point2 = <263,173>;
    preset Point1 = <5,173>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt LastNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft];
    preset Bounds = <2,141,268,173>;
    preset OnChange = onFieldModified;
    preset String = "Last name";
    preset Color = Res::Black;
    preset Placeholder = "Last name";
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Point2 = <263,140>;
    preset Point1 = <5,140>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Components::ButtonBase70x90 UserInitials
  {
    preset Bounds = <99,29,169,120>;
    preset Icon = "";
    preset Descript = Strings::AddPhototTxt;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 CloseBtn
  {
    preset Bounds = <7,4,32,29>;
    preset Icon = Res::CloseIcon;
    preset OnActivate = onClose;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 SaveBtn
  {
    preset Bounds = <240,4,265,29>;
    preset Enabled = false;
    preset Icon = Res::CkeckIcon;
    preset OnActivate = onSave;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
    preset BackgroundColorEnabled = Res::Transparent;
    preset DescriptColorEnabled = Res::Grey;
  }

  $rect <530,330,730,370>
  slot onFieldModified
  {
    UserInitials.Icon = Device::Device.Contacts.GetInitials( LastNameTxt.String, FirstNameTxt.String );

    InvalidateViewState();
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,0,970,150>;
  }
}

$rect <240,560,410,600>
$output false
class OngoingCall : Application::CallBase
{
  $rect <310,40,510,80>
  inherited method Init()
  {
    signal Stoper.StartTimer;
  }

  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,480>;

  $rect <510,130,710,170>
  inherited slot onContactUpdated
  {
    if (  Contact.CallState == Device::CallState.Speaking )
    {
      AddCallBtn.Enabled = true;
      VideoCallBtn.Enabled = true;
      
    } 

    super( sender );
  }

  $rect <20,20,160,60>
  inherited object DesclineButton
  {
    preset Bounds = <104,374,169,466>;
  }

  $rect <500,520,700,560>
  slot onSpeakerPress
  {
    //button pressed it changes sate from start/stop and icon PlayIcon/StopIcon

    Device::Device.Speaker =! Device::Device.Speaker;

    SpeakerBtn.BackgoundColor = Device::Device.Speaker ? Res::White : Res::WhiteTransparent;
    SpeakerBtn.IconColor      = Device::Device.Speaker ? Res::Black : Res::White ;
  }

  $rect <500,480,700,520>
  slot onMicPress
  {
    //button pressed it changes sate from start/stop and icon PlayIcon/StopIcon

    Device::Device.Microphone = ! Device::Device.Microphone;

    MuteBtn.BackgoundColor = Device::Device.Microphone ? Res::White : Res::WhiteTransparent;
    MuteBtn.IconColor      = Device::Device.Microphone ? Res::Black : Res::White;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,710,640>;
  }

  $rect <700,370,900,410>
  slot onKeypadPress
  {
    Keypad.Bounds.origin =< 0, 30>;

    Keypad.OnHide = onHide;


  }

  $rect <500,340,700,380>
  slot onAddCallPress
  {
    addCall = new Application::ContactsAppInsideCall;

    addCall.OnCancel = onCancelAddCall;

    PresentDialog( addCall, Res::SlideUpCenteredLimit, null, null, null, null, null, null, null, false );
  }

  $rect <300,520,500,560>
  slot onVideoCallPress
  {
    sender; 
  }

  $rect <510,250,700,290>
  slot onContactsPress
  {
    contactsPage = new Application::ContactsInsideCall;

    contactsPage.OnCancel = onCancelContacts; 

    SwitchToDialog( contactsPage, Res::SlideUpCenteredLimit, null, null, null, null, null,
                               null, null, null, false );
  }

  $rect <20,20,160,60>
  object Components::Button65x90 ContactsBtn
  {
    preset Bounds = <182,240,247,332>;
    preset Icon = Res::UserIcon;
    preset OnActivate = onContactsPress;
    preset Descript = Strings::contactsTxt;
    preset DescriptColor = Res::White;
    preset BackgoundColor = Res::WhiteTransparent;
    preset BackgoundColorPressed = Res::PressColor;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Components::Button65x90 VideoCallBtn
  {
    preset Bounds = <104,241,169,333>;
    preset Enabled = false;
    preset Icon = Res::VideoCallIcon;
    preset OnActivate = onVideoCallPress;
    preset Descript = Strings::videocallTxt;
    preset DescriptColor = Res::White;
    preset BackgoundColor = Res::WhiteTransparent;
    preset BackgoundColorPressed = Res::PressColor;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
    preset BackgroundColorEnabled = Res::WhiteSemiTransparent;
  }

  $rect <20,20,160,60>
  object Components::Button65x90 AddCallBtn
  {
    preset Bounds = <26,242,91,334>;
    preset Icon = Res::PlusIcon;
    preset OnActivate = onAddCallPress;
    preset Descript = Strings::addcallTxt;
    preset DescriptColor = Res::White;
    preset BackgoundColor = Res::WhiteTransparent;
    preset BackgoundColorPressed = Res::PressColor;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
    preset BackgroundColorEnabled = Res::WhiteSemiTransparent;
  }

  $rect <20,20,160,60>
  object Components::Button65x90 SpeakerBtn
  {
    preset Bounds = <182,147,247,239>;
    preset Icon = Res::SpeakerIcon;
    preset OnActivate = onSpeakerPress;
    preset Descript = Strings::speakerTxt;
    preset DescriptColor = Res::White;
    preset BackgoundColor = Res::WhiteTransparent;
    preset BackgoundColorPressed = Res::PressColor;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Components::Button65x90 KeyPadBtn
  {
    preset Bounds = <104,148,169,240>;
    preset Icon = Res::KeypadIcon;
    preset OnActivate = onKeypadPress;
    preset Descript = Strings::keypadTxt;
    preset DescriptColor = Res::White;
    preset BackgoundColor = Res::WhiteTransparent;
    preset BackgoundColorPressed = Res::PressColor;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Components::Button65x90 MuteBtn
  {
    preset Bounds = <26,149,91,241>;
    preset Icon = Res::MicOffIcon;
    preset OnActivate = onMicPress;
    preset Descript = Strings::muteTxt;
    preset DescriptColor = Res::White;
    preset BackgoundColor = Res::WhiteTransparent;
    preset BackgoundColorPressed = Res::PressColor;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
  }

  $rect <300,250,500,290>
  var Application::ContactsInsideCall contactsPage = null;

  $rect <520,290,690,330>
  slot onCancelContacts
  {
    DismissDialog( contactsPage, Res::SlideDownCentered, null, null, null, null, false);

    contactsPage = null;
  }

  $rect <730,450,900,490>
  slot onHide
  {
    Keypad.Bounds.origin.y = Bounds.y2;

    Keypad.InputEtxt.String = "";
    ContactNameTxt.Visible  = true;
    TimeTxt.Visible         = true;
    UserInitials.Visible    = true;

  }

  $rect <20,20,160,60>
  object Application::KeypadInsideCall Keypad
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,518,272,958>;
    preset inHideTextVisible = false;
    preset IsCallButtonVisible = true;
    preset OnEditTextChanged = onKeypadEdit;
  }

  $rect <700,410,900,450>
  slot onKeypadEdit
  {
    ContactNameTxt.Visible = Keypad.InputEtxt.String == "";
    TimeTxt.Visible        = Keypad.InputEtxt.String == "";
    UserInitials.Visible   = Keypad.InputEtxt.String == "";
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,750,200>;
  }

  $rect <300,340,500,380>
  var Application::ContactsAppInsideCall addCall = null;

  $rect <530,380,700,420>
  slot onCancelAddCall
  {
    DismissDialog( addCall, Res::SlideDownCentered, null, null, null, null, false);

    addCall = null;
  }

  $rect <310,80,510,120>
  object Core::Timer Stoper
  {
    preset OnTrigger = upDateTalkDuration;
  }

  $rect <510,80,710,120>
  slot upDateTalkDuration
  {
    if (  Contact.CallState == Device::CallState.Speaking )
    {
      TimeTxt.String = Contact.GetDuration();
    }
  }
}

$rect <240,640,410,680>
$output false
class DetailsInsideCall : Application::DetailsPage
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272,440>;

  $rect <490,20,690,60>
  inherited slot onTapEdit
  {
    editPage = new Application::EditPage;

    editPage.OnSave  = onSaveEdit;
    editPage.OnClose = onCancelEdit;
    editPage.Contact = Contact;
    editPage.OnDelete = onDelete;

    SwitchToDialog( editPage, Res::FadeInOutCentered, null, null, null, null, null,
                               null, null, null, false );
     



  }

  $rect <290,20,490,60>
  inherited var editPage;

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  inherited object Line2
  {
    preset Point2 = <264,311>;
    preset Point1 = <6,311>;
  }

  $rect <20,20,160,60>
  inherited object NumberTxt
  {
    preset Bounds = <18,282,262,311>;
  }

  $rect <20,20,160,60>
  inherited object MobileTxt
  {
    preset Bounds = <6,256,264,289>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <264,256>;
    preset Point1 = <6,256>;
  }

  $rect <20,20,160,60>
  inherited object CallBtn
  {
    preset Bounds = <50,161,100,236>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  inherited object VideoCallBtn
  {
    preset Bounds = <110,161,160,236>;
  }

  $rect <20,20,160,60>
  inherited object PushButtonMediumBlue2
  {
    preset Bounds = <170,161,220,236>;
  }

  $rect <20,20,160,60>
  inherited object ContactName
  {
    preset Bounds = <10,114,267,144>;
  }

  $rect <20,20,160,60>
  inherited object UserInitialsBtn
  {
    preset Bounds = <100,30,170,121>;
    preset Enabled = false;
  }

  $rect <20,20,160,60>
  inherited object EditBtn
  {
    preset Bounds = <239,5,264,30>;
  }

  $rect <20,20,160,60>
  inherited object BackBtn
  {
    preset Bounds = <6,5,31,30>;
  }
}

$rect <230,431,410,471>
$output false
class KeypadPage : Core::Group
{
  $rect <0,490,200,530>
  inherited property Bounds = <0,0,272, 440>;

  $rect <760,40,960,80>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);

    if ( inHideTextVisible == false)
    {
      HideBtn.Visible= true;
    }

    if ( inHideTextVisible == true)
    {
      HideBtn.Visible= false;
    }

    if ( IsCallButtonVisible == false)
    {
      callbtn.Visible= true;
    }

    if ( IsCallButtonVisible == true)
    {
      callbtn.Visible= false;
    }


    if ( !isEnabled )
    {
      Background.Color = Res::Grey;
    }

    // Enabled but not pressed nor selected.
    else
    {
       Background.Color = BackgoundColor;
    }


  }

  $rect <300,60,500,100>
  property slot OnHide;

  $rect <500,60,700,100>
  slot onHide
  {
    postsignal OnHide;
  }

  $rect <760,90,960,130>
  property color BackgoundColor = Res::White;

  $rect <960,90,1160,130>
  onset BackgoundColor
  {
    if ( pure BackgoundColor == value )
      return;

    pure BackgoundColor = value;

    InvalidateViewState();
  }

  $rect <760,130,960,170>
  property bool inHideTextVisible = true;

  $rect <960,130,1160,170>
  onset inHideTextVisible
  {
    if ( pure inHideTextVisible == value )
      return;

    pure inHideTextVisible = value;

    InvalidateViewState();
  }

  $rect <300,110,500,150>
  slot onButtonsPress
  {
    var Components::SButton65x65 button = (Components::SButton65x65)sender;

    if ( sender == BtnErase)
      InputEtxt.String = InputEtxt.String.remove( InputEtxt.String.length-1, 1);
    else if ( button != null )
    {
      InputEtxt.String += button.Icon;
    }

    signal OnEditTextChanged;        

  }

  $rect <760,170,960,210>
  property bool IsCallButtonVisible = false;

  $rect <960,170,1160,210>
  onset IsCallButtonVisible
  {
    if ( pure IsCallButtonVisible == value )
      return;

    pure IsCallButtonVisible = value;

    InvalidateViewState();
  }

  $rect <300,150,500,190>
  slot onCallPress
  {
    if( InputEtxt.String != "")
    {
      Device::Device.SendCallFromNumber( InputEtxt.String );

    }
  }

  $rect <300,220,500,260>
  property slot OnEditTextChanged = null;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,440>;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 callbtn
  {
    preset Bounds = <104,340,169,405>;
    preset Icon = Res::CallIcon;
    preset OnActivate = onCallPress;
    preset BackgoundColor = Res::GreenDark;
    preset BackgoundColorPressed = Res::Green;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn1
  {
    preset Bounds = <39,80,104,145>;
    preset Icon = "1";
    preset OnActivate = onButtonsPress;
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn3
  {
    preset Bounds = <169,80,234,145>;
    preset Icon = "3";
    preset OnActivate = onButtonsPress;
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn2
  {
    preset Bounds = <104,80,169,145>;
    preset Icon = "2";
    preset OnActivate = onButtonsPress;
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn4
  {
    preset Bounds = <39,145,104,210>;
    preset Icon = "4";
    preset OnActivate = onButtonsPress;
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn6
  {
    preset Bounds = <169,145,234,210>;
    preset Icon = "6";
    preset OnActivate = onButtonsPress;
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn5
  {
    preset Bounds = <104,145,169,210>;
    preset Icon = "5";
    preset OnActivate = onButtonsPress;
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn7
  {
    preset Bounds = <39,210,104,275>;
    preset Icon = "7";
    preset OnActivate = onButtonsPress;
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn9
  {
    preset Bounds = <169,210,234,275>;
    preset Icon = "9";
    preset OnActivate = onButtonsPress;
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn8
  {
    preset Bounds = <104,210,169,275>;
    preset Icon = "8";
    preset OnActivate = onButtonsPress;
    preset Descript = "8";
    preset DescriptColor = Res::White;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btnstar
  {
    preset Bounds = <39,275,104,340>;
    preset Icon = "*";
    preset OnActivate = onButtonsPress;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btnDiez
  {
    preset Bounds = <169,275,234,340>;
    preset Icon = "#";
    preset OnActivate = onButtonsPress;
    preset Descript = "#";
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 btn0
  {
    preset Bounds = <104,275,169,340>;
    preset Icon = "0";
    preset OnActivate = onButtonsPress;
    preset Descript = "0";
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::GreyLight;
    preset BackgoundColorPressed = Res::Grey;
    preset DescriptFont = Res::ContactFont15;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::InputEtxt InputEtxt
  {
    preset Bounds = <39,48,234,80>;
    preset String = "";
    preset Color = Res::Black;
    preset Font = Res::TitileFont25;
  }

  $rect <20,20,160,60>
  object Components::TextButton HideBtn
  {
    preset Bounds = <39,360,101,385>;
    preset Text = Strings::HideTxt;
    preset OnActivate = onHide;
    preset TextColor = Res::Black;
    preset TextColorPress = Res::Grey;
  }

  // State management
  note group Note4
  {
    attr Bounds = <750,0,1170,220>;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,0,740,280>;
  }

  $rect <20,20,160,60>
  object Components::SButton65x65 BtnErase
  {
    preset Bounds = <169,340,234,405>;
    preset Icon = Res::BackspaceIcon;
    preset OnActivate = onButtonsPress;
    preset Descript = "#";
    preset DescriptColor = Res::Black;
    preset IconColor = Res::Black;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset DescriptFont = Res::ContactFont15;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
    preset IconColorPressed = Res::Black;
  }
}

// This is the root component of the entire GUI application.
$rect <20,255,220,295>
$output false
class PhoneApp : Core::Group
{
  $rect <300,40,480,80>
  inherited method Init()
  {
    SelectedPage = 2;
  }

  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  object Core::Group Outline
  {
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,440,272,480>;
  }

  $rect <20,20,160,60>
  object Components::NavBarButton64x40 NavBarButtons
  {
    preset Bounds = <0,440,68,480>;
    preset Icon = Res::HeartIcon;
    preset Descript = Strings::FavoritesTxt;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Components::NavBarButton64x40 NavBarButtons1
  {
    preset Bounds = <68,440,136,480>;
    preset Icon = Res::CallIcon;
    preset Descript = Strings::RecentTxt;
    preset OutletSelector = 1;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Components::NavBarButton64x40 NavBarButtons2
  {
    preset Bounds = <136,440,204,480>;
    preset Icon = Res::UserIcon;
    preset Descript = Strings::ContactsTxtx;
    preset OutletSelector = 2;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Components::NavBarButton64x40 NavBarButtons3
  {
    preset Bounds = <204,440,272,480>;
    preset Icon = Res::KeypadIcon;
    preset Descript = Strings::KeypadTxt;
    preset OutletSelector = 3;
    preset Outlet = ^SelectedPage;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <270,440>;
    preset Point1 = <0,440>;
    preset Color = Res::Grey;
  }

  $rect <300,90,500,130>
  property int32 SelectedPage = -1;

  $rect <300,130,500,170>
  onset SelectedPage
  {
    if ( pure SelectedPage == value )
      return;

    pure SelectedPage = value;

    notifyobservers ^SelectedPage;

    signal onSwitchToSelectedPage;
  }

  $rect <300,170,500,210>
  onget SelectedPage
  {
    return pure SelectedPage;
  }

  // Initialization
  note group Note
  {
    attr Bounds = <290,0,510,290>;
  }

  $rect <300,230,500,270>
  slot onSwitchToSelectedPage
  {
    switch ( pure SelectedPage )
    {
      case 0: 
      {
        var Core::Group favorites = new Application::FavoritesPage;
        Outline.SwitchToDialog( favorites, null, null, null, null, null, null, null, null, null,false );
      }
      case 1: 
      {
        var Core::Group recent = new Application::RecentPage;
        Outline.SwitchToDialog( recent, null, null, null, null, null, null, null, null, null,false );
      }
      case 2: 
      {
        var Core::Group contacts = new Application::ContactsPage;
       
        Outline.SwitchToDialog( contacts, null, null, null, null, null, null, null, null, null,false );
      }
      case 3: 
      {
        var Core::Group keypad = new Application::KeypadPage;
        Outline.SwitchToDialog( keypad, null, null, null, null, null, null,
                                null, null, null,false );
      }

      default:
        trace "ERROR: invalid selected page ", pure SelectedPage;
    }

  }
}

$rect <240,680,410,720>
$output false
class KeypadInsideCall : Application::KeypadPage
{
  $rect <20,20,160,60>
  inherited object Background
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle BackgroundSmall
  {
    preset Bounds = <0,80,272,340>;
    preset ColorBL = #838383FA;
    preset ColorBR = #4F4F4FFF;
    preset ColorTR = #898989FF;
    preset ColorTL = #898989FF;
    preset Color = #3C3C3CFF;
  }

  $rect <20,20,160,60>
  inherited object callbtn
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  inherited object btn1;

  $rect <20,20,160,60>
  inherited object btn3
  {
    preset Enabled = true;
  }

  $rect <20,20,160,60>
  inherited object btn2;

  $rect <20,20,160,60>
  inherited object btn4;

  $rect <20,20,160,60>
  inherited object btn6;

  $rect <20,20,160,60>
  inherited object btn5;

  $rect <20,20,160,60>
  inherited object btn7;

  $rect <20,20,160,60>
  inherited object btn9;

  $rect <20,20,160,60>
  inherited object btn8;

  $rect <20,20,160,60>
  inherited object btnstar;

  $rect <20,20,160,60>
  inherited object btnDiez;

  $rect <20,20,160,60>
  inherited object btn0;

  $rect <20,20,160,60>
  inherited object InputEtxt
  {
    preset Bounds = <39,32,234,64>;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  inherited object HideBtn
  {
    preset TextColor = Res::White;
  }

  $rect <20,20,160,60>
  inherited object BtnErase
  {
    preset IconColor = Res::White;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder BackgroundSmall 16
}

$rect <240,600,410,640>
$output false
class ContactsInsideCall : Application::ContactsPage
{
  $rect <290,110,490,150>
  inherited var detailsPage;

  $rect <20,20,160,60>
  inherited object Background;

  $rect <20,20,160,60>
  inherited object VerticalList
  {
    preset Bounds = <11,134,261,440>;
  }

  $rect <20,20,160,60>
  inherited object SlideTouchHandler
  {
    preset Bounds = <12,134,261,440>;
  }

  $rect <20,20,160,60>
  inherited object UpButton
  {
    preset Bounds = <236,108,262,134>;
  }

  $rect <20,20,160,60>
  inherited object DownButton
  {
    preset Bounds = <210,108,236,134>;
  }

  $rect <20,20,160,60>
  inherited object SearchExt;

  $rect <20,20,160,60>
  inherited object TitleTxt
  {
    preset Bounds = <11,12,261,61>;
    preset Font = Res::ContactFontBold15;
  }

  $rect <20,20,160,60>
  inherited object PlusButton
  {
    preset Bounds = <180,15,210,45>;
  }

  $rect <20,20,160,60>
  inherited object MyCardItem
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  object Components::TextButton TextButton
  {
    preset Bounds = <216,15,282,40>;
    preset Text = Strings::CancelTxt;
    preset OnActivate = onCancel;
  }

  $rect <290,0,490,40>
  property slot OnCancel;

  $rect <490,0,690,40>
  slot onCancel
  {
    postsignal OnCancel;
  }

  $rect <490,110,690,150>
  inherited slot onContactPressed
  {
    var Application::ContactItem itemView = (Application::ContactItem)sender;

    if ( itemView != null )
    {
      detailsPage = new Application::DetailsInsideCall;
      detailsPage.OnBack = onClose;
      detailsPage.OnDelete = onDelete;

      detailsPage.Contact = itemView.Contact;
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }

  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member detailsPage
  $member Background
  $member VerticalList
  $member SlideTouchHandler
  $member UpButton
  $member DownButton
  $member SearchExt
  $member TitleTxt
  $member PlusButton
  $member onContactPressed
  $member MyCardItem
  $member TextButton
  $member OnCancel
  $member onCancel
}

$rect <460,50,660,87>
$variant Simulation
vclass ApplicationSimulation : Application::Application
{
  $rect <920,20,1120,60>
  inherited property Bounds = <0,0,315,630>;

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <-264,-113,576,746>;
    preset ColorBL = #A8A8A8FF;
    preset ColorBR = #E0E0E0FF;
    preset ColorTR = #C7C7C7FF;
    preset Color = Res::Grey;
    preset Bitmap = Res::iphoneCase;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <122,556>;
    preset Point3 = <189,556>;
    preset Point2 = <189,612>;
    preset Point1 = <122,612>;
    preset OnPress = onHomeBtnPressed;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder Image 5
}

// Simulation
note group Note4
{
  attr Bounds = <440,0,909,209>;
}

$rect <240,520,410,560>
$output false
class IncomingCall : Application::CallBase
{
  $rect <300,40,500,80>
  inherited method Init()
  {
  }

  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <20,20,160,60>
  inherited object DesclineButton;

  $rect <20,20,160,60>
  inherited object UserInitials
  {
    preset IconColorPressed = Res::Grey;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,760,320>;
  }

  $rect <310,260,510,300>
  slot onAcceptCall
  {
    Device::Device.SendCallAnswer( Contact );
  }

  $rect <20,20,160,60>
  object Components::Button65x90 AcceptButton
  {
    preset Bounds = <171,340,236,432>;
    preset Icon = Res::CallIcon;
    preset OnActivate = onAcceptCall;
    preset Descript = Strings::acceptTxt;
    preset DescriptColor = Res::White;
    preset BackgoundColor = Res::GreenDark;
    preset BackgoundColorPressed = Res::Green;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,760,200>;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder Note 2
  $reorder onAcceptCall 2
  $reorder AcceptButton 2
  $reorder Note2 2
}

$rect <229,300,409,340>
$output false
class FavoritesPage : Core::Group
{
  $rect <290,50,470,90>
  inherited method Init()
  {
    attachobserver onListItemsUpdated, ^Device::Device.Favorites.NoOfItems;
    postsignal onListItemsUpdated;
  }

  $rect <0,450,190,490>
  inherited property Bounds = <0,0,272,440>;

  $rect <470,260,660,300>
  slot onAddPress
  {
    addFav = new Application::ContactsList;

    addFav.OnCancel      = onClose;
    addFav.OnAddFav      = onAdd;
    addFav.Contact = new Device::Contact;

    SwitchToDialog( addFav, Res::SlideUpCentered, null, null, null, null, null, null, null, null, false );

  }

  $rect <290,260,470,300>
  var Application::ContactsList addFav = null;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <820,60,1020,100>
  slot OnLoadItem
  {
    var int32 itemNo = VerticalList.Item;

    var Device::Contact contact = Device::Device.Favorites.GetContactAtIndex( itemNo );

    var Application::FavContactItem itemView = (Application::FavContactItem)VerticalList.View;
    Contact = itemView.Contact;
                                                  
    if ( itemView == null )
      return;

    itemView.Contact    = contact;
    itemView.OnActivate = onPressedContact;
    itemView.OnDelete   = onDeleteContact;
    itemView.OnInfo     = onInfoContact;  
    itemView.EditMode   = EditMode;

    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );


  }

  $rect <850,100,1020,140>
  slot onPressedContact
  {
    Contact = (( Application::FavContactItem ) sender ).Contact;

    Device::Device.SendCallFromContact( Contact );

    Contact = null;

  }

  $rect <490,300,660,340>
  slot onClose
  {
    DismissDialog( addFav, Res::SlideDownCentered, null, null, null, null, false );

    addFav = null;

  }

  $rect <290,90,470,130>
  slot onListItemsUpdated
  {
    VerticalList.NoOfItems = Device::Device.Favorites.NoOfItems;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
  }

  $rect <490,50,660,90>
  property Device::Contact Contact = null;

  $rect <490,90,660,130>
  onset Contact
  {
    if ( pure Contact == value )
      return;

    pure Contact = value;

    notifyobservers ^Contact; 
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <280,170,670,390>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <11,95,261,408>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 32;
    preset ItemClass = Application::FavContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -2;
    preset Bounds = <11,95,261,408>;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt1
  {
    preset Bounds = <11,42,261,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::FavoritesTxt;
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 PlusButton
  {
    preset Bounds = <11,12,41,42>;
    preset Enabled = true;
    preset Icon = Res::PlusIcon;
    preset OnActivate = onAddPress;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Components::TextButton TextButton
  {
    preset Bounds = <228,12,263,37>;
    preset Text = Strings::EditTxt;
    preset OnActivate = onEdit;
  }

  $rect <690,180,850,220>
  var Application::DetailsPage detailsPage;

  $rect <850,180,1020,220>
  slot onInfoContact
  {
    detailsPage         = new Application::DetailsPage;
    detailsPage.Contact = (( Application::FavContactItem ) sender ).Contact;
    detailsPage.OnBack  = onCloseDetailsPage;

    SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null, null, null, null, false );


  }

  $rect <850,140,1020,180>
  slot onDeleteContact
  {
    Contact = (( Application::FavContactItem ) sender ).Contact;
    var Device::Contact contact = Device::Device.Contacts.FindMatchingIDContact( Contact );

    if ( contact != null)
      contact.IsFavorite = false;

    Device::Device.Favorites.Remove( Contact );

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );

    Contact = null;
  }

  $rect <870,220,1020,260>
  slot onCloseDetailsPage
  {
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false );

    detailsPage = null;
    Contact = null;
  }

  // Vertical list
  note group Note2
  {
    attr Bounds = <680,0,1030,390>;
  }

  // Initialization
  note group Note3
  {
    attr Bounds = <280,0,670,170>;
  }

  $rect <480,210,660,250>
  property bool EditMode = false;

  $rect <290,210,480,250>
  slot onEdit
  {
    EditMode = !EditMode;

    TextButton.Text = EditMode == false ?  "Edit" : "Done" ;

    postsignal onListItemsUpdated;
  }

  $rect <490,340,660,380>
  slot onAdd
  {
    Device::Device.Favorites.AddLast ( addFav.Contact );
    postsignal onListItemsUpdated;

    DismissDialog ( addFav, Res::SlideDownCentered, null, null, null, null, false );
                               
    addFav = null;

  }
}

$rect <40,550,220,590>
$output false
class RecentPage : Core::Group
{
  $rect <290,40,480,80>
  inherited method Init()
  {
    attachobserver onListItemsUpdated, ^Device::Device.History.NoOfItems;
    postsignal onListItemsUpdated;
  }

  $rect <0,460,190,500>
  inherited property Bounds = <0,0,272,440>;

  $rect <0,570,200,610>
  inherited method UpdateLayout()
  {
    // Always invoke the inherited method.
    super( aSize );

    /*

      HINT:

      This method exists for sophisticated layout calculation. Please note, that in 
      most cases it is completely sufficient to use the views property 'Layout' to
      determine how the view should behave when the component is resized.

    */

    /*

      TO DO:

      Put here the code to calculate new position and size of enclosed views. The
      current (new) size of the component itself is passed in the parameter aSize.
      For example:

        SomeView.Bounds = rect( 10, 10, aSize.x - 20, aSize.y - 20 );

    */
  }

  $rect <0,530,200,570>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    /*

      HINT 1:

      This method is invoked automatically when the state set of the component has
      been changed. The new state set can be found in the parameter aState.
      Following are the important states:

        Enabled   --> The component can react to user inputs.

        Selected  --> The component is selected in context of its owner.

        Focused   --> The component is selected in context of its owner and 
                      the owner can react to keyboard events. In this manner the
                      component is also able to react to keyboard events.

        Modal     --> The component is modal. All events are redirected to this
                      component.

      To determine whether a state is currently active or not you have to test
      the aState parameter. For example to test the 'Selected' state:

        if ( aState.contains( Core::ViewState[ Selected ]))
        {
          ... yes, this component is currently selected.
        }

    */

    /*

      HINT 2:

      Alternatively you can request this method invocation by executing explicitly
      following code:


        InvalidateViewState();

    */
      
    /*

      TO DO 1:

      Put here the code to ensure that the visual aspect of the component does
      reflect its current state. For example, depending on its 'Enabled' state
      a component may appear with full colors or pale if it is disabled:

        if ( aState.contains( Core::ViewState[ Enabled ]))
        {
          SomeBackgroundView.Opacity = 255;
          SomeTextView.Color         = #000000FF;
        }
        else
        {
          SomeBackgroundView.Opacity = 128;
          SomeTextView.Color         = #00000080;
        }


      TO DO 2:

      You can evaluate here also the state of any other member in your component.
      For example in a push-button component, the button should appear highlighted
      as long as the user holds the finger within a touch area of the button:

        if ( SomeTouchHandler.Down && SomeTouchHandler.Inside )
          HighlightedBackground.Visible = true;
        else
          HighlightedBackground.Visible = false;

      The touch handler itself only requests the update method to be called. Use
      for this purpose 'InvalidateViewState()' method.


      TO DO 3:

      You can calculate here also the position/size of views accordingly to the
      state of any other member in your component. For example in a slider you
      can calculate the position of the slider knob from some properties like
      'SliderValue' and 'SliderRange':

        SliderKnob.Bounds.origin.x = ( SliderValue * Bounds.w ) / SliderRange;

      Changing the 'SliderValue' or 'SliderRange' property should only request
      the update method to be called. Use for this purpose 'InvalidateViewState()'
      method.

    */
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,0,272,440>;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt1
  {
    preset Bounds = <11,42,261,76>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::RecentTxt;
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::TextButton TextButton
  {
    preset Layout = Core::Layout[AlignToRight, ResizeVert];
    preset Bounds = <226,12,261,37>;
    preset Text = Strings::EditTxt;
    preset OnActivate = onEdit;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Bounds = <11,95,261,408>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 50;
    preset ItemClass = Application::RecentItm;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -1;
    preset Bounds = <11,95,261,408>;
    preset SlideHorz = false;
  }

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <690,40,890,80>
  slot OnLoadItem
  {
    var int32 itemNo = VerticalList.Item;

    var Device::HistoryContact contactHistory = (Device::HistoryContact )Device::Device.History.GetContactAtIndex( itemNo );

    var Application::RecentItm itemView = (Application::RecentItm)VerticalList.View;
                                                  
    if ( itemView == null )
      return;

    if ( contactHistory != null )
    {
      itemView.ContactHistory = contactHistory;  
      itemView.EditMode = EditMode;
      itemView.OnActivate = onPressedContact;
      itemView.OnDelete = onDeleteContact;
      itemView.OnInfo = onInfoContact;
      
    }

    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );


  }

  $rect <490,40,660,80>
  property Device::HistoryContact SelectedContact = null;

  $rect <490,80,660,120>
  onset SelectedContact
  {
    if ( pure SelectedContact == value )
      return;

    pure SelectedContact = value;

    notifyobservers ^SelectedContact; 
  }

  $rect <290,230,470,270>
  property bool EditMode = false;

  $rect <470,230,650,270>
  slot onEdit
  {
    EditMode = !EditMode;

    TextButton.Text = EditMode == false ? "Edit" : "Done";

    postsignal onListItemsUpdated;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <280,180,670,280>;
  }

  // Vertical list
  note group Note2
  {
    attr Bounds = <680,0,1100,280>;
  }

  // Initialization
  note group Note3
  {
    attr Bounds = <280,0,670,170>;
  }

  $rect <720,80,890,120>
  slot onPressedContact
  {
    var Application::RecentItm itemView = (Application::RecentItm)sender;
    SelectedContact = itemView.ContactHistory;

    Device::Device.SendCallFromContact( SelectedContact );

    SelectedContact = null;

  }

  $rect <900,160,1060,200>
  var Application::RecentDetailsPage detailsPage;

  $rect <720,160,890,200>
  slot onInfoContact
  {
    var Application::RecentItm itemView = (Application::RecentItm)sender;

    if ( itemView != null )
    {
      detailsPage = new Application::RecentDetailsPage;
      
      detailsPage.Contact = itemView.ContactHistory;
      detailsPage.OnBack = onCloseDetailsPage;
      detailsPage.OnDelete = onCloseDetailsPage;

      detailsPage.HistoryContact = itemView.ContactHistory;
      SwitchToDialog( detailsPage, Res::SlideLeftCentered, null, null, null, null, null,
                               null, null, null, false );
    }
  }

  $rect <720,120,890,160>
  slot onDeleteContact
  {
    var Application::RecentItm itemView = (Application::RecentItm)sender;
    SelectedContact = itemView.ContactHistory;

    Device::Device.History.Remove( SelectedContact );

    postsignal onListItemsUpdated;
    SelectedContact = null;
  }

  $rect <740,200,890,240>
  slot onCloseDetailsPage
  {
    postsignal onListItemsUpdated;
    DismissDialog( detailsPage, Res::SlideRightCentered, null, null, null, null, false);

    SelectedContact = null;
  }

  $rect <890,40,1060,80>
  slot onListItemsUpdated
  {
    VerticalList.NoOfItems = Device::Device.History.NoOfItems;

    VerticalList.InvalidateItems ( 0, VerticalList.NoOfItems -1 );

  }
}

$rect <239,380,409,420>
$output false
class ContactsList : Application::ContactsInsideCall
{
  $rect <20,20,160,60>
  inherited object PlusButton
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  inherited object TextButton
  {
    preset Bounds = <202,24,268,49>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Bounds = <12,0,261,30>;
    preset String = Strings::AddToFavTxt;
    preset Font = Res::ContactFont12;
    preset Color = Res::Black;
  }

  $rect <310,240,510,280>
  property slot OnAddFav;

  $rect <310,50,510,90>
  property Device::Contact Contact = null;

  $rect <310,90,510,130>
  onset Contact
  {
    if ( pure Contact == value )
      return;

    pure Contact = value;

    notifyobservers ^Contact; 
  }

  // Contact data
  note group Note4
  {
    attr Bounds = <290,0,520,190>;
  }

  // Touch screen events
  note group Note8
  {
    attr Bounds = <290,190,740,310>;
  }

  $rect <20,20,160,60>
  inherited object ContactsInsideSearch
  {
    preset OnSelectedContact = onFilteredContactPressed;
  }

  $rect <520,240,720,280>
  inherited slot onContactPressed
  {
    Contact =  ((Application::ContactItem ) sender ).Contact;

    if ( Contact.IsFavorite == false )
    {
      Contact.IsFavorite = true;
      postsignal OnAddFav; 
    }
    else
    {
      trace "ERROR: Contact already in the list";
      postsignal OnCancel;
    }



  }

  $rect <520,290,720,330>
  inherited slot onFilteredContactPressed
  {
    Contact =  ContactsInsideSearch.Contact;

    if ( Contact.IsFavorite == false )
    {
      Contact.IsFavorite = true;
      postsignal OnAddFav; 
    }
    else
    {
      trace "ERROR: Contact already in the list";
      postsignal OnCancel;
    }


  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member PlusButton
  $member onContactPressed
  $member TextButton
  $member Text
  $member OnAddFav
  $member Contact
  $member OnSetContact
  $member Note4
  $member Note8
  $member ContactsInsideSearch
  $member onFilteredContactPressed

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder TextButton 3
  $reorder OnCancel 3
  $reorder onCancel 3
  $reorder Text 3
  $reorder OnAddFav 3
  $reorder Contact 3
  $reorder OnSetContact 3
  $reorder Note4 3
  $reorder Note8 3
}

$rect <239,340,408,380>
$output false
class FavContactItem : Application::ContactItem
{
  $rect <360,0,560,40>
  inherited property Bounds = <0,0,250,32>;

  $rect <10,230,170,270>
  object Effects::Int32Effect EditEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 25;
    preset Value1 = 0;
  }

  $rect <170,250,320,290>
  slot onAnimate
  {
    RemoveButton.Bounds.x    = EditEffect.Value - 25  - DeleteEffect.Value;
    PrfofilButton.Bounds.x   = EditEffect.Value + 6   - DeleteEffect.Value;
    LastNameTxt.Bounds.x     = EditEffect.Value + 55  - DeleteEffect.Value;
    FirstNameTxt.Bounds.x    = EditEffect.Value + 146 - DeleteEffect.Value;
    InfoButton.Bounds.x      = EditEffect.Value + 217  - DeleteEffect.Value;
    TouchHandler.Point1.x    = RemoveButton.Bounds.x2;
    TouchHandler.Point4.x    = RemoveButton.Bounds.x2;
    DeleteButton.Bounds.x    = EditEffect.Value + 273 - DeleteEffect.Value;
  }

  $rect <10,100,210,140>
  property bool EditMode = false;

  $rect <10,140,210,180>
  onset EditMode
  {
    if ( pure EditMode == value )
      return;

    pure EditMode = value;

    EditEffect.Reversed = !EditMode;

    if ( EditMode )
    {
      InfoButton.Icon = Res::MenuIcon;
      InfoButton.IconColor = Res::Grey; 
    }
    else
    {
      InfoButton.Icon = Res::InfoIcon;
      InfoButton.IconColor = Res::Blue;
      
      if ( DeleteEffect.Enabled || DeleteEffect.Value == DeleteEffect.Value2 )
      {
        DeleteEffect.Reversed = true;
        signal DeleteEffect.StartEffect;
      }
    }

    signal EditEffect.StartEffect;



  }

  $rect <10,270,170,310>
  object Effects::Int32Effect DeleteEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 110;
    preset Value1 = 0;
  }

  $rect <350,150,550,190>
  slot onDelete
  {
    DeleteEffect.Reversed = true;
    signal DeleteEffect.StartEffect;
    postsignal OnDelete;
  }

  $rect <350,110,550,150>
  slot onShowDelete
  {
    DeleteEffect.Reversed = false;

    signal DeleteEffect.StartEffect;

  }

  $rect <550,150,750,190>
  property slot OnDelete;

  $rect <350,190,550,230>
  slot onInfo
  {
    signal OnInfo;
  }

  $rect <550,190,750,230>
  property slot OnInfo;

  $rect <20,20,160,60>
  inherited object TouchHandler
  {
    preset StackingPriority = -1;
    preset Point3 = <217,32>;
    preset Point2 = <217,0>;
  }

  $rect <20,20,160,60>
  inherited object Background
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <0,0,250,32>;
  }

  $rect <20,20,160,60>
  inherited object LastNameTxt
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <44,8,113,26>;
    preset AutoSize = true;
  }

  $rect <20,20,160,60>
  object Components::TextButton DeleteButton
  {
    preset Bounds = <250,0,316,32>;
    preset Text = Strings::deleteTxt;
    preset OnActivate = onDelete;
    preset TextColor = Res::White;
    preset TextColorPress = Res::WhiteSemiTransparent;
    preset BackgoundColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 InfoButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <217,5,242,30>;
    preset Icon = Res::InfoIcon;
    preset OnActivate = onInfo;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::WhiteSemiTransparent;
    preset IconFont = Res::IconsFont20;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  inherited object FirstNameTxt
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <131,8,201,26>;
    preset AutoSize = true;
    preset String = "FirstName";
  }

  $rect <20,20,160,60>
  inherited object Line
  {
    preset Point2 = <250,32>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  inherited object PrfofilButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <6,4,31,29>;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <250,0>;
  }

  // Moving effect
  note group Note
  {
    attr Bounds = <0,190,330,330>;
  }

  // Initialization
  note group Note7
  {
    attr Bounds = <0,60,330,190>;
  }

  // Touch screen events
  note group Note8
  {
    attr Bounds = <340,60,800,320>;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 RemoveButton
  {
    preset Bounds = <-25,5,0,30>;
    preset Icon = Res::RemoveIcon;
    preset OnActivate = onShowDelete;
    preset BackgoundColor = Res::Red;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
  }

  // Directives to adapt the order of members belonging to this class so they appear 
  // correctly arranged relative to the members inherited from the ancestor (super) 
  // classes. The numbers indicate the order-displacement to apply on the respective 
  // member once all members have been loaded and combined with members from the 
  // ancestor classes.
  $reorder EditEffect 11
  $reorder onAnimate 11
  $reorder EditMode 11
  $reorder OnSetEditMode 11
  $reorder DeleteEffect 11
  $reorder onDelete 11
  $reorder onShowDelete 11
  $reorder OnDelete 11
  $reorder onInfo 11
  $reorder OnInfo 11
  $reorder DeleteButton 5
  $reorder InfoButton 5
}

$rect <50,590,219,630>
$output false
class RecentItm : Core::Group
{
  $rect <30,450,230,490>
  inherited property Bounds = <0,0,250,50>;

  $rect <580,110,780,150>
  inherited method UpdateViewState()
  {

    super( aState );
    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;

    if (LastNameTxt != null )
    {
      var color clr = ColorText1;
      var Resources::Font font = Res::ContactFontBold15; 
      LastNameTxt.Font  = font;
      LastNameTxt.Color     = clr;
     }
    if (FirstNameTxt!= null)
    {
      var color clr = ColorText1;
      var Resources::Font font = Res::ContactFont15; 
      FirstNameTxt.Font = font;
      FirstNameTxt.Color = clr;
     }

    if (CallTypeTxt != null)
    {
      CallTypeTxt.Font = Res::ContactFont12;
      CallTypeTxt.Color = ColorText2; 
     }

    if (TimeTxt != null)
    {
      TimeTxt.Font = Res::ContactFont12;
      TimeTxt.Color = ColorText2; 
     }



    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GreyLight;
    }
    else
    {
      Background.Color = ButtonColor;
    }



    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // Contact data
  note group Note4
  {
    attr Bounds = <570,330,790,520>;
  }

  // State management
  note group Note5
  {
    attr Bounds = <570,70,790,320>;
  }

  $rect <580,270,780,310>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <580,230,780,270>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <580,190,780,230>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <580,150,780,190>
  var bool enabled;

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <10,108,159,148>
  property string Icon = Res::OutgoingCallIcon;

  $rect <170,110,320,150>
  property string Text = "";

  $rect <170,150,320,190>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <10,270,159,310>
  property color ButtonColor = Res::White;

  $rect <10,310,159,350>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <10,188,159,228>
  property color IconColor = Res::White;

  $rect <10,228,159,268>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <340,390,560,520>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <340,250,560,380>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <340,70,560,240>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <350,430,550,470>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <350,290,550,330>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <350,470,550,510>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <350,330,550,370>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  $rect <10,148,159,188>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <350,190,550,230>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <350,150,550,190>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <10,378,159,418>
  property slot OnActivate = null;

  // This internal slot method is called when the user touches the button's area.
  $rect <350,110,550,150>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,250,52>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <25,52>;
    preset Point3 = <205,52>;
    preset Point2 = <205,0>;
    preset Point1 = <25,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <250,50>;
    preset Point1 = <0,50>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Views::Text LastNameTxt
  {
    preset Bounds = <32,4,114,22>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "LastName";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text FirstNameTxt
  {
    preset StackingPriority = 0;
    preset Layout = Core::Layout[AlignToLeft, ResizeHorz];
    preset Bounds = <114,4,220,22>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "FirstName";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text CallTypeTxt
  {
    preset Bounds = <32,33,101,47>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Call type";
    preset Font = Resources::DefaultFont;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Bounds = <162,22,220,36>;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzRight, AlignVertCenter];
    preset String = "Time ";
    preset Font = Resources::DefaultFont;
  }

  $rect <170,190,320,230>
  property color ColorText1 = Res::Black;

  $rect <170,230,320,270>
  onset ColorText1
  {
    // The value doesn't change - nothing to do.
    if ( pure ColorText1 == value )
      return;

    // Remember the property's new value.
    pure ColorText1 = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <170,270,320,310>
  property color ColorText2 = Res::Grey;

  $rect <170,310,320,350>
  onset ColorText2
  {
    // The value doesn't change - nothing to do.
    if ( pure ColorText2 == value )
      return;

    // Remember the property's new value.
    pure ColorText2 = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 InfoButton
  {
    preset Layout = Core::Layout[ResizeHorz, ResizeVert];
    preset Bounds = <225,2,250,27>;
    preset Icon = Res::InfoIcon;
    preset OnActivate = onInfo;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 IconBtn
  {
    preset Bounds = <0,17,25,42>;
    preset AlphaBlended = true;
    preset Icon = "";
    preset IconColor = Res::Grey;
    preset BackgoundColor = Res::WhiteTransparent;
    preset BackgoundColorPressed = Res::WhiteTransparent;
    preset IconFont = Res::IconsFont20;
    preset Backgound = Res::ButtonRoundSmall;
    preset BackgroundColorEnabled = Res::WhiteTransparent;
  }

  // Design
  note group Note6
  {
    attr Bounds = <0,70,330,520>;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 RemoveButton
  {
    preset Bounds = <-25,11,0,36>;
    preset Icon = Res::RemoveIcon;
    preset OnActivate = onShowDelete;
    preset BackgoundColor = Res::Red;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundSmall;
  }

  $rect <20,20,160,60>
  object Components::TextButton DeleteButton
  {
    preset Bounds = <250,1,316,51>;
    preset Text = Strings::deleteTxt;
    preset OnActivate = onDelete;
    preset TextColor = Res::White;
    preset TextColorPress = Res::WhiteSemiTransparent;
    preset BackgoundColor = Res::Red;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <250,0>;
    preset Point1 = <0,0>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <10,720,170,760>
  object Effects::Int32Effect EditEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 25;
    preset Value1 = 0;
  }

  $rect <180,740,320,780>
  slot onAnimate
  {
    RemoveButton.Bounds.x    = EditEffect.Value - 25  - DeleteEffect.Value;
    IconBtn.Bounds.x = EditEffect.Value + 0   - DeleteEffect.Value;
    LastNameTxt.Bounds.x     = EditEffect.Value + 32  - DeleteEffect.Value;
    FirstNameTxt.Bounds.x    = EditEffect.Value + 114 - DeleteEffect.Value;
    CallTypeTxt.Bounds.x        = EditEffect.Value + 32 - DeleteEffect.Value;
    InfoButton.Bounds.x      = EditEffect.Value + 225  - DeleteEffect.Value;
    TimeTxt.Bounds.x            = EditEffect.Value + 162  - DeleteEffect.Value;
    TouchHandler.Point1.x    = RemoveButton.Bounds.x2;
    TouchHandler.Point4.x    = RemoveButton.Bounds.x2;
    DeleteButton.Bounds.x    = EditEffect.Value + 273 - DeleteEffect.Value;
  }

  $rect <10,570,210,610>
  property bool EditMode = false;

  $rect <10,610,210,650>
  onset EditMode
  {
    // The value doesn't change - nothing to do.
    if ( pure EditMode == value )
      return;

    // Remember the property's new value.
    pure EditMode = value;

    EditEffect.Reversed = !EditMode;

    if ( EditMode )
    {
      InfoButton.Visible = false;
    }
    else
    {
      InfoButton.Visible = true;
      
      if ( DeleteEffect.Enabled || DeleteEffect.Value == DeleteEffect.Value2 )
      {
        DeleteEffect.Reversed = true;
        signal DeleteEffect.StartEffect;
      }
    }

    signal EditEffect.StartEffect;



  }

  $rect <10,760,170,800>
  object Effects::Int32Effect DeleteEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 110;
    preset Value1 = 0;
  }

  // Moving effect
  note group Note
  {
    attr Bounds = <0,670,330,810>;
  }

  // Initialization
  note group Note7
  {
    attr Bounds = <0,530,330,660>;
  }

  $rect <350,620,520,660>
  slot onDelete
  {
    DeleteEffect.Reversed = true;
    signal DeleteEffect.StartEffect;
    postsignal OnDelete;
  }

  $rect <350,580,520,620>
  slot onShowDelete
  {
    DeleteEffect.Reversed = false;
    signal DeleteEffect.StartEffect;

  }

  $rect <520,620,690,660>
  property slot OnDelete;

  $rect <350,660,520,700>
  slot onInfo
  {
    postsignal OnInfo;
  }

  $rect <520,660,690,700>
  property slot OnInfo;

  // Touch screen events
  note group Note8
  {
    attr Bounds = <340,530,700,790>;
  }

  $rect <590,410,780,450>
  onset ContactHistory
  {
    // The value doesn't change - nothing to do.
    if ( pure ContactHistory == value )
      return;

    if ( pure ContactHistory != null )
    {
       detachobserver onContactRistoryUpdate, pure ContactHistory;
    }

    // Remember the property's new value.
    pure ContactHistory = value;

    if ( pure ContactHistory != null )
    {
      attachobserver onContactRistoryUpdate, pure ContactHistory;
      postsignal onContactRistoryUpdate;
    }

  }

  $rect <590,450,780,490>
  slot onContactRistoryUpdate
  {
    if ( pure ContactHistory != null )
    {
      LastNameTxt.String  =  pure ContactHistory.LastName;
      FirstNameTxt.String = pure ContactHistory.FirstName;
      
      if ( pure ContactHistory.CallDirection == Device::CallDirection.Incoming )
        IconBtn.Icon = Res::IncomingCallIcon;
      else
        IconBtn.Icon = Res::OutgoingCallIcon;
      
      CallTypeTxt.String  = pure ContactHistory.GetCallDirection();
      TimeTxt.String      = pure ContactHistory.GetTimeOfCall();
      
      if ( pure ContactHistory.CallState == Device::CallState.Missed )
      {
        ColorText1 = Res::Red;
       }
      else
        ColorText1 = Res::Black;
    }

  }

  $rect <590,370,780,410>
  property Device::HistoryContact ContactHistory = null;
}

$rect <50,630,220,670>
$output false
class RecentDetailsPage : Application::DetailsPage
{
  $rect <320,130,520,170>
  inherited slot onContactUpdated
  {
    if ( pure HistoryContact != null )
    {
      UserInitialsBtn.Icon =  pure HistoryContact.NameInitials;
      ContactName.String   = pure HistoryContact.LastName + " " + pure HistoryContact.FirstName;
      NumberTxt.String     = pure HistoryContact.PhoneNumber; 
      
      DateTxt.String = pure HistoryContact.TimeOfCall.Format( "%d %m %Y" );
      TimeTxt.String = pure HistoryContact.TimeOfCall.Format( "%H:%M %p" );

      if (( HistoryContact.CallState == Device::CallState.EndCall ) &&
          (( HistoryContact.CallDirection == Device::CallDirection.Incoming) ||
           ( HistoryContact.CallDirection == Device::CallDirection.Outgoing )))
      {
        TypeTxt.String     = HistoryContact.GetCallDirection();
        DurationTxt.String = HistoryContact.GetDuration();
      }
      else
      {
        TypeTxt.String     = HistoryContact.GetCallState();
        DurationTxt.String = HistoryContact.GetDuration();
      } 
    }

  }

  $rect <20,20,160,60>
  inherited object Line2
  {
    preset Point2 = <265,371>;
    preset Point1 = <7,371>;
  }

  $rect <20,20,160,60>
  inherited object NumberTxt
  {
    preset Bounds = <19,342,263,371>;
  }

  $rect <20,20,160,60>
  inherited object MobileTxt
  {
    preset Bounds = <7,316,265,349>;
  }

  $rect <20,20,160,60>
  inherited object Line1
  {
    preset Point2 = <265,316>;
    preset Point1 = <7,316>;
  }

  $rect <20,20,160,60>
  object Views::Line Line4
  {
    preset Point2 = <265,237>;
    preset Point1 = <7,237>;
    preset Color = #E2E2E2FD;
  }

  $rect <20,20,160,60>
  object Views::Text DateTxt
  {
    preset Bounds = <8,246,263,267>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "30 nov 2022";
    preset Font = Res::ContactFont15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text TypeTxt
  {
    preset Bounds = <67,267,263,289>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Outgoing Call";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Bounds = <7,267,67,289>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "5:37 PM";
    preset Font = Res::ContactFont12;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text DurationTxt
  {
    preset Bounds = <67,289,263,311>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "22 seconds";
    preset Font = Res::ContactFont12;
    preset Color = Res::Grey;
  }

  $rect <330,90,520,130>
  onset HistoryContact
  {
    // The value doesn't change - nothing to do.
    if ( pure HistoryContact == value )
      return;

    if ( pure HistoryContact != null )
    {
       detachobserver onContactUpdated, pure HistoryContact;
    }

    // Remember the property's new value.
    pure HistoryContact = value;

    if ( pure HistoryContact != null )
    {
      attachobserver onContactUpdated, pure HistoryContact;
      postsignal onContactUpdated;
    }

  }

  $rect <330,50,520,90>
  property Device::HistoryContact HistoryContact;

  // Contact data
  note group Note8
  {
    attr Bounds = <290,0,580,260>;
  }
}

$rect <230,480,410,520>
$output false
class CallBase : Core::Group
{
  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <310,120,510,160>
  slot onContactUpdated
  {
    //if the calling number is in the contact list display info
    if ( pure Contact != null )
    {
      ContactNameTxt.String  = pure Contact.LastName + " "  + pure Contact.FirstName;
      UserInitials.Icon = pure Contact.NameInitials; 
    }
    //if not display number and hide UserInitials
    else
    {
       ContactNameTxt.String = Device::Device.OngoingCalls.GetContactAtIndex( 0 ).PhoneNumber;
       UserInitials.Visible = false;
    }

  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <290,-10,700,190>;
  }

  $rect <310,240,510,280>
  slot onDesclineCall
  {
    if ( Contact.CallDirection ==  Device::CallDirection.Outgoing)
    {
      Device::Device.SendEndCall( Contact.PhoneNumber );
    }
    else if ( Contact.CallDirection ==  Device::CallDirection.Incoming)
    {
      Device::Device.SendEndCall( Contact.PhoneNumber );
    }

  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,200,700,360>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,480>;
    preset ColorBL = #838383FA;
    preset ColorBR = #4F4F4FFF;
    preset ColorTR = #898989FF;
    preset ColorTL = #898989FF;
    preset Color = #3C3C3CFF;
  }

  $rect <20,20,160,60>
  object Components::Button65x90 DesclineButton
  {
    preset Bounds = <36,340,101,432>;
    preset Icon = Res::EndCallIcon;
    preset OnActivate = onDesclineCall;
    preset Descript = Strings::declineTxt;
    preset DescriptColor = Res::White;
    preset BackgoundColor = Res::Red;
    preset BackgoundColorPressed = Res::RedLight;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::ButtonRoundMedium1;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <18,73,91,103>;
    preset Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
    preset String = "calling...";
    preset Font = Res::ContactFont12;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  object Views::Text ContactNameTxt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <18,42,171,72>;
    preset EnableBidiText = false;
    preset AutoSize = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "Contact name";
    preset Font = Res::TitileFont25;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  object Components::ButtonBase70x90 UserInitials
  {
    preset Bounds = <184,28,254,119>;
    preset Enabled = false;
    preset Descript = "";
    preset IconColor = Res::Black;
    preset IconColorEnabled = Res::Black;
    preset IconColorPressed = Res::Grey;
  }

  $rect <310,40,510,80>
  property Device::HistoryContact Contact = null;

  $rect <310,80,510,120>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }
}

$rect <240,720,410,760>
$output false
class ContactsAppInsideCall : Application::PhoneApp
{
  $rect <290,-10,490,30>
  inherited property Bounds = <0,0,272,440>;

  $rect <20,20,160,60>
  inherited object Rectangle
  {
    preset Bounds = <0,400,272,440>;
  }

  $rect <20,20,160,60>
  inherited object NavBarButtons
  {
    preset Bounds = <0,400,68,440>;
  }

  $rect <20,20,160,60>
  inherited object NavBarButtons1
  {
    preset Bounds = <68,400,136,440>;
  }

  $rect <20,20,160,60>
  inherited object NavBarButtons2
  {
    preset Bounds = <136,400,204,440>;
  }

  $rect <20,20,160,60>
  inherited object NavBarButtons3
  {
    preset Bounds = <204,400,272,440>;
  }

  $rect <20,20,160,60>
  object Components::TextButton TextButton
  {
    preset Bounds = <170,14,236,39>;
    preset Text = Strings::CancelTxt;
    preset OnActivate = onCancel;
  }

  $rect <290,40,490,80>
  property slot OnCancel;

  $rect <490,40,690,80>
  slot onCancel
  {
    postsignal OnCancel;
  }
}

$rect <50,380,219,419>
$output false
class MyCardItem : Core::Group
{
  $rect <230,100,430,140>
  inherited method Init()
  {
    attachobserver onContactUpdated, ^Device::Device.MyContact;
    postsignal onContactUpdated; 

  }

  $rect <10,500,210,540>
  inherited property Bounds = <0,0,260,45>;

  $rect <10,100,210,140>
  inherited method UpdateViewState()
  {

    super( aState );

    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GreyLight;
      }

    // Enabled but not pressed nor selected.
    else
    {
      Background.Color = ButtonColor;
    }

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <580,0,780,40>
  property string Icon;

  $rect <790,0,990,40>
  property string Text = "";

  $rect <790,40,990,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <990,0,1190,40>
  property color ButtonColor = Res::White;

  $rect <990,40,1190,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <1190,0,1390,40>
  property color IconColor = Res::White;

  $rect <1190,40,1390,80>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <580,40,780,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <370,0,570,40>
  property slot OnActivate = null;

  $rect <1390,0,1590,40>
  property color TextColor = Res::Black;

  // State management
  note group Note5
  {
    attr Bounds = <0,60,220,310>;
  }

  $rect <10,260,210,300>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <10,220,210,260>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <10,180,210,220>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <10,140,210,180>
  var bool enabled;

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <460,320,680,450>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <230,320,450,450>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <0,320,220,490>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <470,360,670,400>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <240,360,440,400>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <470,400,670,440>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <240,400,440,440>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <10,440,210,480>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <10,400,210,440>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <10,360,210,400>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <230,140,430,180>
  slot onContactUpdated
  {
    if ( Device::Device.MyContact != null )
    {
      NameTxt.String  = Device::Device.MyContact.LastName + " " +  Device::Device.MyContact.FirstName;
      PushButtonSmall1.Icon  =  Device::Device.MyContact.NameInitials;
    }
    else
    {
      NameTxt.String  = "";
      PushButtonSmall1.Icon  =  "";
    }
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,41>;
    preset Point3 = <260,41>;
    preset Point2 = <260,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,260,45>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Views::Text NameTxt
  {
    preset Bounds = <59,2,255,32>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::MyCardTxt;
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Text MyCardTxt
  {
    preset Bounds = <59,24,156,44>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::MyCardTxt;
    preset Font = Res::ContactFont12;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::SButton50x50 PushButtonSmall1
  {
    preset Bounds = <6,0,56,48>;
    preset Backgound = Res::ButtonRoundMedium;
  }

  // Card data
  note group Note4
  {
    attr Bounds = <220,60,440,270>;
  }
}

// Messages
note group Note1
{
  attr Bounds = <439,219,919,559>;
}

$rect <460,260,660,300>
$output false
class MessagesApp : Core::Group
{
  $rect <310,30,520,70>
  inherited method Init()
  {
    attachobserver onUpdateList, ^Device::Device.MessageHistory.NoOfItems;
    postsignal onUpdateList;

  }

  $rect <309,89,509,129>
  inherited property Bounds = <0,0,273,480>;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <300,290,500,330>
  slot OnLoadItem
  {
    // Get the number of the item to load.
    var int32 itemNo = VerticalList.Item;

    var Device::Contact          contact     = Device::Device.MessageHistory.GetContactAtIndex( itemNo );
    var Application::MessegeItem messageItem = (Application::MessegeItem)VerticalList.View;
                                                  
    if ( messageItem == null )
      return;

    messageItem.Contact    = contact;
    messageItem.OnActivate = onOpenChat;
    messageItem.EditMode   = EditMode;
    messageItem.OnCheck    = onSelectedChats;

    messageItem.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );


  }

  $rect <740,169,920,209>
  property bool EditMode = false;

  $rect <920,169,1130,209>
  slot onEdit
  {
    EditMode = !EditMode;

    editBtn.Text      = !EditMode ? "Edit" : "Cancel";
    deleteBtn.Visible = !EditMode ? false : true;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems -1 );
  }

  $rect <920,40,1130,80>
  slot onAddChat
  {
    addNewChat = new Application::ContactsListInsideMessages;

    addNewChat.OnCancel = onCloseAdd;
    addNewChat.OnAddFav = onAdd;
    addNewChat.Contact  = new Device::Contact;

    SwitchToDialog( addNewChat, Res::SlideUpCenteredLimit, null, null, null, null, null, null, null, null, false );
  }

  $rect <740,40,920,80>
  var Application::ContactsListInsideMessages addNewChat = null;

  $rect <940,120,1130,160>
  slot onCloseAdd
  {
    DismissDialog( addNewChat, Res::SlideDownCentered, null, null, null, null, false );
    addNewChat = null;
  }

  $rect <940,80,1130,120>
  slot onAdd
  {
    Device::Device.MessageHistory.AddFirst( addNewChat.Contact );

    postsignal onUpdateList;
    postsignal onCloseAdd;
  }

  // Touch screen events
  note group Note
  {
    attr Bounds = <720,-10,1149,289>;
  }

  // Initialization
  note group Note2
  {
    attr Bounds = <289,-10,709,180>;
  }

  $rect <520,370,700,410>
  var Application::ChatPage chat = null;

  $rect <330,410,520,450>
  slot onBack
  {
    signal onUpdateList;

    DismissDialog( chat, Res::SlideDownCentered, null, null, null, null, false );   
    chat = null;
  }

  $rect <929,220,1129,260>
  slot onDelete
  {
    if ( SelectedContacts != null )
    {
      var Device::ContactListElement contact = SelectedContacts.head;

      while ( contact != null )
      {
        var Device::Contact mCont = Device::Device.MessageHistory.FindByPhoneNumber( contact.Data.PhoneNumber );
      
        if ( mCont != null )
        {
           Device::Device.MessageHistory.Remove( mCont );
           mCont.MessagesList.RemoveAll( );
         }
           
        contact = contact.next;
      } 
    }

    postsignal onEdit;
    postsignal onUpdateList;
  }

  $rect <509,240,709,280>
  slot onUpdateList
  {
    VerticalList.NoOfItems = Device::Device.MessageHistory.NoOfItems;

    VerticalList.InvalidateItems( 0, Device::Device.MessageHistory.NoOfItems -1 );
  }

  $rect <310,370,520,410>
  slot onOpenChat
  {
    var Application::MessegeItem itemView = (Application::MessegeItem)sender;

    if ( itemView != null )
    {
      chat = new Application::ChatPage; 
      chat.Contact = itemView.Contact;
      chat.OnBack  = onBack;
      
      SwitchToDialog( chat, Res::SlideUpCentered, null, null, null, null, null, null, null, null, false );
    }
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,272,480>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,122,272,466>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 45;
    preset ItemClass = Application::MessegeItem;
  }

  $rect <20,20,160,60>
  object Components::InputBtnEtxt SearchExt
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToRight, AlignToTop, ResizeHorz];
    preset Bounds = <3,80,269,112>;
    preset OnChange = onSearch;
    preset String = "";
    preset Color = Res::Grey;
    preset Placeholder = "Type..";
    preset OnIcon = onCancelSearch;
  }

  $rect <20,20,160,60>
  object Views::Text TitleTxt
  {
    preset Bounds = <11,40,264,80>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::MessagesTxt;
    preset Font = Res::TitileFont32;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 createBtn
  {
    preset Bounds = <239,15,264,40>;
    preset Icon = Res::WriteIcon;
    preset OnActivate = onAddChat;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont20;
    preset BackgroundColorEnabled = Res::Transparent;
  }

  $rect <20,20,160,60>
  object Components::TextButton editBtn
  {
    preset Bounds = <11,15,59,40>;
    preset Text = Strings::EditTxt;
    preset OnActivate = onEdit;
  }

  $rect <20,20,160,60>
  object Components::TextButton deleteBtn
  {
    preset Bounds = <62,15,109,40>;
    preset Visible = false;
    preset Text = Strings::DeleteContactTxt;
    preset OnActivate = onDelete;
  }

  $rect <310,330,520,370>
  slot onSelectedChats
  {
    var Application::MessegeItem messageItem = (Application::MessegeItem)sender;

    if ( messageItem.Contact )
      SelectedContacts.AddFirst( messageItem.Contact );
      
    else
      SelectedContacts.Remove( messageItem.Contact );

  }

  $rect <520,330,700,370>
  object Device::ContactsList SelectedContacts;

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -1;
    preset Bounds = <11,122,272,466>;
    preset SlideHorz = false;
  }

  $rect <740,349,940,389>
  slot onSearch
  {
    if ( SearchExt.String != "" )
    {
      Device::Device.MessageHistory.Search( SearchExt.String );

      ContactsInsideSearch.Bounds.origin = <0,11>;

      SearchExt.Icon = Res::XIcon;
    }
    else
    {
      postsignal onCancelSearch;
    }
  }

  $rect <740,389,940,429>
  slot onCancelSearch
  {
    Device::Device.MessageHistory.CancelSearch();

    ContactsInsideSearch.Bounds.origin.y = Bounds.y2;


    SearchExt.String      = "";
    SearchExt.Placeholder = "Type...";
    SearchExt.Text.String = SearchExt.String + "\n";
    SearchExt.Icon        = Res::SerachIcon;
  }

  // Search
  note group Note3
  {
    attr Bounds = <720,305,1149,489>;
  }

  $rect <20,20,160,60>
  object Application::ContactsInsideSearch ContactsInsideSearch
  {
    preset Bounds = <1,500,273,980>;
    preset OnSelectedContact = onOpenChat;
  }

  // VerticalList
  note group Note4
  {
    attr Bounds = <289,189,709,489>;
  }
}

$rect <480,306,660,346>
$output false
class MessegeItem : Core::Group
{
  $rect <750,290,950,330>
  inherited property Bounds = <0,0,269,45>;

  $rect <10,100,210,140>
  inherited method UpdateViewState()
  {
    super( aState );

    var bool isEnabled  = aState.contains( Core::ViewState[ Enabled  ]);
    var bool isSelected = aState.contains( Core::ViewState[ Selected ]);
    var bool isPressed  = ( TouchHandler.Down && TouchHandler.Inside ) || 
                            FlashTimer.Enabled;


    if ( !isEnabled )
    {
      Background.Color = ButtonColor;
    }

    else if ( isPressed )
    {
      Background.Color = Res::PressColor;
    }

    else if ( isSelected )
    {
      Background.Color =  Res::GreyLight;
    }
    else
    {
      Background.Color = ButtonColor;
    }

    enabled  = isEnabled;
    selected = isSelected;
    pressed  = isPressed;


  }

  // The property 'Label' specifies the text to display as label in this push button \
  // widget. The desired font as well as the colors for all individual button states \
  // have to be specified in the configuration object assigned to the property @Appearance. \
  // If there is no configuration object associated to this push button widget (the \
  // property @Appearance is 'null'), no label is displayed.
  // Per default, the label is displayed centered within the push button area. You \
  // can modify the alignment of the label as well as its margins by specifying them \
  // in the configuration object.
  $rect <580,0,780,40>
  property string Icon;

  $rect <790,0,990,40>
  property string Text = "";

  $rect <790,40,990,80>
  onset Text
  {
    // The value doesn't change - nothing to do.
    if ( pure Text == value )
      return;

    // Remember the property's new value.
    pure Text = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <990,0,1190,40>
  property color ButtonColor = Res::White;

  $rect <990,40,1190,80>
  onset ButtonColor
  {
    // The value doesn't change - nothing to do.
    if ( pure ButtonColor == value )
      return;

    // Remember the property's new value.
    pure ButtonColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <580,80,780,120>
  property color IconColor = Res::White;

  $rect <580,120,780,160>
  onset IconColor
  {
    // The value doesn't change - nothing to do.
    if ( pure IconColor == value )
      return;

    // Remember the property's new value.
    pure IconColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();

  }

  $rect <580,40,780,80>
  onset Icon
  {
    // The value doesn't change - nothing to do.
    if ( pure Icon == value )
      return;

    // Remember the property's new value.
    pure Icon = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  // The property 'OnActivate' can refer to a slot method, which will receive a signal \
  // as soon as the user has activated the button. Thereupon the method's logic will \
  // be executed.
  $rect <370,0,570,40>
  property slot OnActivate = null;

  $rect <790,90,990,130>
  property color TextColor = Res::Black;

  // State management
  note group Note5
  {
    attr Bounds = <0,60,220,310>;
  }

  $rect <10,260,210,300>
  var Views::Text textView;

  // This variable stores the current state of the button.
  $rect <10,220,210,260>
  var bool pressed;

  // This variable stores the current state of the button.
  $rect <10,180,210,220>
  var bool selected;

  // This variable stores the current state of the button.
  $rect <10,140,210,180>
  var bool enabled;

  // Feedback flash effect
  note group Note3
  {
    attr Bounds = <460,320,680,480>;
  }

  // Keyboard events
  note group Note2
  {
    attr Bounds = <230,320,450,490>;
  }

  // Touch screen events
  note group Note1
  {
    attr Bounds = <0,320,220,490>;
  }

  // This timer object is used to flash the button when the user has tapped it very \
  // quickly or the button has been activated with the keyboard. This is just a visual \
  // feedback effect.
  $rect <470,360,670,400>
  object Core::Timer FlashTimer
  {
    preset OnTrigger = onFlashTimer;
    preset Period = 0;
    preset Begin = 50;
  }

  // This key handler reacts to key press events. When the user presses the key specified \
  // in the property 'Filter' of the key handler, the handler is activated and the \
  // method '@onPressKey' is called.
  $rect <240,360,440,400>
  object Core::KeyPressHandler KeyHandler
  {
    preset OnPress = onPressKey;
    preset Filter = Core::KeyCode.Enter;
  }

  // This internal slot method is called when the '@FlashTimer' is expired. It ends \
  // the short flash feedback effect.
  $rect <470,400,670,440>
  slot onFlashTimer
  {
    // The feedback flash timer is finished. Request the button to update its
    // appearance. The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // With the end of the feedback flash effect the button is activated.
    postsignal OnActivate;
  }

  // This internal slot method is called when the '@KeyHandler' is activated (when \
  // the user has pressed the key specified in the property 'Filter' of the key handler).
  $rect <240,400,440,440>
  slot onPressKey
  {
    // Ignore keyboard events when the user is interacting with the button via the
    // touch screen.
    if ( TouchHandler.Down )
      return;

    // Ignore repetitions of key events (e.g. when the user holds the key pressed)
    if ( KeyHandler.Repetition )
      return;

    // Pressing the key flashes the button for a short period. This is a kind of 
    // feedback effect. Request the button to update its appearance accordingly.
    // The update will occur in the UpdateViewState() method.
    InvalidateViewState();

    // The button is still performing the feedback flash effect from the preceding
    // tap/key event. This can occur when the user taps the button or presses the
    // key in a very rapid succession. Thus complete this preceding tap (simulate
    // the timer expiration) before starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }

    // Start the feedback flash effect.
    FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user drags the finger while pressing \
  // the button. This only updates the button to appear pressed or released.
  $rect <10,440,210,480>
  slot onEnterLeaveTouch
  {
    // Every time the user touches the button or drags the finger inside/outside
    // the button's area request the button update its appearance. The update will
    // occur in the UpdateViewState() method.
    InvalidateViewState();
  }

  // This internal slot method is called when the user releases the touch screen \
  // after touching the button's area. This activates the button.
  $rect <10,400,210,440>
  slot onReleaseTouch
  {
    // Did the user moved the finger outside the button's area? In such case
    // the button is not activated.
    if ( !TouchHandler.Inside )
      return;

    // The user interaction has been passed over to the another touch handler
    if ( TouchHandler.AutoDeflected )
      return;

    // The user has pressed and held the button for longer time. This was enough
    // long to give a visual 'press' feedback to the user. The button can be
    // activated immediately.
    if ( TouchHandler.HoldPeriod >= FlashTimer.Begin )
      postsignal OnActivate;

    // The user has tapped the button very quickly. Defer the button activation
    // to give the user first a short visual feedback that the button has been
    // pressed.
    else
      FlashTimer.Enabled = true;
  }

  // This internal slot method is called when the user touches the button's area.
  $rect <10,360,210,400>
  slot onPressTouch
  {
    // The button is still performing the feedback flash effect from the preceding
    // tap. This can occur when the user taps the button in a very rapid succession. 
    // Thus complete this preceding tap (simulate the timer expiration) before 
    // starting a new button interaction.
    if ( FlashTimer.Enabled )
    {
      postsignal OnActivate;
      FlashTimer.Enabled = false;
    }
  }

  $rect <230,190,430,230>
  slot onContactUpdated
  {
    if ( Contact != null )
    {
      NameTxt.String     = pure Contact.LastName + " "  + pure Contact.FirstName;
      UserIcon.Icon      = pure Contact.NameInitials;  
      CheckButton.Active = false;
      if ( Contact.MessagesList.head != null )
      {
        MessageTxt.String = pure Contact.MessagesList.GetLastMessage().MessageContent;//"last message";    
        TimeTxt.String    = pure Contact.MessagesList.GetLastMessage().GetTimeOfCall();//"l.m. time";
        ArrowBtn.Visible  = true;
        
        NotificationButton.Descript = pure Contact.UnreadMessagesNr;
        NotificationButton.Visible  = pure Contact.UnreadMessagesNr > 0;
      } 
      else 
      {
        MessageTxt.String = "";    
        TimeTxt.String    = "";
        ArrowBtn.Visible  = false;  
      }
    }
  }

  // Card data
  note group Note4
  {
    attr Bounds = <220,60,440,310>;
  }

  $rect <790,130,990,170>
  onset TextColor
  {
    // The value doesn't change - nothing to do.
    if ( pure TextColor == value )
      return;

    // Remember the property's new value.
    pure TextColor = value;

    // ... and trigger the component to update its actual state.
    InvalidateViewState();
  }

  $rect <10,690,170,730>
  object Effects::Int32Effect EditEffect
  {
    preset OnAnimate = onAnimate;
    preset NoOfCycles = 1;
    preset CycleDuration = 250;
    preset Value2 = 30;
    preset Value1 = 0;
  }

  $rect <180,690,320,730>
  slot onAnimate
  {
    CheckButton.Bounds.x = EditEffect.Value - 30 ;
    UserIcon.Bounds.x    = EditEffect.Value;
    NameTxt.Bounds.x     = EditEffect.Value + 56;
    MessageTxt.Bounds.x  = EditEffect.Value + 56;
    TimeTxt.Bounds.x     = EditEffect.Value + 145 ;
    ArrowBtn.Bounds.x    = EditEffect.Value + 251;

  }

  $rect <10,540,210,580>
  property bool EditMode = false;

  $rect <10,580,210,620>
  onset EditMode
  {
    // The value doesn't change - nothing to do.
    if ( pure EditMode == value )
      return;

    // Remember the property's new value.
    pure EditMode = value;

    EditEffect.Reversed = !EditMode;

    signal EditEffect.StartEffect;



  }

  // Moving effect
  note group Note
  {
    attr Bounds = <0,640,330,800>;
  }

  // Initialization
  note group Note7
  {
    attr Bounds = <0,500,330,630>;
  }

  $rect <230,110,430,150>
  property Device::Contact Contact = null;

  $rect <230,150,430,190>
  onset Contact
  {
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
    }
    postsignal onContactUpdated;

  }

  $rect <10,730,170,770>
  slot onCheck
  {
    if ( CheckButton.Active == true )
      postsignal OnCheck;  

  }

  $rect <180,730,320,770>
  property slot OnCheck;

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,269,45>;
    preset ColorBL = #FDFDFDC8;
    preset ColorBR = #FDFDFDC8;
    preset Color = #FFFFFFFF;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler TouchHandler
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Point4 = <0,44>;
    preset Point3 = <269,44>;
    preset Point2 = <269,0>;
    preset Point1 = <0,0>;
    preset OnLeave = onEnterLeaveTouch;
    preset OnEnter = onEnterLeaveTouch;
    preset OnRelease = onReleaseTouch;
    preset OnPress = onPressTouch;
    preset RetargetCondition = Core::RetargetReason[WipeDown, WipeLeft, WipeRight, WipeUp];
    preset MaxStrikeCount = 100;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 ArrowBtn
  {
    preset Bounds = <251,-3,276,22>;
    preset Visible = false;
    preset Icon = Res::ForwardIcon;
    preset IconColor = Res::Grey;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont12;
    preset Backgound = Res::ButtonRoundSmall;
    preset BackgroundColorEnabled = Res::Transparent;
    preset IconColorEnabled = Res::GreyLight;
    preset IconColorPressed = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Text TimeTxt
  {
    preset Bounds = <145,3,258,15>;
    preset Alignment = Views::TextAlignment[AlignHorzRight];
    preset String = "Time ";
    preset Font = Resources::DefaultFont;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Line Line2
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <269,45>;
    preset Point1 = <50,44>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Views::Text MessageTxt
  {
    preset Bounds = <56,24,257,44>;
    preset Ellipsis = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = Strings::messageTxt;
    preset Font = Res::ContactFont12;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Views::Text NameTxt
  {
    preset Bounds = <56,2,232,24>;
    preset Alignment = Views::TextAlignment[AlignHorzLeft, AlignVertCenter];
    preset String = "name";
    preset Font = Res::ContactFontBold15;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Components::SButton50x50 UserIcon
  {
    preset Bounds = <0,0,50,48>;
    preset Backgound = Res::ButtonRoundMedium;
  }

  $rect <20,20,160,60>
  object Components::ToggleButton CheckButton
  {
    preset StackingPriority = 1;
    preset Bounds = <-35,7,0,42>;
    preset OnToggle = onCheck;
    preset BackgroundColor = Res::GreyLight;
    preset IconSelectedColor = Res::White;
  }

  $rect <20,20,160,60>
  object Views::Line Line1
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Point2 = <269,0>;
    preset Point1 = <50,0>;
    preset Width = 2;
    preset Color = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 NotificationButton
  {
    preset StackingPriority = 0;
    preset Bounds = <0,-3,50,47>;
    preset Visible = false;
    preset Icon = Res::CircleFillIcon;
    preset DescriptColor = Res::White;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont20;
    preset BackgroundColorEnabled = Res::Transparent;
    preset DescriptColorEnabled = Res::Transparent;
    preset IconColorEnabled = Res::Transparent;
    preset DescriptColorPressed = Res::White;
    preset IconColorPressed = Res::BlueLight;
  }
}

$rect <480,346,660,386>
$output false
class ContactsListInsideMessages : Application::ContactsList
{
  $rect <20,20,160,60>
  inherited object TitleTxt
  {
    preset String = Strings::NewMessage;
  }

  $rect <20,20,160,60>
  inherited object Text
  {
    preset Visible = false;
  }

  $rect <20,20,160,60>
  inherited object ContactsInsideSearch
  {
    preset OnSelectedContact = Slot2;
  }

  $rect <481,302,681,342>
  slot Slot2
  {
    //add contact to favorites
    Contact =  ContactsInsideSearch.Contact;

    postsignal OnAddFav; 
  }

  $rect <290,0,490,40>
  inherited slot onContactPressed
  {
    Contact =  ((Application::ContactItem ) sender ).Contact;

    postsignal OnAddFav; 
  }

  // Directives to adapt the order of the above members according to how these members 
  // where arranged when the project content was stored. In this manner the storage 
  // and the expected order of the members don't depend. Merging of changes in the 
  // project files is simplified.
  $member TitleTxt
  $member onContactPressed
  $member Text
  $member ContactsInsideSearch
  $member Slot2
}

$rect <480,386,660,426>
$output false
class ChatPage : Core::Group
{
  $rect <300,40,500,80>
  inherited method Init()
  {
  }

  $rect <10,500,210,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <500,250,700,290>
  slot onBack
  {
    postsignal OnBack;

  }

  $rect <500,300,700,340>
  slot onUser
  {
    detailsPage = new Application::DetailsPage;

    detailsPage.OnBack  = onCloseUser;
    detailsPage.Contact = Contact;

    SwitchToDialog( detailsPage, Res::SlideUpCenteredLimit, null, null, null, null, null,
                               null, null, null, false );

  }

  $rect <500,390,700,430>
  slot onCall
  {
    Device::Device.SendCallFromContact( Contact );
  }

  $rect <300,250,500,290>
  var slot OnBack;

  $rect <300,300,500,340>
  var Application::DetailsPage detailsPage = null;

  $rect <530,340,700,380>
  slot onCloseUser
  {
    DismissDialog( detailsPage, Res::SlideDownCentered, null, null, null, null, false );
    detailsPage = null;
  }

  // Displayed contact info
  note group Note1
  {
    attr Bounds = <680,0,950,200>;
  }

  $rect <700,90,890,130>
  onset Contact
  {
    // The value doesn't change - nothing to do.
    if ( pure Contact == value )
      return;

    if ( pure Contact != null )
    {
       detachobserver onContactUpdated, pure Contact;
    }

    // Remember the property's new value.
    pure Contact = value;

    if ( pure Contact != null )
    {
      attachobserver onContactUpdated, pure Contact;
      postsignal onContactUpdated;
    }

  }

  $rect <700,130,890,170>
  slot onContactUpdated
  {
    if ( pure Contact != null )
    {
      Button40x55.Descript = pure Contact.FirstName;  
      Button40x55.Icon     =  pure Contact.NameInitials;
    }

    signal onMessageUpdate;
  }

  $rect <700,50,890,90>
  property Device::Contact Contact = null;

  // Touch screen events
  note group Note
  {
    attr Bounds = <290,210,710,540>;
  }

  $rect <500,440,700,480>
  slot onSend
  {
    if ( SearchEtxt.String != "")
    {
      Device::Device.SendMessage( Contact, SearchEtxt.String );
      SearchEtxt.Text.String = " ";
    }


  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Bounds = <0,0,272,480>;
    preset Color = Res::White;
  }

  $rect <20,20,160,60>
  object Core::Outline Outline
  {
    preset Bounds = <0,69,272,435>;
    preset SlideHandler = SlideTouchHandler;
    preset Space = 1;
    preset Formation = Core::Formation.BottomToTop;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset Bounds = <0,69,272,435>;
    preset SlideHorz = false;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Header
  {
    preset Bounds = <0,0,272,60>;
    preset Color = Res::PressColor;
  }

  $rect <20,20,160,60>
  object Views::Line Line
  {
    preset Point2 = <272,60>;
    preset Point1 = <0,60>;
    preset Color = Res::Grey;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 BackBtn
  {
    preset Bounds = <7,4,32,29>;
    preset Icon = Res::BackIcon;
    preset OnActivate = onBack;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont20;
    preset BackgroundColorEnabled = Res::Transparent;
  }

  $rect <20,20,160,60>
  object Components::InputBtnEtxt SearchEtxt
  {
    preset Bounds = <3,441,269,473>;
    preset String = "";
    preset Color = Res::Black;
    preset Placeholder = "Type...";
    preset Icon = Res::SendIcon;
    preset OnIcon = onSend;
  }

  $rect <20,20,160,60>
  object Components::SButton25x25 BackBtn1
  {
    preset Bounds = <241,4,266,29>;
    preset Icon = Res::CallIcon;
    preset OnActivate = onCall;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset IconFont = Res::IconsFont20;
    preset BackgroundColorEnabled = Res::Transparent;
  }

  $rect <20,20,160,60>
  object Components::Button40x55 Button40x55
  {
    preset Bounds = <90,5,182,60>;
    preset OnActivate = onUser;
    preset Descript = "name";
    preset DescriptColor = Res::Black;
    preset Backgound = Res::ButtonRoundMedium;
  }

  $rect <300,90,500,130>
  slot onMessageUpdate
  {
    RemoveMessages();

    if ( pure Contact != null && pure Contact.MessagesList.head != null)
    {
      var Components::TextButton unreadText = new Components::TextButton;
      unreadText.Text = "Unread";
      unreadText.TextTxt.Alignment = Views::TextAlignment[AlignHorzCenter, AlignVertCenter];
      unreadText.TextTxt.Font = Res::ContactFontBold15;
      unreadText.TextColor = Res::Grey;  
      unreadText.BackgoundColor = Res::PressColor;
      unreadText.Bounds.h = 20;
      unreadText.Bounds.w = 272;
      
      lastItem = null;
      
      var bool isAdded = false;
      var int32 order = -1; 
      var Device::Message message = pure Contact.MessagesList.head;  
        
      while ( message != null)
      {
        var Application::ChatItem chatItem = new Application::ChatItem;
        
        chatItem.OnDelete = onDeleteMessage;
        
        if ( !message.IsSeen )
        {    
          if ( !isAdded )
          {
            unreadText.Embedded = true;
            Add( unreadText, order-- );
                  
            isAdded = true;
          }
          message.IsSeen = true;
        }
            
        if ( message.Sender == Device::Device.MyContact )
        {
          chatItem.LeftAligned  = false;
          chatItem.BubbleColor  = Res::Blue;
          chatItem.Message      = message;
          chatItem.MessageColor = Res::White; 
         }
        else if ( message.Receiver == Device::Device.MyContact )
        {
          chatItem.LeftAligned  = true;
          chatItem.BubbleColor  = Res::GreyLight;
          chatItem.Message      = message;
          chatItem.MessageColor = Res::Black; 
         }
        
        chatItem.Embedded = true;                            
        Add( chatItem, order-- );
        
        if ( lastItem == null )
          lastItem = chatItem;
        
        message = message.next;
      }
      
      Contact.UnreadMessagesNr = 0;

      Outline.ScrollOffset = <0,0>;
    }
    Device::Device.MessageHistory.FindUnreadMessagesNr();
  }

  $rect <300,130,500,170>
  method void RemoveMessages()
  {
    var Core::View view = Outline.FindNextView( null, Core::ViewState[ Embedded ] );
    while ( view != null )
    {
     // if ((Application::ChatItem)view != null )
       if ( view != null )
         Remove( view );

      view = Outline.FindNextView( null, Core::ViewState[ Embedded ] );
    }

  }

  $rect <510,90,660,130>
  var Application::ChatItem lastItem = null;

  // Initialization
  note group Note2
  {
    attr Bounds = <290,0,670,200>;
  }

  $rect <500,490,700,530>
  slot onDeleteMessage
  {
    var Application::ChatItem chatitm = (Application::ChatItem)sender;

    Contact.MessagesList.Remove( chatitm.Message );

    trace Contact.MessagesList.TraceMessages();

    postsignal onMessageUpdate;
  }
}

// Application
note group Note2
{
  attr Bounds = <0,0,430,210>;
}

$rect <500,426,660,466>
$output false
class ChatItem : Core::Group
{
  $rect <90,120,290,160>
  inherited property Bounds = <0,0,272,55>;

  $rect <300,110,500,150>
  inherited method UpdateViewState()
  {
    // Always invoke the inherited method.
    super( aState );

    if ( LeftAligned == false )
    {
      ChatOutline.Bitmap = Res::ChatRight;  
      ChatOutline.Layout = Core::Layout[AlignToRight, AlignToTop];
      
      Text.Layout = Core::Layout[AlignToRight, AlignToTop];
      Text.Bounds.x= 272 - Text.GetContentArea().w - 20;
      Text.Bounds.y = 10;
    }
    else if ( LeftAligned == true )
    {
      ChatOutline.Bitmap = Res::ChatLeft;
      
      Text.Bounds.x = 15;
      Text.Bounds.y = 10;
    }

    ChatOutline.Color = BubbleColor;

    Text.Color  = MessageColor;
    Text.Alignment = Views::TextAlignment[AlignHorzLeft];

    Backgound.Color = Res::Transparent;
  }

  $rect <300,0,500,40>
  property bool LeftAligned = false;

  $rect <300,40,500,80>
  onset LeftAligned
  {
    // The value doesn't change - nothing to do.
    if ( pure LeftAligned == value )
      return;

    // Remember the property's new value.
    pure LeftAligned = value;

    InvalidateViewState();
  }

  $rect <510,110,710,150>
  property Device::Message Message = null;

  $rect <510,150,710,190>
  onset Message
  {
    if ( pure Message == value )
      return;

    pure Message = value;

    postsignal onUpdateMessage;
  }

  $rect <710,0,910,40>
  property color BubbleColor = Res::GreyLight;

  $rect <710,40,910,80>
  onset BubbleColor
  {
    // The value doesn't change - nothing to do.
    if ( pure BubbleColor == value )
      return;

    // Remember the property's new value.
    pure BubbleColor = value;

    InvalidateViewState();
  }

  $rect <510,0,710,40>
  property color MessageColor = Res::Black;

  $rect <730,100,930,140>
  var slot OnDelete;

  $rect <930,100,1130,140>
  slot onPress
  {
    DeleteBtn.Enabled = DeleteBtn.Enabled == true ? false : true;
    DeleteBtn.Visible = DeleteBtn.Visible == true ?  false : true;
     
    Backgound.Color = Backgound.Color == Res::BlueLight1 ? Res::Transparent : Res::BlueLight1;
  }

  $rect <510,190,710,230>
  slot onUpdateMessage
  {
    if ( Message != null) 
    {
      Text.String = Message.MessageContent;
    }
  }

  $rect <930,150,1130,190>
  slot onDelete
  {
    postsignal OnDelete;
  }

  $rect <10,200,210,240>
  slot onUpdateText
  {
    if ( LeftAligned == false )
    {
      ChatOutline.Bounds    = Text.GetContentArea() * <10,10>;
      ChatOutline.Bounds.h += 10;
        
      DeleteBtn.Bounds.x    = 5;
    }
    else if ( LeftAligned == true )
    {
      ChatOutline.Bounds    = Text.GetContentArea() * <10,10>;
      ChatOutline.Bounds.h += 10;
      ChatOutline.Layout    = Core::Layout[AlignToRight, AlignToTop];
    }

    Bounds.h = ChatOutline.Bounds.y2;

    Backgound.Bounds.h = Bounds.h;
  }

  $rect <510,40,710,80>
  onset MessageColor
  {
    // The value doesn't change - nothing to do.
    if ( pure MessageColor == value )
      return;

    // Remember the property's new value.
    pure MessageColor = value;

    InvalidateViewState();
  }

  $rect <20,20,160,60>
  object Views::Rectangle Backgound
  {
    preset Bounds = <-2,0,272,50>;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <0,0>;
    preset Point3 = <272,0>;
    preset Point2 = <272,48>;
    preset Point1 = <0,48>;
    preset OnPress = onPress;
  }

  $rect <20,20,160,60>
  object Views::Frame ChatOutline
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <34,60,239,150>;
    preset Bitmap = Res::ChatLeft;
    preset NoEdgesLimit = <220,0>;
  }

  $rect <20,20,160,60>
  object Views::Text Text
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <186,9,202,21>;
    preset Padding = 2;
    preset Ellipsis = true;
    preset OnUpdate = onUpdateText;
    preset AutoSize = true;
    preset WrapWidth = 195;
    preset WrapText = true;
    preset Alignment = Views::TextAlignment[AlignHorzLeft];
    preset String = "text";
    preset Font = Res::ContactFont15;
  }

  $rect <20,20,160,60>
  object Components::TextButton DeleteBtn
  {
    preset Bounds = <221,10,268,35>;
    preset Enabled = false;
    preset Visible = false;
    preset Text = "Delete";
    preset OnActivate = onDelete;
    preset TextColor = Res::White;
    preset TextColorPress = Res::GreyLight;
  }
}

$rect <30,720,210,760>
$output false
class ContactsInsideSearch : Core::Group
{
  $rect <280,0,480,40>
  inherited method Init()
  {
    attachobserver onNoOfContactsChanged, ^Device::Device.FilteredContacts.NoOfItems;
    postsignal onNoOfContactsChanged;


  }

  $rect <280,40,480,80>
  inherited property Bounds = <0,0,272,480>;

  // This method is called by 'VerticalList' every time the list loads or updates \
  // an item.
  $rect <280,110,480,150>
  slot OnLoadItem
  {
    var int32 itemNo = VerticalList.Item;

    var Device::Contact contact = Device::Device.FilteredContacts.GetContactAtIndex( itemNo );

    var Application::ContactItem itemView = (Application::ContactItem)VerticalList.View;
                                                  
    if ( itemView == null )
      return;

    itemView.Contact    = contact;
    itemView.OnActivate = onSelectedContact;

    itemView.Bounds.size = point( VerticalList.Bounds.w, VerticalList.ItemHeight );
  }

  $rect <480,0,690,40>
  slot onNoOfContactsChanged
  {
    VerticalList.NoOfItems = Device::Device.FilteredContacts.NoOfItems;

    VerticalList.InvalidateItems( 0, VerticalList.NoOfItems - 1 );

  }

  $rect <20,20,160,60>
  object Views::Rectangle Background
  {
    preset Layout = Core::Layout[AlignToBottom, AlignToLeft, AlignToRight, AlignToTop, ResizeHorz, ResizeVert];
    preset Bounds = <0,100,272,481>;
  }

  $rect <20,20,160,60>
  object Core::VerticalList VerticalList
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <11,111,261,435>;
    preset OnLoadItem = OnLoadItem;
    preset SlideHandler = SlideTouchHandler;
    preset ItemHeight = 32;
    preset ItemClass = Application::ContactItem;
  }

  $rect <20,20,160,60>
  object Core::SlideTouchHandler SlideTouchHandler
  {
    preset StackingPriority = -1;
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <12,100,261,435>;
    preset SnapNext = <0,35>;
    preset SlideHorz = false;
  }

  $rect <510,410,710,450>
  slot onSelectedContact
  {
    Contact =  ((Application::ContactItem ) sender ).Contact;

    signal OnSelectedContact; 
  }

  $rect <300,410,500,450>
  property slot OnSelectedContact;

  $rect <300,220,500,260>
  property Device::Contact Contact = null;

  $rect <300,260,500,300>
  onset Contact
  {
    if ( pure Contact == value )
      return;

    pure Contact = value;

    notifyobservers ^Contact; 
  }

  // Contact data
  note group Note4
  {
    attr Bounds = <280,170,510,360>;
  }

  // Touch screen events
  note group Note8
  {
    attr Bounds = <280,360,730,480>;
  }
}

$rect <10,40,210,80>
$output false
class Application : Core::Root
{
  $rect <310,40,510,80>
  inherited method Init()
  {
    postsignal onPresentSplash;

    attachobserver onCallState, ^Device::Device.OngoingCalls.NoOfItems;

    postsignal onCallState;

    //SetMyNumber( 2 );

  }

  $rect <-10,500,190,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <530,60,730,100>
  slot onCallState
  {
    if ( Contact != null)
      detachobserver onCallState, Contact;

    Contact = (Device::HistoryContact)Device::Device.OngoingCalls.GetContactAtIndex( 0 );

    if ( ongoingPage != null )
    {
      DismissDialog( ongoingPage, Res::FadeInOutCentered, null, null, null, null, false );

      ongoingPage = null;
    }  

    if ( Contact != null )
    {
      if ( Contact.CallState == Device::CallState.Cancelled || 
           Contact.CallState == Device::CallState.EndCall ||
           Contact.CallState == Device::CallState.Rejected || 
           Contact.CallState == Device::CallState.Missed )
      {
        DismissDialog( ongoingPage, Res::FadeInOutCentered, null, null, null, null, false );
      }
      if ( Contact.CallDirection == Device::CallDirection.Incoming )
      {
        if ( Contact.CallState == Device::CallState.Speaking )
        {
          ongoingPage          = new Application::OngoingCall;
          ongoingPage.Contact = Contact;
        }
        else
        {
          ongoingPage = new Application::IncomingCall;
          ongoingPage.Contact = Contact;
        }
        
        PresentDialog( ongoingPage, Res::FadeInOutCentered, null, null, null, null, null, null, null, false );
      }
      else if ( Contact.CallDirection == Device::CallDirection.Outgoing )
      {
        ongoingPage = new Application::OngoingCall;
        ongoingPage.Contact = Contact;
        PresentDialog( ongoingPage, Res::FadeInOutCentered, null, null, null, null, null, null, null, false );
      }
      attachobserver onCallState, Contact;
      
    }

  }

  $rect <580,10,780,50>
  var Device::DeviceClass deviceInstance = Device::Device;

  $rect <540,100,710,140>
  var Application::CallBase ongoingPage = null;

  $rect <540,140,710,180>
  var Device::HistoryContact Contact = null;

  $rect <300,320,530,360>
  slot onPhoneAppPressed
  {
    phoneApp = new Application::PhoneApp;

    PresentDialog( phoneApp, null, null, null, null, null, null, null, null, false );
  }

  $rect <300,280,530,320>
  slot onMessagesAppPressed
  {
    messageApp = new Application::MessagesApp;

    PresentDialog( messageApp, null, null, null, null, null, null, null, null, false );
  }

  $rect <530,320,740,360>
  var Application::PhoneApp phoneApp;

  $rect <530,280,740,320>
  var Application::MessagesApp messageApp;

  $rect <300,360,530,400>
  slot onPresentSplash
  {
    splashScreen = new Application::SplashScreen;

    splashScreen.OnStart = onDismissSplash;

    PresentDialog( splashScreen, null, null, null, null, null, null, null, null, false );
  }

  $rect <320,400,530,440>
  slot onDismissSplash
  {
    DismissDialog( splashScreen, null, null, null, null, null, false );

    postsignal onHomeBtnPressed;
  }

  $rect <530,360,740,400>
  var Application::SplashScreen splashScreen;

  $rect <300,440,530,480>
  slot onHomeBtnPressed
  {
    var Application::HomePage page = new Application::HomePage;

    PresentDialog( page, null, null, null, null, null, null, null, null, false );
  }

  $rect <310,125,510,165>
  $output true
  method void SetMyNumber( arg int32 aMyNumber )
  {
    myID = aMyNumber;

    idlesignal onSetMyContact;

  }

  $rect <310,165,510,205>
  slot onSetMyContact
  {
    Device::Device.MyContact = Device::Device.Contacts.FindContactByID( myID );


  }

  $rect <310,80,510,120>
  var int32 myID;

  // Initialization
  note group Note
  {
    attr Bounds = <290,0,780,220>;
  }

  // Touchscreen events
  note group Note1
  {
    attr Bounds = <290,230,770,490>;
  }
}

$rect <31,121,231,161>
$output false
class HomePage : Core::Group
{
  $rect <320,30,530,70>
  inherited method Init()
  {
    attachobserver ShowUnreadMessages, ^Device::Device.MessageHistory.UnreadMessagesNr;
    postsignal ShowUnreadMessages;

  }

  $rect <0,500,200,540>
  inherited property Bounds = <0,0,272,480>;

  $rect <300,377,500,417>
  slot onPhoneAppPressed
  {
    phoneApp = new Application::PhoneApp;

    PresentDialog( phoneApp, null, null, null, null, null, null, null, null, false );
  }

  $rect <300,425,500,465>
  slot onMessagesAppPressed
  {
    messageApp = new Application::MessagesApp;

    PresentDialog( messageApp, null, null, null, null, null, null, null, null, false );
  }

  $rect <500,377,700,417>
  var Application::PhoneApp phoneApp;

  $rect <500,425,700,465>
  var Application::MessagesApp messageApp;

  $rect <300,250,500,290>
  slot onSettingsAppPressed
  {
    settingsApp = new Application::EditPage;

    settingsApp.Bounds.h = 480;
    settingsApp.DeleteBtn.Enabled = false;

    if ( Device::Device.MyContact )
      settingsApp.Contact = Device::Device.MyContact;
    else
      settingsApp.Contact = new Device::Contact;
      
    settingsApp.OnClose = onClose;
    settingsApp.OnSave  = onSave;

    PresentDialog( settingsApp, null, null, null, null, null, null, null, null, false );
  }

  $rect <500,250,700,290>
  var Application::EditPage settingsApp = null;

  $rect <320,290,500,330>
  slot onClose
  {
    DismissDialog( settingsApp, null, null, null, null, null, false );

    settingsApp = null;
  }

  $rect <320,330,500,370>
  slot onSave
  {
    Device::Device.MyContact = settingsApp.Contact;
    Device::Device.Contacts.AddLast( settingsApp.Contact );

    postsignal onClose;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <0,0,272,480>;
    preset Color = #FFFFFFFF;
    preset Bitmap = Res::background;
  }

  $rect <20,20,160,60>
  object Components::Button50x75 Button50x77
  {
    preset Bounds = <3,4,53,79>;
    preset Icon = Res::SettingsIcon;
    preset OnActivate = onSettingsAppPressed;
    preset Descript = "Settings";
    preset DescriptColor = Res::Grey;
    preset BackgoundColorPressed = #AAAAAAFF;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::SuqareButton;
    preset DescriptColorPressed = Res::Grey;
    preset IconColorPressed = Res::PressColor;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Footer
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <0,420,272,480>;
    preset ColorBL = #94949496;
    preset ColorBR = #B9B9B9AD;
    preset ColorTR = #C3C3C3B0;
    preset ColorTL = #CDCDCDDA;
    preset Color = #79797986;
  }

  $rect <20,20,160,60>
  object Components::SButton50x50 Contacts
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <53,425,103,475>;
    preset Icon = Res::CallIcon;
    preset OnActivate = onPhoneAppPressed;
    preset BackgoundColor = Res::GreenDark;
    preset BackgoundColorPressed = Res::Green;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::SuqareButton;
    preset IconColorPressed = Res::GreyLight;
  }

  $rect <20,20,160,60>
  object Components::SButton50x50 Messeges
  {
    preset Layout = Core::Layout[AlignToLeft, AlignToTop];
    preset Bounds = <170,425,220,475>;
    preset Icon = Res::MessageIcon;
    preset OnActivate = onMessagesAppPressed;
    preset BackgoundColor = Res::GreenDark;
    preset BackgoundColorPressed = Res::Green;
    preset IconFont = Res::IconsFont25;
    preset Backgound = Res::SuqareButton;
    preset IconColorPressed = Res::GreyLight;
  }

  $rect <320,80,530,120>
  slot ShowUnreadMessages
  {
    if ( Device::Device.MessageHistory.UnreadMessagesNr != 0 )
    {
      NotificationBtn.Visible  = true;
      NotificationBtn.Descript = (int32)Device::Device.MessageHistory.UnreadMessagesNr;
    }
    else
      NotificationBtn.Visible = false;
      

  }

  $rect <20,20,160,60>
  object Components::SButton50x50 NotificationBtn
  {
    preset StackingPriority = 0;
    preset Bounds = <195,400,245,450>;
    preset Icon = Res::CircleFillIcon;
    preset DescriptColor = Res::White;
    preset IconColor = Res::Blue;
    preset BackgoundColor = Res::Transparent;
    preset BackgoundColorPressed = Res::Transparent;
    preset DescriptFont = Res::ContactFont12;
    preset IconFont = Res::IconsFont25;
    preset BackgroundColorEnabled = Res::Transparent;
    preset DescriptColorEnabled = Res::Transparent;
    preset IconColorEnabled = Res::Transparent;
    preset DescriptColorPressed = Res::White;
    preset IconColorPressed = Res::BlueLight;
  }

  // Initialization
  note group Note
  {
    attr Bounds = <290,-10,590,190>;
  }

  // Touchscreen events
  note group Note1
  {
    attr Bounds = <290,200,720,480>;
  }
}

$rect <31,81,231,121>
$output false
class SplashScreen : Core::Group
{
  $rect <320,460,520,500>
  inherited property Bounds = <0,0,272,480>;

  // To do:
  // 
  // - Adjust the visible size of your component (the thick blue border).
  // 
  // - The simplest way to compose the appearance of the component is to use the \
  // 'Views' and 'Widget Sets' from the Gallery.
  // 
  // - To react to touch or keyboard events use the templates from the Gallery folder \
  // 'Event Handlers'.
  // 
  // - To perform transitions (animations) use the templates from the Gallery folder \
  // 'Effects'.
  // 
  // - To implement the interface of the component use the 'Property' template from \
  // the Gallery folder 'Chora'.
  // 
  // - To store values use the 'Variable' and 'Array' templates available in the \
  // Gallery folder 'Chora'.
  // 
  // - To implement behavior use the 'Method' and 'Slot Method' templates available \
  // in the Gallery folder 'Chora'.
  // 
  // - In the method 'UpdateViewState()' you can put code to update the state of \
  // views enclosed in your component.
  // 
  // - In the method 'UpdateLayout()' you can put code to perform sophisticated layout \
  // calculation for enclosed views.
  note legend Note1
  {
    attr Bounds = <580,620,1360,940>;
  }

  $rect <20,20,160,60>
  object Views::Rectangle Rectangle
  {
    preset Bounds = <0,0,272,480>;
    preset ColorBL = #5E5E5EFF;
    preset ColorBR = #000000FF;
    preset ColorTL = #F0F0F0FF;
    preset Color = Res::Black;
  }

  $rect <20,20,160,60>
  object Views::Image Image
  {
    preset Bounds = <101,205,171,275>;
    preset Bitmap = Res::logog;
  }

  $rect <20,20,160,60>
  object Core::SimpleTouchHandler SimpleTouchHandler
  {
    preset Point4 = <1,0>;
    preset Point3 = <272,0>;
    preset Point2 = <271,480>;
    preset Point1 = <0,480>;
    preset OnPress = onScreenTouched;
  }

  $rect <290,10,490,50>
  slot onScreenTouched
  {
    postsignal OnStart;
  }

  $rect <490,10,690,50>
  var slot OnStart;
}
